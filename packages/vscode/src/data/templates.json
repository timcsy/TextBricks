{
  "languages": [
    {
      "id": "c",
      "name": "c",
      "displayName": "C",
      "extension": ".c",
      "icon": "file-text"
    },
    {
      "id": "python",
      "name": "python",
      "displayName": "Python",
      "extension": ".py",
      "icon": "file-text"
    },
    {
      "id": "javascript",
      "name": "javascript",
      "displayName": "JavaScript",
      "extension": ".js",
      "icon": "file-text"
    },
    {
      "id": "cpp",
      "name": "cpp",
      "displayName": "C++",
      "extension": ".cpp",
      "icon": "file-text"
    },
    {
      "id": "arduino",
      "name": "arduino",
      "displayName": "Arduino",
      "extension": ".ino",
      "icon": "file-text"
    },
    {
      "id": "esp32",
      "name": "esp32",
      "displayName": "ESP32",
      "extension": ".ino",
      "icon": "file-text"
    }
  ],
  "topics": [
    {
      "id": "topic-basic",
      "name": "基礎",
      "description": "程式設計基礎概念，適合初學者入門",
      "documentation": "# 基礎程式設計概念\n\n## 學習目標\n這個主題涵蓋程式設計的基本概念，是所有程式學習者的起點。透過這些模板，您將學會：\n\n- **Hello World 程式** - 驗證開發環境並了解程式基本結構\n- **變數宣告** - 學習如何儲存和使用資料\n- **基本輸入輸出** - 與使用者互動的基礎操作\n\n## 適合對象\n- 程式設計初學者\n- 剛開始學習新程式語言的開發者\n- 需要複習基礎概念的學習者\n\n## 學習順序建議\n1. 先從 Hello World 開始，確認環境設置正確\n2. 學習變數宣告，理解資料儲存概念\n3. 練習輸入輸出，學會與程式互動\n\n## 重要概念\n- **程式結構** - 了解程式的基本組成\n- **語法規則** - 掌握每種語言的基本語法\n- **資料型別** - 學習不同型別的資料如何使用",
      "color": "#28a745",
      "icon": "🌱",
      "createdAt": "2025-09-15T08:00:00.000Z",
      "updatedAt": "2025-09-15T08:00:00.000Z"
    },
    {
      "id": "topic-control",
      "name": "控制",
      "description": "流程控制結構，學習程式邏輯分支",
      "documentation": "# 流程控制結構\n\n## 學習目標\n流程控制是程式設計的核心概念，讓程式能夠根據條件執行不同的動作或重複執行特定操作：\n\n- **條件判斷 (if-else)** - 根據條件執行不同的程式碼路徑\n- **迴圈結構 (for, while)** - 重複執行程式碼直到滿足特定條件\n- **邏輯運算** - 組合多個條件進行複雜判斷\n\n## 適合對象\n- 已掌握基礎語法的學習者\n- 需要學習程式邏輯的開發者\n- 想要編寫動態程式的學習者\n\n## 學習順序建議\n1. 從簡單的 if-else 條件判斷開始\n2. 學習 for 迴圈處理已知次數的重複\n3. 掌握 while 迴圈處理未知次數的重複\n4. 練習組合條件和迴圈解決複雜問題\n\n## 實際應用\n- **資料驗證** - 檢查使用者輸入是否有效\n- **清單處理** - 遍歷和處理資料集合\n- **遊戲邏輯** - 實現遊戲規則和互動\n- **自動化腳本** - 重複執行系統任務",
      "color": "#17a2b8",
      "icon": "🔄",
      "createdAt": "2025-09-15T08:00:00.000Z",
      "updatedAt": "2025-09-15T08:00:00.000Z"
    },
    {
      "id": "topic-structure",
      "name": "結構",
      "description": "資料結構與程式組織，學習程式架構",
      "documentation": "# 資料結構與程式組織\n\n## 學習目標\n程式結構化是編寫可維護程式的關鍵。這個主題涵蓋：\n\n- **函數定義** - 將程式碼組織成可重複使用的單元\n- **陣列/列表** - 儲存和操作多個相關資料\n- **物件/字典** - 組織複雜的資料結構\n- **模組化設計** - 分離關注點和提高程式可讀性\n\n## 適合對象\n- 已熟悉基礎語法和流程控制的學習者\n- 需要編寫較大型程式的開發者\n- 想要提升程式設計技能的學習者\n\n## 學習順序建議\n1. 學習函數定義，理解程式碼重用概念\n2. 掌握陣列/列表的基本操作\n3. 學習物件/字典來組織複雜資料\n4. 實作綜合性的專案來應用這些概念\n\n## 設計原則\n- **DRY (Don't Repeat Yourself)** - 避免重複程式碼\n- **單一職責** - 每個函數只做一件事\n- **清晰命名** - 使用有意義的變數和函數名稱\n- **適當註解** - 說明複雜邏輯的目的\n\n## 實際應用\n- **資料處理** - 分析和轉換大量資料\n- **使用者介面** - 組織前端元件和互動\n- **API 開發** - 設計清晰的程式介面\n- **系統架構** - 構建可擴展的應用程式",
      "color": "#fd7e14",
      "icon": "🏗️",
      "createdAt": "2025-09-15T08:00:00.000Z",
      "updatedAt": "2025-09-15T08:00:00.000Z"
    },
    {
      "id": "topic-advanced",
      "name": "進階",
      "description": "進階程式設計概念，適合有經驗的開發者",
      "documentation": "# 進階程式設計概念\n\n## 學習目標\n進階概念讓您能夠編寫更強大、更高效的程式：\n\n- **物件導向程式設計 (OOP)** - 使用類別和物件組織程式碼\n- **記憶體管理** - 理解指標和記憶體分配 (適用於 C)\n- **檔案處理** - 讀寫外部檔案和資料持久化\n- **非同步程式設計** - 處理並發和非阻塞操作 (適用於 JavaScript)\n- **錯誤處理** - 優雅地處理例外狀況\n\n## 適合對象\n- 已熟練掌握基礎程式設計的開發者\n- 需要解決複雜問題的程式設計師\n- 準備進入專業開發領域的學習者\n- 想要深入理解程式語言特性的開發者\n\n## 學習順序建議\n1. 根據語言特性選擇重點學習方向\n2. 從具體例子開始，逐步理解抽象概念\n3. 大量練習和實作，加深理解\n4. 學習最佳實踐和設計模式\n\n## 不同語言的重點\n### C 語言\n- **指標操作** - 直接記憶體存取和管理\n- **結構體** - 自定義資料型別\n- **檔案 I/O** - 系統層級的檔案操作\n\n### Python\n- **類別和繼承** - 完整的 OOP 特性\n- **例外處理** - 使用 try-except 處理錯誤\n- **檔案處理** - 高階檔案操作和編碼處理\n\n### JavaScript\n- **ES6+ 類別** - 現代 JavaScript 的 OOP\n- **Promise 和 async/await** - 非同步程式設計\n- **模組系統** - 程式碼組織和重用\n\n## 專業發展\n這些概念是邁向專業開發的基石，掌握後您將能夠：\n- 參與大型專案開發\n- 設計可擴展的系統架構\n- 解決複雜的技術問題\n- 編寫高品質的生產級程式碼",
      "color": "#6f42c1",
      "icon": "🚀",
      "createdAt": "2025-09-15T08:00:00.000Z",
      "updatedAt": "2025-09-15T08:00:00.000Z"
    },
    {
      "id": "topic-c-building-blocks",
      "name": "C 積木片段",
      "description": "最基礎的 C 語言程式碼積木，適合初學者組合學習",
      "documentation": "# C 積木語法\n\n## 學習目標\n積木式程式設計是一種視覺化的程式學習方法，將複雜的程式概念分解成簡單、可組合的程式碼片段。這個主題提供：\n\n- **基礎輸出入積木** - printf, scanf 等基本輸入輸出操作\n- **變數操作積木** - 變數宣告、賦值、運算等操作\n- **邏輯控制積木** - if-else、for、while 等流程控制\n- **比較運算積木** - 相等、大於、小於等條件判斷\n- **陣列操作積木** - 陣列宣告、存取、設定等基本操作\n\n## 積木式學習的優點\n- **視覺化學習** - 像樂高積木一樣組合程式碼\n- **降低學習門檻** - 專注於邏輯而非語法細節\n- **漸進式學習** - 從簡單積木開始，逐步組合複雜功能\n- **實用性強** - 每個積木都是可直接使用的程式碼\n\n## 適合對象\n- **程式設計初學者** - 第一次接觸程式設計的學習者\n- **年輕學習者** - 中小學生程式教育\n- **視覺化學習者** - 偏好透過具體範例學習的人\n- **快速原型開發** - 需要快速組合基本功能的開發者\n\n## 使用方式\n### 組合式學習\n```c\n// 組合基礎積木建立完整程式\nint number = 0;              // 宣告整數變數積木\nprintf(\"請輸入數字: \");      // 輸出文字積木\nscanf(\"%d\", &number);       // 輸入數字積木\nif (number > 0) {           // 大於比較 + 如果條件積木\n    printf(\"正數\\n\");       // 輸出文字(換行)積木\n} else {                    // 如果否則積木\n    printf(\"非正數\\n\");     // 輸出文字(換行)積木\n}\n```\n\n### 積木分類\n#### 🔧 **基礎操作積木**\n- 輸出文字、輸入數字\n- 變數宣告、賦值\n- 基本運算\n\n#### 🔀 **邏輯控制積木** \n- 條件判斷 (if-else)\n- 迴圈結構 (for, while)\n- 比較運算\n\n#### 📦 **資料結構積木**\n- 陣列操作\n- 變數遞增/遞減\n\n## 學習路徑\n1. **熟悉基礎積木** - 輸出、變數、運算\n2. **學習邏輯積木** - 條件判斷和比較\n3. **掌握迴圈積木** - 重複執行概念\n4. **組合複雜功能** - 多個積木組合解決問題\n5. **自由創作** - 使用積木實現自己的想法\n\n## 教學建議\n### 對於教師\n- 先示範單一積木的功能\n- 展示積木之間的組合方式\n- 鼓勵學生實驗不同的組合\n- 從簡單到複雜逐步引導\n\n### 對於學習者\n- 不要害怕嘗試不同組合\n- 每個積木都可以獨立測試\n- 理解積木的輸入和輸出\n- 嘗試修改積木中的參數值",
      "color": "#ff6b6b",
      "icon": "🧩",
      "createdAt": "2025-09-18T10:00:00.000Z",
      "updatedAt": "2025-09-18T10:00:00.000Z"
    },
    {
      "id": "topic-c-fundamentals",
      "name": "C 基礎程式",
      "description": "C 語言基本程式結構和常用語法",
      "documentation": "# C 基礎程式\n\n## 學習目標\n掌握 C 語言的基本程式結構和核心語法概念，建立紮實的程式設計基礎：\n\n- **程式架構** - #include、main函數、基本語法結構\n- **資料型別** - int、float、char、string 等基本型別\n- **輸入輸出** - printf、scanf 格式化輸入輸出\n- **流程控制** - if-else、for、while、switch 等控制結構\n- **函數基礎** - 函數定義、參數傳遞、回傳值\n- **陣列基礎** - 一維陣列的宣告和使用\n\n## 適合對象\n- 已熟悉積木語法的學習者\n- 想要學習完整程式結構的初學者\n- 準備深入學習 C 語言的學習者\n- 需要複習 C 語言基礎的開發者\n\n## 學習順序建議\n1. **Hello World** - 理解基本程式結構\n2. **變數與資料型別** - 學習資料儲存概念\n3. **輸入輸出** - 掌握與使用者互動\n4. **條件判斷** - 學習程式邏輯分支\n5. **迴圈結構** - 理解重複執行概念\n6. **函數定義** - 程式模組化基礎\n7. **陣列操作** - 處理多個相關資料\n\n## 重要概念\n- **編譯型語言** - 理解編譯和執行過程\n- **型別安全** - 變數型別的重要性\n- **記憶體概念** - 變數在記憶體中的儲存\n- **語法規則** - C 語言的基本語法約定\n\n## 程式設計原則\n- **結構化** - 使用適當的控制結構\n- **可讀性** - 清晰的變數命名和註解\n- **模組化** - 將功能分解成函數\n- **除錯技巧** - 學習找出和修正錯誤\n\n## 實際應用\n- **數學計算** - 數值運算和方程式求解\n- **資料處理** - 簡單的資料分析和統計\n- **小工具** - 實用的命令列程式\n- **學習基礎** - 為進階主題打下基礎",
      "color": "#17a2b8",
      "icon": "📚",
      "createdAt": "2025-09-18T10:15:00.000Z",
      "updatedAt": "2025-09-18T10:15:00.000Z"
    },
    {
      "id": "topic-c-advanced",
      "name": "C 進階特性",
      "description": "C 語言進階語法特性和資料結構",
      "documentation": "# C 進階特性\n\n## 學習目標\n深入學習 C 語言的進階語法特性，掌握複雜程式設計技巧：\n\n- **指標操作** - 指標宣告、解參考、指標運算\n- **動態記憶體** - malloc、free、記憶體管理\n- **結構體** - 自定義資料型別和複雜資料組織\n- **檔案處理** - 檔案讀寫和資料持久化\n- **字串處理** - 字串函數和字元陣列操作\n- **函數指標** - 回呼函數和動態函數調用\n- **巨集和預處理器** - 程式碼生成和條件編譯\n- **多檔案專案** - 標頭檔、模組化程式設計\n\n## 適合對象\n- 已掌握 C 基礎程式的學習者\n- 想要深入理解記憶體管理的開發者\n- 準備開發系統程式的程式設計師\n- 需要處理複雜資料結構的學習者\n\n## 學習順序建議\n1. **指標基礎** - 理解記憶體位址概念\n2. **結構體** - 組織複雜資料\n3. **動態記憶體** - 運行時記憶體分配\n4. **字串處理** - 文字資料操作\n5. **檔案操作** - 資料持久化\n6. **函數指標** - 進階函數技巧\n7. **多檔案專案** - 大型程式組織\n\n## 核心概念\n- **記憶體管理** - 手動管理記憶體分配和釋放\n- **資料結構** - 鏈結串列、樹狀結構、雜湊表\n- **演算法** - 排序、搜尋、遞迴技巧\n- **程式架構** - 模組化設計和介面定義\n\n## 程式設計技巧\n- **指標安全** - 避免空指標和記憶體洩漏\n- **錯誤處理** - 檢查函數回傳值和錯誤碼\n- **效能優化** - 記憶體使用和運算效率\n- **除錯技術** - 使用 gdb 和除錯工具\n\n## 實際應用\n- **資料結構實作** - 自製 vector、map 等容器\n- **演算法實現** - 排序、搜尋演算法\n- **系統程式** - 作業系統和驅動程式基礎\n- **嵌入式開發** - 微控制器和 IoT 裝置",
      "color": "#fd7e14",
      "icon": "🔧",
      "createdAt": "2025-09-18T10:20:00.000Z",
      "updatedAt": "2025-09-18T10:20:00.000Z"
    },
    {
      "id": "topic-c-system",
      "name": "C 系統程式",
      "description": "C 語言系統程式設計和底層操作",
      "documentation": "# C 系統程式設計\n\n## 學習目標\n學習 C 語言在系統程式設計領域的應用，掌握底層程式設計技術：\n\n- **行程管理** - fork、exec、wait 等行程控制\n- **執行緒程式設計** - pthread、同步和通訊機制\n- **訊號處理** - 系統訊號的捕捉和處理\n- **行程間通訊** - 管道、共享記憶體、訊息佇列\n- **網路程式設計** - Socket 程式設計基礎\n- **檔案系統** - 底層檔案操作和權限管理\n- **記憶體映射** - mmap、共享記憶體區段\n- **系統呼叫** - 直接與作業系統核心互動\n\n## 適合對象\n- 已熟練掌握 C 進階特性的開發者\n- 想要理解作業系統原理的學習者\n- 準備開發系統軟體的程式設計師\n- 嵌入式系統和 IoT 開發者\n\n## 學習順序建議\n1. **檔案系統操作** - 底層檔案讀寫\n2. **行程管理** - 建立和控制子行程\n3. **訊號處理** - 系統事件響應\n4. **管道通訊** - 行程間資料傳遞\n5. **共享記憶體** - 高效能資料交換\n6. **網路程式設計** - 網路通訊基礎\n7. **執行緒程式設計** - 並行程式設計\n\n## 核心技術\n- **POSIX 標準** - 可攜式作業系統介面\n- **並行程式設計** - 多行程、多執行緒程式\n- **同步機制** - 互斥鎖、條件變數、號誌\n- **IPC 機制** - 各種行程間通訊方法\n\n## 系統程式特點\n- **效能要求** - 高效率和低延遲\n- **資源管理** - 精確控制系統資源\n- **錯誤處理** - 健壯的錯誤恢復機制\n- **安全考量** - 權限檢查和安全程式設計\n\n## 實際應用\n- **作業系統核心** - Linux、Windows 驅動程式\n- **伺服器程式** - Web 伺服器、資料庫系統\n- **嵌入式系統** - 即時作業系統 (RTOS)\n- **網路服務** - 路由器、防火牆軟體\n- **工具程式** - 系統管理和監控工具",
      "color": "#6c757d",
      "icon": "⚙️",
      "createdAt": "2025-09-18T10:25:00.000Z",
      "updatedAt": "2025-09-18T10:25:00.000Z"
    },
    {
      "id": "topic-cpp-fundamentals",
      "name": "C++ 基礎語法",
      "description": "C++ 程式語言核心語法和基本概念",
      "documentation": "# C++ 基礎語法\n\n## 學習目標\n掌握 C++ 程式語言的核心語法和基本概念，為後續學習物件導向和硬體編程奠定堅實基礎：\n\n- **變數與資料型別** - 基本資料型別、變數宣告、型別轉換\n- **運算子與表達式** - 算術、邏輯、比較和位元運算\n- **輸入輸出** - cout、cin 和基本格式化\n- **流程控制** - if-else、for、while 迴圈結構\n- **函數基礎** - 函數定義、參數傳遞、回傳值\n- **陣列與字串** - 一維陣列、字元陣列、string 類別\n\n## 適合對象\n- C++ 程式設計初學者\n- 有其他語言經驗但初學 C++ 的開發者\n- 準備學習 Arduino 或 ESP32 的學習者\n- 需要複習 C++ 基礎的學習者\n\n## 學習順序建議\n1. **Hello World** - 認識基本程式結構\n2. **變數宣告** - 學習資料型別和記憶體概念\n3. **輸入輸出** - 掌握與使用者互動的方式\n4. **運算子** - 理解各種運算和表達式\n5. **流程控制** - 學習程式邏輯結構\n6. **函數** - 程式模組化的基礎\n7. **陣列與字串** - 處理複雜資料結構\n\n## 重要概念\n- **編譯型語言** - 理解編譯過程和執行檔概念\n- **型別安全** - C++ 的強型別系統特性\n- **記憶體管理** - 區域變數和記憶體分配基礎\n- **標準庫** - iostream、string 等常用標準庫\n\n## 實際應用\n- **科學計算** - 數值運算和資料處理\n- **系統程式** - 作業系統和驅動程式開發\n- **嵌入式系統** - Arduino、ESP32 等微控制器編程\n- **遊戲開發** - 高效能遊戲引擎開發",
      "color": "#007acc",
      "icon": "📝",
      "createdAt": "2025-09-17T09:00:00.000Z",
      "updatedAt": "2025-09-17T09:00:00.000Z"
    },
    {
      "id": "topic-cpp-oop",
      "name": "C++ 物件導向",
      "description": "物件導向程式設計概念與 C++ 類別系統",
      "documentation": "# C++ 物件導向程式設計\n\n## 學習目標\n深入理解物件導向程式設計 (OOP) 的核心概念，並掌握 C++ 類別系統的使用：\n\n- **類別與物件** - 類別定義、物件建立、成員變數和方法\n- **建構子與解構子** - 物件生命週期管理\n- **存取控制** - public、private、protected 存取修飾符\n- **繼承** - 單一繼承、多重繼承、虛擬繼承\n- **多型** - 虛擬函數、抽象類別、動態綁定\n- **運算子重載** - 自定義運算子行為\n- **友元函數** - 類別間的特殊存取權限\n\n## 適合對象\n- 已掌握 C++ 基礎語法的學習者\n- 想要學習現代程式設計思維的開發者\n- 準備開發大型軟體專案的程式設計師\n- 需要理解 Arduino 函式庫架構的學習者\n\n## 學習順序建議\n1. **簡單類別** - 基本類別定義和物件使用\n2. **建構子** - 物件初始化和資源管理\n3. **存取控制** - 封裝概念和資料保護\n4. **繼承基礎** - 程式碼重用和擴展\n5. **虛擬函數** - 多型和動態行為\n6. **運算子重載** - 直觀的物件操作\n7. **進階繼承** - 複雜的類別階層設計\n\n## 設計原則\n- **封裝** - 隱藏實作細節，提供清晰介面\n- **繼承** - 程式碼重用和階層關係建立\n- **多型** - 統一介面處理不同類型物件\n- **抽象** - 關注本質特徵，忽略具體細節\n\n## 實際應用\n- **GUI 程式設計** - 視窗、按鈕等 UI 組件\n- **遊戲開發** - 角色、道具、場景物件\n- **Arduino 函式庫** - 感測器、致動器類別設計\n- **企業軟體** - 業務邏輯和資料模型",
      "color": "#28a745",
      "icon": "🏗️",
      "createdAt": "2025-09-17T09:00:00.000Z",
      "updatedAt": "2025-09-17T09:00:00.000Z"
    },
    {
      "id": "topic-cpp-advanced",
      "name": "C++ 進階特性",
      "description": "C++ 進階語法特性和現代 C++ 標準",
      "documentation": "# C++ 進階特性\n\n## 學習目標\n掌握 C++ 的進階語法特性和現代 C++ 標準，提升程式設計能力和代碼品質：\n\n- **模板** - 函數模板、類別模板、特化和偏特化\n- **STL 標準庫** - 容器、迭代器、演算法\n- **智慧指標** - unique_ptr、shared_ptr、weak_ptr\n- **例外處理** - try-catch、例外安全性\n- **Lambda 表達式** - 匿名函數和函數式程式設計\n- **現代 C++ 特性** - auto、範圍for、move語意\n- **記憶體管理** - 動態分配、RAII、移動語意\n\n## 適合對象\n- 已熟練掌握 C++ 基礎和 OOP 的開發者\n- 想要編寫高效能程式的程式設計師\n- 需要維護大型 C++ 專案的開發者\n- 準備學習現代 C++ 最佳實踐的學習者\n\n## 學習順序建議\n1. **函數模板** - 泛型程式設計入門\n2. **STL 容器** - vector、list、map 等常用容器\n3. **迭代器** - 統一的資料存取介面\n4. **智慧指標** - 現代記憶體管理\n5. **例外處理** - 錯誤處理和程式健壯性\n6. **Lambda 表達式** - 函數式程式設計\n7. **移動語意** - 效能優化技術\n\n## 技術重點\n- **泛型程式設計** - 編寫可重用的程式碼\n- **記憶體安全** - 避免記憶體洩漏和懸掛指標\n- **效能優化** - 減少不必要的複製和分配\n- **錯誤處理** - 優雅地處理例外狀況\n- **程式碼品質** - 可讀性、可維護性、可測試性\n\n## 現代 C++ 標準\n- **C++11/14** - auto、範圍for、智慧指標、Lambda\n- **C++17/20** - 結構化綁定、概念、協程\n- **最佳實踐** - RAII、DRY、SOLID 原則\n\n## 實際應用\n- **高效能運算** - 科學計算和數值分析\n- **系統程式設計** - 作業系統和資料庫\n- **嵌入式系統** - 資源受限環境的優化\n- **函式庫開發** - 可重用組件和 API 設計",
      "color": "#6f42c1",
      "icon": "⚡",
      "createdAt": "2025-09-17T09:00:00.000Z",
      "updatedAt": "2025-09-17T09:00:00.000Z"
    },
    {
      "id": "topic-arduino-hardware",
      "name": "Arduino 硬體基礎",
      "description": "Arduino 微控制器基本操作和 I/O 控制",
      "documentation": "# Arduino 硬體基礎\n\n## 學習目標\n掌握 Arduino 微控制器的基本操作，學習數位和類比 I/O 控制，建立硬體編程的基礎能力：\n\n- **Arduino 基礎** - 開發環境、程式結構、序列監控器\n- **數位 I/O** - pinMode、digitalWrite、digitalRead\n- **類比 I/O** - analogRead、analogWrite (PWM)\n- **時間控制** - delay、millis、micros\n- **序列通訊** - Serial.print、Serial.read\n- **中斷處理** - attachInterrupt、外部中斷\n- **腳位配置** - 認識 Arduino Uno 腳位功能\n\n## 適合對象\n- 硬體編程初學者\n- 有程式基礎但初接觸硬體的開發者\n- 電子 DIY 愛好者\n- 想要學習物聯網開發的學習者\n\n## 硬體需求\n- **Arduino Uno/Nano** - 入門級開發板\n- **LED** - 發光二極體 (紅、綠、藍)\n- **電阻** - 220Ω、10kΩ 限流和上拉電阻\n- **按鈕開關** - 數位輸入元件\n- **可變電阻** - 類比輸入元件\n- **麵包板** - 無焊接電路實驗\n- **杜邦線** - 連接線材\n\n## 學習順序建議\n1. **LED 閃爍** - 數位輸出基礎\n2. **按鈕控制** - 數位輸入基礎\n3. **PWM 調光** - 類比輸出概念\n4. **類比讀取** - 感測器數值讀取\n5. **序列通訊** - 資料傳輸和除錯\n6. **多工處理** - millis() 非阻塞式程式設計\n7. **中斷處理** - 即時響應外部事件\n\n## 重要概念\n- **數位訊號** - HIGH/LOW、0/1 二進位狀態\n- **類比訊號** - 連續變化的電壓值\n- **PWM (脈寬調變)** - 模擬類比輸出\n- **上拉電阻** - 確保數位輸入的穩定狀態\n- **去彈跳** - 處理機械開關的雜訊\n- **非阻塞式程式設計** - 避免 delay() 造成的程式停頓\n\n## 電路基礎\n- **歐姆定律** - V = I × R，電壓、電流、電阻關係\n- **LED 限流** - 保護 LED 避免燒毀\n- **開關電路** - 上拉和下拉電阻配置\n- **分壓電路** - 電壓分配和訊號調整\n\n## 實際應用\n- **自動化控制** - 燈光、風扇、馬達控制\n- **環境監測** - 溫度、濕度、光線感測\n- **互動裝置** - 按鈕、開關、感測器回應\n- **教育專案** - STEM 教學和創客教育",
      "color": "#ff6b35",
      "icon": "🔌",
      "createdAt": "2025-09-17T09:00:00.000Z",
      "updatedAt": "2025-09-17T09:00:00.000Z"
    },
    {
      "id": "topic-arduino-sensors",
      "name": "Arduino 感測器與致動器",
      "description": "各種感測器與致動器的使用和整合應用",
      "documentation": "# Arduino 感測器與致動器\n\n## 學習目標\n學習各種感測器的使用方法，掌握致動器控制技術，建構完整的輸入輸出系統：\n\n- **溫濕度感測器** - DHT11/DHT22、DS18B20\n- **光線感測器** - 光敏電阻 (LDR)、光電二極體\n- **距離感測器** - 超音波 HC-SR04、紅外線\n- **運動感測器** - 加速度計、陀螺儀、PIR\n- **伺服馬達** - 角度控制和位置回饋\n- **步進馬達** - 精確轉動控制\n- **直流馬達** - 速度和方向控制\n- **感測器融合** - 多感測器數據整合\n\n## 適合對象\n- 已掌握 Arduino 基礎 I/O 的學習者\n- 想要製作互動專案的 Maker\n- 需要環境監測功能的開發者\n- 機器人和自動化系統愛好者\n\n## 硬體需求\n### 感測器模組\n- **DHT22** - 溫濕度感測器\n- **HC-SR04** - 超音波距離感測器\n- **LDR** - 光敏電阻\n- **PIR** - 人體紅外線感測器\n- **MPU6050** - 6軸慣性感測器\n\n### 致動器模組\n- **SG90** - 微型伺服馬達\n- **28BYJ-48** - 步進馬達 + ULN2003 驅動板\n- **直流馬達** + L298N 驅動模組\n- **蜂鳴器** - 有源/無源蜂鳴器\n\n### 輔助元件\n- **電晶體** - 2N2222、TIP120 功率放大\n- **二極體** - 1N4007 反向保護\n- **電容器** - 濾波和穩壓\n\n## 學習順序建議\n1. **溫度感測** - 單一感測器數據讀取\n2. **光線偵測** - 環境感測和自動控制\n3. **距離測量** - 超音波感測器應用\n4. **伺服控制** - 精確角度定位\n5. **馬達控制** - 運動控制基礎\n6. **多感測器** - 複合感測系統\n7. **智慧控制** - 感測器回饋控制\n\n## 技術重點\n- **類比數位轉換** - ADC 原理和解析度\n- **訊號調理** - 放大、濾波、線性化\n- **校正和補償** - 感測器誤差修正\n- **數位濾波** - 軟體雜訊抑制\n- **PWM 控制** - 馬達速度和伺服角度\n- **中斷驅動** - 即時響應感測器事件\n\n## 常見應用\n- **環境監測站** - 溫濕度、光線、空氣品質\n- **安全系統** - 動作偵測、門窗感測\n- **自動澆水** - 土壤濕度感測控制\n- **循跡機器人** - 光感測器導航\n- **太陽能追蹤** - 光感測器 + 伺服馬達\n- **智慧風扇** - 溫度感測自動調速\n\n## 進階概念\n- **感測器網路** - 多節點資料收集\n- **預測性維護** - 振動和溫度監測\n- **機器學習** - 感測器數據模式識別\n- **能源管理** - 低功耗感測和休眠模式",
      "color": "#20c997",
      "icon": "📡",
      "createdAt": "2025-09-17T09:00:00.000Z",
      "updatedAt": "2025-09-17T09:00:00.000Z"
    },
    {
      "id": "topic-arduino-display",
      "name": "Arduino 顯示與通訊",
      "description": "顯示器、通訊協定與人機介面設計",
      "documentation": "# Arduino 顯示與通訊\n\n## 學習目標\n掌握各種顯示技術和通訊協定，建立完整的人機介面和設備互聯系統：\n\n- **液晶顯示器** - 16x2 LCD、OLED 顯示\n- **LED 矩陣** - 8x8 LED、WS2812 全彩 LED\n- **七段顯示器** - 數字顯示和時鐘應用\n- **I2C 通訊** - 兩線式串列通訊協定\n- **SPI 通訊** - 高速串列週邊介面\n- **UART 序列** - 非同步串列通訊\n- **藍牙通訊** - HC-05/HC-06 無線通訊\n- **紅外線通訊** - IR 遙控收發\n\n## 適合對象\n- 想要建立使用者介面的開發者\n- 需要設備間通訊的專案開發者\n- 對顯示技術有興趣的學習者\n- 想要建立遠端控制系統的 Maker\n\n## 硬體需求\n### 顯示模組\n- **1602 LCD** - 16x2 字元顯示器 + I2C 模組\n- **SSD1306 OLED** - 128x64 圖形顯示器\n- **MAX7219** - 8x8 LED 矩陣控制器\n- **WS2812B** - 全彩可程式 LED 燈條\n- **7段顯示器** - 共陽極/共陰極數字顯示\n\n### 通訊模組\n- **HC-05** - 藍牙串列通訊模組\n- **NRF24L01** - 2.4GHz 無線通訊\n- **ESP8266** - WiFi 通訊模組\n- **IR 接收器** - TSOP4838 紅外線接收\n- **IR LED** - 紅外線發射器\n\n### 輔助組件\n- **I2C 轉接板** - LCD I2C 背包\n- **電平轉換器** - 3.3V/5V 邏輯轉換\n- **天線** - 2.4GHz 陶瓷天線\n\n## 學習順序建議\n1. **基本 LCD** - 文字顯示和簡單介面\n2. **I2C 通訊** - 減少接線的顯示控制\n3. **OLED 圖形** - 像素級圖形顯示\n4. **LED 矩陣** - 動態圖案和動畫\n5. **序列通訊** - Arduino 間資料交換\n6. **藍牙控制** - 手機 APP 遙控\n7. **多設備網路** - 感測器網路建構\n\n## 通訊協定詳解\n### I2C (Inter-Integrated Circuit)\n- **雙線通訊** - SDA (資料) + SCL (時脈)\n- **主從架構** - 一個主機，多個從機\n- **位址識別** - 7位元或10位元設備位址\n- **常見設備** - LCD、OLED、RTC、感測器\n\n### SPI (Serial Peripheral Interface)\n- **四線通訊** - MOSI、MISO、SCK、CS\n- **高速傳輸** - 數 MHz 傳輸速度\n- **全雙工** - 同時收發資料\n- **常見設備** - SD卡、無線模組、顯示器\n\n### UART (Universal Asynchronous Receiver-Transmitter)\n- **非同步** - 無需共用時脈訊號\n- **點對點** - 兩個設備間直接通訊\n- **可設定** - 鮑率、資料位元、校驗位元\n- **常見應用** - GPS、藍牙、WiFi模組\n\n## 顯示技術比較\n- **字元 LCD** - 成本低、功耗低、文字顯示\n- **OLED** - 對比度高、可彎曲、圖形顯示\n- **LED 矩陣** - 亮度高、可見距離遠、動畫效果\n- **E-Paper** - 超低功耗、陽光下可讀、靜態顯示\n\n## 實際應用\n- **資訊顯示站** - 溫度、時間、狀態顯示\n- **遠端監控** - 感測器數據無線傳輸\n- **智慧家居** - 手機控制家電設備\n- **機器人控制** - 視覺化機器人狀態\n- **教育展示** - 互動式學習裝置\n- **工業監控** - 製程參數即時顯示",
      "color": "#fd7e14",
      "icon": "📺",
      "createdAt": "2025-09-17T09:00:00.000Z",
      "updatedAt": "2025-09-17T09:00:00.000Z"
    },
    {
      "id": "topic-esp32-iot",
      "name": "ESP32 物聯網基礎",
      "description": "ESP32 WiFi 連接與基礎網路程式設計",
      "documentation": "# ESP32 物聯網基礎\n\n## 學習目標\n掌握 ESP32 微控制器的 WiFi 功能，學習基礎網路程式設計，建立物聯網 (IoT) 應用的基礎能力：\n\n- **ESP32 介紹** - 雙核心處理器、WiFi/藍牙整合\n- **WiFi 連接** - 無線網路連接和管理\n- **HTTP 客戶端** - 網路請求和 API 呼叫\n- **Web 伺服器** - 建立簡易網站介面\n- **JSON 資料處理** - 結構化資料交換\n- **時間同步** - NTP 伺服器時間校正\n- **檔案系統** - SPIFFS/LittleFS 資料儲存\n- **韌體更新** - OTA (Over-The-Air) 無線更新\n\n## 適合對象\n- 已具備 Arduino 基礎的開發者\n- 想要學習物聯網開發的程式設計師\n- 需要遠端監控功能的專案開發者\n- 對智慧家居有興趣的 Maker\n\n## 硬體需求\n### ESP32 開發板\n- **ESP32 DevKit** - 基本開發板，豐富 GPIO\n- **ESP32-CAM** - 內建攝像頭模組\n- **ESP32-S2** - 單核心，USB 原生支援\n- **ESP32-C3** - RISC-V 架構，低功耗\n\n### 開發環境\n- **Arduino IDE** - 安裝 ESP32 開發板支援\n- **PlatformIO** - 專業 IDE 和專案管理\n- **ESP-IDF** - 官方開發框架 (進階)\n\n### 網路環境\n- **WiFi 路由器** - 2.4GHz 網路 (ESP32 不支援 5GHz)\n- **行動熱點** - 測試和展示用途\n- **網路除錯工具** - Postman、Wireshark\n\n## 學習順序建議\n1. **WiFi 連接** - 連接無線網路，取得 IP 位址\n2. **HTTP 請求** - 呼叫網路 API，取得資料\n3. **簡易伺服器** - 建立網頁介面，遠端控制\n4. **JSON 解析** - 處理結構化資料\n5. **時間同步** - 取得網路時間，建立時戳\n6. **資料儲存** - 儲存設定和歷史資料\n7. **OTA 更新** - 遠端韌體更新\n\n## 核心技術\n### WiFi 管理\n- **WiFi.begin()** - 連接指定網路\n- **WiFi.status()** - 檢查連接狀態\n- **WiFi.localIP()** - 取得本機 IP 位址\n- **WiFiManager** - 動態網路設定\n\n### HTTP 通訊\n- **HTTPClient** - HTTP 請求客戶端\n- **WebServer** - 建立 Web 伺服器\n- **AsyncWebServer** - 非同步 Web 伺服器\n- **WebSocket** - 雙向即時通訊\n\n### 資料格式\n- **JSON** - 輕量級資料交換格式\n- **XML** - 結構化標記語言\n- **CSV** - 簡單表格資料格式\n- **Base64** - 二進位資料編碼\n\n## 網路安全\n- **HTTPS** - 加密 HTTP 通訊\n- **證書驗證** - SSL/TLS 憑證檢查\n- **API 金鑰** - 服務存取授權\n- **加密儲存** - 敏感資料保護\n\n## 雲端服務整合\n- **Google Sheets** - 資料記錄和視覺化\n- **ThingSpeak** - IoT 資料分析平台\n- **IFTTT** - 自動化服務連接\n- **Firebase** - 即時資料庫和認證\n- **AWS IoT** - 企業級物聯網平台\n\n## 實際應用\n- **環境監測** - 感測器資料上傳雲端\n- **遠端控制** - 手機或電腦控制設備\n- **智慧開關** - 網路控制電器開關\n- **資料記錄器** - 長期資料收集和分析\n- **通知系統** - 異常狀況警報推送\n- **韌體管理** - 遠端設備更新維護\n\n## 效能優化\n- **深度睡眠** - 電池供電應用\n- **連接管理** - 網路斷線重連\n- **記憶體管理** - 避免記憶體洩漏\n- **看門狗計時器** - 系統穩定性保護",
      "color": "#e83e8c",
      "icon": "🌐",
      "createdAt": "2025-09-17T09:00:00.000Z",
      "updatedAt": "2025-09-17T09:00:00.000Z"
    },
    {
      "id": "topic-esp32-advanced",
      "name": "ESP32 進階應用",
      "description": "完整物聯網系統開發與企業級應用",
      "documentation": "# ESP32 進階應用\n\n## 學習目標\n建構完整的物聯網解決方案，掌握企業級應用開發技術，實現產品化的 IoT 系統：\n\n- **MQTT 通訊** - 物聯網標準通訊協定\n- **即時系統** - FreeRTOS 多工處理\n- **藍牙應用** - BLE 低功耗藍牙\n- **攝像頭應用** - 影像串流和處理\n- **機器學習** - TensorFlow Lite 邊緣運算\n- **安全通訊** - 加密和認證機制\n- **大量部署** - 設備管理和監控\n- **商業應用** - 完整產品解決方案\n\n## 適合對象\n- 已掌握 ESP32 基礎物聯網功能的開發者\n- 需要開發商業級 IoT 產品的工程師\n- 想要學習邊緣運算的 AI 開發者\n- 企業 IoT 系統架構師\n\n## 進階硬體\n### 專業開發板\n- **ESP32-S3** - AI 加速器、攝像頭介面\n- **ESP32-C6** - WiFi 6、Thread/Zigbee\n- **ESP32-H2** - Zigbee 3.0、Thread 專用\n- **ESP32-P4** - 高效能雙核心，無無線功能\n\n### 擴展模組\n- **攝像頭模組** - OV2640、OV5640\n- **觸控螢幕** - TFT LCD + 電容觸控\n- **LoRa 模組** - 長距離低功耗通訊\n- **GPS 模組** - 定位和時間同步\n- **加密晶片** - ATECC608 硬體加密\n\n## 學習順序建議\n1. **MQTT 系統** - 建立穩定的通訊架構\n2. **多工處理** - FreeRTOS 任務管理\n3. **BLE 應用** - 近距離通訊和組態\n4. **影像處理** - 攝像頭數據處理\n5. **邊緣 AI** - 本地機器學習推論\n6. **安全架構** - 端到端加密通訊\n7. **系統整合** - 完整解決方案實作\n\n## 核心技術深度\n### MQTT (Message Queuing Telemetry Transport)\n- **發佈/訂閱** - 解耦的通訊模式\n- **QoS 等級** - 訊息傳遞品質保證\n- **持久會話** - 離線訊息暫存\n- **遺囑訊息** - 設備異常處理\n- **群組通訊** - 一對多廣播\n\n### FreeRTOS 即時系統\n- **任務管理** - 多工並行處理\n- **佇列通訊** - 任務間資料交換\n- **信號量** - 資源同步控制\n- **記憶體管理** - 動態記憶體分配\n- **中斷處理** - 即時響應機制\n\n### 藍牙低功耗 (BLE)\n- **GATT 服務** - 通用屬性協定\n- **特徵值** - 資料交換介面\n- **廣播** - 設備發現機制\n- **配對** - 安全連接建立\n- **省電模式** - 間歇式通訊\n\n### 邊緣人工智慧\n- **TensorFlow Lite** - 輕量化 AI 框架\n- **模型量化** - 減少記憶體使用\n- **推論優化** - 提升執行效率\n- **感測器融合** - 多模態資料處理\n- **預測性維護** - 異常模式檢測\n\n## 企業級功能\n### 設備管理\n- **設備註冊** - 自動化設備上線\n- **韌體管理** - 批次 OTA 更新\n- **配置管理** - 遠端參數設定\n- **狀態監控** - 設備健康度追蹤\n- **故障診斷** - 自動問題檢測\n\n### 資料分析\n- **時序資料庫** - 高效能資料儲存\n- **即時分析** - 串流資料處理\n- **機器學習** - 模式識別和預測\n- **視覺化** - 儀表板和報表\n- **警報系統** - 智慧異常通知\n\n### 安全架構\n- **端到端加密** - 資料傳輸保護\n- **設備認證** - 數位憑證管理\n- **存取控制** - 角色權限管理\n- **安全更新** - 防篡改韌體\n- **稽核日誌** - 操作記錄追蹤\n\n## 產業應用案例\n### 智慧農業\n- **土壤監測** - pH、養分、濕度感測\n- **自動灌溉** - 智慧水資源管理\n- **病蟲害偵測** - AI 影像識別\n- **產量預測** - 機器學習分析\n\n### 工業 4.0\n- **設備監控** - 振動、溫度、效率\n- **預測性維護** - 故障前兆檢測\n- **品質控制** - 自動化檢測\n- **供應鏈** - 即時庫存管理\n\n### 智慧城市\n- **交通監控** - 車流分析和優化\n- **環境監測** - 空氣品質監測\n- **能源管理** - 智慧電網整合\n- **公共安全** - 監控和預警\n\n### 醫療保健\n- **生理監測** - 心率、血壓、血氧\n- **藥物管理** - 智慧提醒系統\n- **遠距照護** - 居家健康監控\n- **流行病追蹤** - 接觸者追蹤\n\n## 部署和維運\n- **雲端架構** - 可擴展的後端服務\n- **負載平衡** - 高可用性設計\n- **監控系統** - 即時系統健康度\n- **災難恢復** - 備份和復原機制\n- **成本優化** - 資源使用效率",
      "color": "#dc3545",
      "icon": "🚀",
      "createdAt": "2025-09-17T09:00:00.000Z",
      "updatedAt": "2025-09-17T09:00:00.000Z"
    }
  ],
  "templates": [
    {
      "id": "hello-world",
      "title": "Hello World",
      "description": "經典的第一個程式",
      "code": "#include <stdio.h>\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}",
      "language": "c",
      "topic": "C 基礎程式",
      "metadata": {
        "usage": 8,
        "popularity": 85,
        "lastUsedAt": "2025-01-15T10:30:00.000Z"
      },
      "documentation": "# Hello World\n\n## 功能簡介\n這是每個程式語言學習者的第一個程式，用於展示最基本的程式輸出功能。透過這個簡單的程式，你可以確認開發環境已正確設置，並了解 C 語言程式的基本結構。\n\n## 模板內容\n```c\n#include <stdio.h>\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\n```\n\n## 範例輸入\n```\n(此程式不需要輸入)\n```\n\n## 範例輸出\n```\nHello, World!\n```\n\n## 重點說明\n- `#include <stdio.h>` - 包含標準輸入輸出庫，提供 printf 函數\n- `int main()` - 主函數，程式的入口點\n- `printf()` - 輸出函數，用於顯示文字到螢幕\n- `\\n` - 換行字符，讓輸出後游標移到下一行\n- `return 0` - 回傳值，表示程式正常結束\n\n## 相關模板\n- 變數宣告 - 學習如何宣告和使用變數\n- 輸入輸出 - 學習更複雜的輸入輸出操作"
    },
    {
      "id": "variable-declaration",
      "title": "變數宣告",
      "description": "基本變數宣告和初始化",
      "code": "int number = 42;\nchar character = 'A';\nfloat decimal = 3.14f;\ndouble precision = 2.71828;",
      "language": "c",
      "topic": "C 基礎程式"
    },
    {
      "id": "input-output",
      "title": "輸入輸出",
      "description": "基本輸入輸出操作",
      "code": "#include <stdio.h>\n\nint main() {\n    int number;\n    printf(\"請輸入一個數字: \");\n    scanf(\"%d\", &number);\n    printf(\"您輸入的數字是: %d\\n\", number);\n    return 0;\n}",
      "language": "c",
      "topic": "C 基礎程式"
    },
    {
      "id": "if-else",
      "title": "If-Else 條件判斷",
      "description": "基本條件判斷結構",
      "code": "if (condition) {\n    // 條件為真時執行\n} else if (another_condition) {\n    // 另一個條件為真時執行\n} else {\n    // 所有條件都為假時執行\n}",
      "language": "c",
      "topic": "C 基礎程式"
    },
    {
      "id": "for-loop",
      "title": "For 迴圈",
      "description": "基本for迴圈結構",
      "code": "for (int i = 0; i < 10; i++) {\n    printf(\"第 %d 次迴圈\\n\", i + 1);\n}",
      "language": "c",
      "topic": "C 基礎程式",
      "metadata": {
        "usage": 12,
        "popularity": 90,
        "lastUsedAt": "2025-01-15T09:15:00.000Z"
      },
      "documentation": "# For 迴圈\n\n## 功能簡介\nFor 迴圈是程式設計中最常用的迴圈結構，用於重複執行一段程式碼指定的次數。它特別適合用於已知迴圈次數的情況，如陣列遍歷、計數操作等。\n\n## 模板內容\n```c\nfor (int i = 0; i < 10; i++) {\n    printf(\"第 %d 次迴圈\\n\", i + 1);\n}\n```\n\n## 範例輸入\n```\n(此程式不需要輸入)\n```\n\n## 範例輸出\n```\n第 1 次迴圈\n第 2 次迴圈\n第 3 次迴圈\n...\n第 10 次迴圈\n```\n\n## 重點說明\n- `for (初始化; 條件; 更新)` - for 迴圈的三個部分\n- `int i = 0` - 迴圈變數初始化，通常從 0 開始\n- `i < 10` - 迴圈繼續條件，當條件為假時停止\n- `i++` - 每次迴圈後的更新操作，等同於 i = i + 1\n- `%d` - printf 中的格式化符號，用於輸出整數\n- 迴圈變數 i 的作用域僅在迴圈內\n\n## 相關模板\n- While 迴圈 - 學習另一種迴圈結構\n- 一維陣列 - 使用 for 迴圈遍歷陣列\n- 二維陣列 - 使用巢狀 for 迴圈"
    },
    {
      "id": "while-loop",
      "title": "While 迴圈",
      "description": "基本while迴圈結構",
      "code": "int count = 0;\nwhile (count < 10) {\n    printf(\"計數: %d\\n\", count);\n    count++;\n}",
      "language": "c",
      "topic": "C 基礎程式"
    },
    {
      "id": "c-switch-case",
      "title": "Switch-Case 語句",
      "description": "多條件分支判斷結構",
      "code": "#include <stdio.h>\n\nint main() {\n    int choice;\n    \n    printf(\"請選擇操作 (1-4): \");\n    scanf(\"%d\", &choice);\n    \n    switch (choice) {\n        case 1:\n            printf(\"您選擇了選項 1\\n\");\n            break;\n        case 2:\n            printf(\"您選擇了選項 2\\n\");\n            break;\n        case 3:\n            printf(\"您選擇了選項 3\\n\");\n            break;\n        case 4:\n            printf(\"您選擇了選項 4\\n\");\n            break;\n        default:\n            printf(\"無效的選擇\\n\");\n            break;\n    }\n    \n    return 0;\n}",
      "language": "c",
      "topic": "C 基礎程式",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "basic",
        "tags": ["流程控制", "switch", "case", "分支判斷", "原子式"]
      },
      "documentation": "# Switch-Case 語句\n\n## 功能說明\nSwitch-case 語句是 C 語言中處理多條件分支的有效方式，比多個 if-else 語句更清晰易讀。\n\n## 語法結構\n```c\nswitch (expression) {\n    case constant1:\n        // 程式碼\n        break;\n    case constant2:\n        // 程式碼\n        break;\n    default:\n        // 預設情況\n        break;\n}\n```\n\n## 重要概念\n- **expression** - 必須是整數類型（int, char 等）\n- **case** - 標籤必須是常數\n- **break** - 防止程式碼「穿透」到下一個 case\n- **default** - 可選的預設分支\n\n## Break 的重要性\n如果忘記 break，程式會繼續執行下一個 case 的程式碼（fall-through）：\n```c\nswitch (x) {\n    case 1:\n        printf(\"一\");\n        // 沒有 break，會繼續執行\n    case 2:\n        printf(\"二\");  // x=1 時也會執行這裡\n        break;\n}\n```\n\n## 使用場景\n- **選單系統** - 使用者選擇不同功能\n- **狀態機** - 根據狀態執行不同操作\n- **字元處理** - 根據輸入字元分類處理\n- **錯誤碼處理** - 根據錯誤代碼執行對應處理\n\n## 與 if-else 的比較\n**優點：**\n- 程式碼更清晰易讀\n- 編譯器可能產生更高效的程式碼\n- 容易添加新的條件分支\n\n**限制：**\n- 只能比較相等性，不能使用範圍\n- case 標籤必須是編譯時常數\n- 只支援整數類型"
    },
    {
      "id": "c-string-basics",
      "title": "字串基礎操作",
      "description": "字元陣列和基本字串操作",
      "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    // 字串宣告方式\n    char str1[50] = \"Hello\";\n    char str2[] = \"World\";\n    char str3[50];\n    \n    // 字串長度\n    printf(\"str1 長度: %lu\\n\", strlen(str1));\n    \n    // 字串複製\n    strcpy(str3, str1);\n    printf(\"複製後 str3: %s\\n\", str3);\n    \n    // 字串連接\n    strcat(str3, \" \");\n    strcat(str3, str2);\n    printf(\"連接後 str3: %s\\n\", str3);\n    \n    // 字串比較\n    if (strcmp(str1, \"Hello\") == 0) {\n        printf(\"str1 等於 'Hello'\\n\");\n    }\n    \n    // 字元存取\n    printf(\"第一個字元: %c\\n\", str1[0]);\n    \n    return 0;\n}",
      "language": "c",
      "topic": "C 基礎程式",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "basic",
        "tags": ["字串", "字元陣列", "string.h", "基礎操作", "原子式"]
      },
      "documentation": "# 字串基礎操作\n\n## 功能說明\nC 語言中字串是以 null 字元（\\0）結尾的字元陣列，提供基本的字串操作函數。\n\n## 字串宣告方式\n```c\n// 方式 1: 指定大小\nchar str[50] = \"Hello\";\n\n// 方式 2: 自動計算大小\nchar str[] = \"Hello\";\n\n// 方式 3: 字元逐一初始化\nchar str[] = {'H', 'e', 'l', 'l', 'o', '\\0'};\n```\n\n## 常用字串函數\n\n### strlen() - 計算長度\n- 回傳字串的字元數（不包括 \\0）\n- 需要 #include <string.h>\n\n### strcpy() - 字串複製\n```c\nstrcpy(destination, source);\n```\n- 將 source 的內容複製到 destination\n- destination 必須有足夠空間\n\n### strcat() - 字串連接\n```c\nstrcat(destination, source);\n```\n- 將 source 連接到 destination 後面\n- destination 必須有足夠空間容納結果\n\n### strcmp() - 字串比較\n```c\nint result = strcmp(str1, str2);\n```\n- 回傳值：0（相等）、正數（str1 > str2）、負數（str1 < str2）\n\n## 安全注意事項\n- **緩衝區溢位** - 確保目標陣列有足夠空間\n- **Null 終止** - 確保字串以 \\0 結尾\n- **未初始化** - 宣告後立即初始化字串\n\n## 安全替代函數\n```c\n// 更安全的函數（C99 標準）\nstrncpy(dest, src, n);  // 限制複製長度\nstrncat(dest, src, n);  // 限制連接長度\nstrncmp(str1, str2, n); // 限制比較長度\n```\n\n## 常見錯誤\n1. **忘記 \\0** - 手動建立字串時忘記結尾字元\n2. **空間不足** - 目標陣列太小無法容納結果\n3. **未初始化** - 使用未初始化的字元陣列\n4. **指標混淆** - 混淆字元指標和字元陣列的用法"
    },
    {
      "id": "c-operators",
      "title": "運算子範例",
      "description": "C 語言各種運算子的使用",
      "code": "#include <stdio.h>\n\nint main() {\n    int a = 10, b = 3;\n    \n    // 算術運算子\n    printf(\"算術運算子:\\n\");\n    printf(\"%d + %d = %d\\n\", a, b, a + b);\n    printf(\"%d - %d = %d\\n\", a, b, a - b);\n    printf(\"%d * %d = %d\\n\", a, b, a * b);\n    printf(\"%d / %d = %d\\n\", a, b, a / b);\n    printf(\"%d %% %d = %d\\n\", a, b, a % b);\n    \n    // 比較運算子\n    printf(\"\\n比較運算子:\\n\");\n    printf(\"%d == %d: %d\\n\", a, b, a == b);\n    printf(\"%d != %d: %d\\n\", a, b, a != b);\n    printf(\"%d > %d: %d\\n\", a, b, a > b);\n    printf(\"%d < %d: %d\\n\", a, b, a < b);\n    \n    // 邏輯運算子\n    printf(\"\\n邏輯運算子:\\n\");\n    printf(\"(%d > 5) && (%d < 15): %d\\n\", a, a, (a > 5) && (a < 15));\n    printf(\"(%d < 5) || (%d > 15): %d\\n\", a, a, (a < 5) || (a > 15));\n    printf(\"!(%d > 5): %d\\n\", a, !(a > 5));\n    \n    // 位元運算子\n    printf(\"\\n位元運算子:\\n\");\n    printf(\"%d & %d = %d\\n\", a, b, a & b);\n    printf(\"%d | %d = %d\\n\", a, b, a | b);\n    printf(\"%d ^ %d = %d\\n\", a, b, a ^ b);\n    printf(\"~%d = %d\\n\", a, ~a);\n    \n    // 遞增遞減運算子\n    printf(\"\\n遞增遞減運算子:\\n\");\n    int c = 5;\n    printf(\"c = %d\\n\", c);\n    printf(\"c++ = %d, c = %d\\n\", c++, c);\n    printf(\"++c = %d, c = %d\\n\", ++c, c);\n    \n    return 0;\n}",
      "language": "c",
      "topic": "C 基礎程式",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "basic",
        "tags": ["運算子", "算術", "邏輯", "位元", "比較", "原子式"]
      },
      "documentation": "# 運算子範例\n\n## 功能說明\nC 語言提供豐富的運算子來進行各種數值和邏輯運算，是程式設計的基礎工具。\n\n## 運算子分類\n\n### 1. 算術運算子\n- **+** 加法\n- **-** 減法\n- **\\*** 乘法\n- **/** 除法（整數除法會捨去小數）\n- **%** 取餘數（模運算）\n\n### 2. 比較運算子\n- **==** 等於\n- **!=** 不等於\n- **>** 大於\n- **<** 小於\n- **>=** 大於等於\n- **<=** 小於等於\n\n### 3. 邏輯運算子\n- **&&** 邏輯且（AND）\n- **||** 邏輯或（OR）\n- **!** 邏輯非（NOT）\n\n### 4. 位元運算子\n- **&** 位元且\n- **|** 位元或\n- **^** 位元異或\n- **~** 位元補數\n- **<<** 左移\n- **>>** 右移\n\n### 5. 遞增遞減運算子\n- **++** 遞增\n- **--** 遞減\n\n## 前置 vs 後置\n```c\nint a = 5;\nint b = ++a;  // 前置：先遞增 a，再賦值給 b（a=6, b=6）\nint c = a++;  // 後置：先賦值給 c，再遞增 a（c=6, a=7）\n```\n\n## 運算子優先順序\n1. **()** 括號（最高優先級）\n2. **++ --** 遞增遞減\n3. **\\* / %** 乘除模\n4. **+ -** 加減\n5. **< <= > >=** 比較\n6. **== !=** 相等\n7. **&&** 邏輯且\n8. **||** 邏輯或\n9. **= += -= \\*= /=** 賦值（最低優先級）\n\n## 短路求值\n```c\n// 邏輯且：如果左邊為假，右邊不會被執行\nif (a != 0 && 10/a > 2) { ... }\n\n// 邏輯或：如果左邊為真，右邊不會被執行\nif (a == 0 || 10/a > 2) { ... }\n```\n\n## 常見陷阱\n1. **賦值 vs 比較** - 混淆 = 和 ==\n2. **整數除法** - 10/3 = 3（不是 3.33）\n3. **優先順序** - 使用括號明確表達意圖\n4. **副作用** - 在複雜表達式中避免 ++ 和 --"
    },
    {
      "id": "c-constants-macros",
      "title": "常量和巨集",
      "description": "常量定義和預處理器巨集",
      "code": "#include <stdio.h>\n\n// 巨集定義\n#define PI 3.14159\n#define MAX_SIZE 100\n#define SQUARE(x) ((x) * (x))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\n// 條件編譯\n#define DEBUG 1\n\nint main() {\n    // const 常量\n    const int DAYS_IN_WEEK = 7;\n    const float GRAVITY = 9.8f;\n    \n    // 使用巨集常量\n    printf(\"圓周率: %.5f\\n\", PI);\n    printf(\"最大陣列大小: %d\\n\", MAX_SIZE);\n    \n    // 使用函數型巨集\n    int num = 5;\n    printf(\"%d 的平方: %d\\n\", num, SQUARE(num));\n    printf(\"10 和 20 的最大值: %d\\n\", MAX(10, 20));\n    \n    // 使用 const 常量\n    printf(\"一週有 %d 天\\n\", DAYS_IN_WEEK);\n    printf(\"重力加速度: %.1f m/s²\\n\", GRAVITY);\n    \n    // 條件編譯\n#if DEBUG\n    printf(\"除錯模式：程式正在執行\\n\");\n#endif\n    \n    // 預定義巨集\n    printf(\"檔案: %s\\n\", __FILE__);\n    printf(\"行號: %d\\n\", __LINE__);\n    printf(\"編譯日期: %s\\n\", __DATE__);\n    printf(\"編譯時間: %s\\n\", __TIME__);\n    \n    return 0;\n}",
      "language": "c",
      "topic": "C 基礎程式",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "basic",
        "tags": ["常量", "巨集", "const", "define", "預處理器", "原子式"]
      },
      "documentation": "# 常量和巨集\n\n## 功能說明\nC 語言提供多種方式定義常量和巨集，用於建立可讀性高且易於維護的程式碼。\n\n## 常量定義方式\n\n### 1. #define 巨集\n```c\n#define PI 3.14159\n#define MAX_SIZE 100\n```\n**特點：**\n- 預處理器替換，不佔記憶體\n- 沒有型別檢查\n- 作用域是全域的\n\n### 2. const 關鍵字\n```c\nconst int MAX_USERS = 50;\nconst float TAX_RATE = 0.1f;\n```\n**特點：**\n- 有型別檢查\n- 遵循變數作用域規則\n- 佔用記憶體空間\n\n## 函數型巨集\n```c\n#define SQUARE(x) ((x) * (x))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n```\n\n**注意事項：**\n- 參數要用括號包圍\n- 整個表達式要用括號包圍\n- 避免副作用：MAX(i++, j++) 會有問題\n\n## 條件編譯\n```c\n#define DEBUG 1\n\n#if DEBUG\n    printf(\"除錯訊息\\n\");\n#endif\n\n#ifdef DEBUG\n    // 如果定義了 DEBUG\n#endif\n\n#ifndef RELEASE\n    // 如果沒有定義 RELEASE\n#endif\n```\n\n## 預定義巨集\nC 語言提供一些有用的預定義巨集：\n- **\\_\\_FILE\\_\\_** - 目前檔案名稱\n- **\\_\\_LINE\\_\\_** - 目前行號\n- **\\_\\_DATE\\_\\_** - 編譯日期\n- **\\_\\_TIME\\_\\_** - 編譯時間\n- **\\_\\_FUNCTION\\_\\_** - 目前函數名稱\n\n## 最佳實踐\n\n### 命名規範\n- 巨集常量使用全大寫：PI, MAX_SIZE\n- 函數型巨集使用全大寫：SQUARE(), MAX()\n- const 常量使用有意義的名稱\n\n### 選擇原則\n- **簡單常量** - 優先使用 const\n- **編譯時常量** - 使用 #define\n- **條件編譯** - 使用 #define 配合 #if\n- **簡單計算** - 使用函數型巨集\n\n### 避免的問題\n```c\n// 錯誤：沒有括號\n#define SQUARE(x) x * x\n// SQUARE(2+3) 展開為 2+3 * 2+3 = 11（不是 25）\n\n// 正確：使用括號\n#define SQUARE(x) ((x) * (x))\n```\n\n## 應用場景\n- **配置常數** - 陣列大小、閾值\n- **數學常數** - π、e、物理常數\n- **平台差異** - 條件編譯處理不同系統\n- **除錯開關** - 控制除錯輸出的顯示"
    },
    {
      "id": "c-printf-block",
      "title": "輸出文字",
      "description": "積木：顯示文字到螢幕",
      "code": "printf(\"Hello World\");",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "basic",
        "tags": ["積木", "輸出", "printf", "基礎"]
      }
    },
    {
      "id": "c-printf-newline-block",
      "title": "輸出文字(換行)",
      "description": "積木：顯示文字並換行",
      "code": "printf(\"Hello World\\n\");",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "basic",
        "tags": ["積木", "輸出", "printf", "換行"]
      }
    },
    {
      "id": "c-printf-number-block",
      "title": "輸出數字",
      "description": "積木：顯示數字變數",
      "code": "printf(\"%d\", number);",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "basic",
        "tags": ["積木", "輸出", "數字", "變數"]
      }
    },
    {
      "id": "c-scanf-block",
      "title": "輸入數字",
      "description": "積木：從鍵盤讀取數字",
      "code": "scanf(\"%d\", &number);",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "basic",
        "tags": ["積木", "輸入", "scanf", "數字"]
      }
    },
    {
      "id": "c-int-declare-block",
      "title": "宣告整數變數",
      "description": "積木：建立一個整數變數",
      "code": "int number = 0;",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "basic",
        "tags": ["積木", "變數", "int", "宣告"]
      }
    },
    {
      "id": "c-float-declare-block",
      "title": "宣告小數變數",
      "description": "積木：建立一個小數變數",
      "code": "float number = 0.0;",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "basic",
        "tags": ["積木", "變數", "float", "小數"]
      }
    },
    {
      "id": "c-char-declare-block",
      "title": "宣告字元變數",
      "description": "積木：建立一個字元變數",
      "code": "char letter = 'A';",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "basic",
        "tags": ["積木", "變數", "char", "字元"]
      }
    },
    {
      "id": "c-assign-block",
      "title": "設定變數值",
      "description": "積木：給變數一個新的值",
      "code": "number = 10;",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "basic",
        "tags": ["積木", "賦值", "設定", "變數"]
      }
    },
    {
      "id": "c-add-block",
      "title": "加法運算",
      "description": "積木：兩個數字相加",
      "code": "result = a + b;",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "basic",
        "tags": ["積木", "運算", "加法", "數學"]
      }
    },
    {
      "id": "c-subtract-block",
      "title": "減法運算",
      "description": "積木：兩個數字相減",
      "code": "result = a - b;",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "basic",
        "tags": ["積木", "運算", "減法", "數學"]
      }
    },
    {
      "id": "c-multiply-block",
      "title": "乘法運算",
      "description": "積木：兩個數字相乘",
      "code": "result = a * b;",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "basic",
        "tags": ["積木", "運算", "乘法", "數學"]
      }
    },
    {
      "id": "c-divide-block",
      "title": "除法運算",
      "description": "積木：兩個數字相除",
      "code": "result = a / b;",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "basic",
        "tags": ["積木", "運算", "除法", "數學"]
      }
    },
    {
      "id": "c-if-block",
      "title": "如果條件",
      "description": "積木：如果條件成立就執行",
      "code": "if (condition) {\n    // 在這裡寫程式碼\n}",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "basic",
        "tags": ["積木", "條件", "if", "判斷"]
      }
    },
    {
      "id": "c-if-else-block",
      "title": "如果否則",
      "description": "積木：如果條件成立執行A，否則執行B",
      "code": "if (condition) {\n    // 條件成立時執行\n} else {\n    // 條件不成立時執行\n}",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "basic",
        "tags": ["積木", "條件", "if-else", "判斷"]
      }
    },
    {
      "id": "c-equal-condition-block",
      "title": "相等比較",
      "description": "積木：比較兩個值是否相等",
      "code": "a == b",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "basic",
        "tags": ["積木", "比較", "相等", "條件"]
      }
    },
    {
      "id": "c-greater-condition-block",
      "title": "大於比較",
      "description": "積木：比較第一個值是否大於第二個值",
      "code": "a > b",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "basic",
        "tags": ["積木", "比較", "大於", "條件"]
      }
    },
    {
      "id": "c-less-condition-block",
      "title": "小於比較",
      "description": "積木：比較第一個值是否小於第二個值",
      "code": "a < b",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "basic",
        "tags": ["積木", "比較", "小於", "條件"]
      }
    },
    {
      "id": "c-for-count-block",
      "title": "重複次數迴圈",
      "description": "積木：重複執行指定的次數",
      "code": "for (int i = 0; i < 10; i++) {\n    // 重複執行的程式碼\n}",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "basic",
        "tags": ["積木", "迴圈", "for", "重複"]
      }
    },
    {
      "id": "c-while-block",
      "title": "當條件迴圈",
      "description": "積木：當條件成立時持續執行",
      "code": "while (condition) {\n    // 當條件成立時重複執行\n}",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "basic",
        "tags": ["積木", "迴圈", "while", "條件"]
      }
    },
    {
      "id": "c-increment-block",
      "title": "變數加一",
      "description": "積木：讓變數的值增加1",
      "code": "number++;",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "basic",
        "tags": ["積木", "遞增", "加一", "變數"]
      }
    },
    {
      "id": "c-decrement-block",
      "title": "變數減一",
      "description": "積木：讓變數的值減少1",
      "code": "number--;",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "basic",
        "tags": ["積木", "遞減", "減一", "變數"]
      }
    },
    {
      "id": "c-array-declare-block",
      "title": "宣告陣列",
      "description": "積木：建立一個可以存放多個值的陣列",
      "code": "int numbers[10];",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["積木", "陣列", "宣告", "容器"]
      }
    },
    {
      "id": "c-array-access-block",
      "title": "取得陣列元素",
      "description": "積木：取得陣列中特定位置的值",
      "code": "value = numbers[0];",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["積木", "陣列", "存取", "索引"]
      }
    },
    {
      "id": "c-array-set-block",
      "title": "設定陣列元素",
      "description": "積木：設定陣列中特定位置的值",
      "code": "numbers[0] = 10;",
      "language": "c",
      "topic": "C 積木片段",
      "templateType": "block",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["積木", "陣列", "設定", "索引"]
      }
    },
    {
      "id": "function-definition",
      "title": "函數定義",
      "description": "基本函數定義和呼叫",
      "code": "// 函數定義\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    int result = add(5, 3);\n    printf(\"結果: %d\\n\", result);\n    return 0;\n}",
      "language": "c",
      "topic": "C 進階特性"
    },
    {
      "id": "array-1d",
      "title": "一維陣列",
      "description": "一維陣列宣告和使用",
      "code": "int numbers[5] = {1, 2, 3, 4, 5};\n\nfor (int i = 0; i < 5; i++) {\n    printf(\"numbers[%d] = %d\\n\", i, numbers[i]);\n}",
      "language": "c",
      "topic": "C 進階特性"
    },
    {
      "id": "array-2d",
      "title": "二維陣列",
      "description": "二維陣列宣告和使用",
      "code": "int matrix[3][3] = {\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 9}\n};\n\nfor (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 3; j++) {\n        printf(\"%d \", matrix[i][j]);\n    }\n    printf(\"\\n\");\n}",
      "language": "c",
      "topic": "C 進階特性"
    },
    {
      "id": "pointer-basic",
      "title": "基礎指標",
      "description": "指標的宣告和基本使用",
      "code": "int number = 42;\nint *ptr = &number;\n\nprintf(\"變數值: %d\\n\", number);\nprintf(\"變數位址: %p\\n\", &number);\nprintf(\"指標值: %p\\n\", ptr);\nprintf(\"指標指向的值: %d\\n\", *ptr);",
      "language": "c",
      "topic": "C 進階特性"
    },
    {
      "id": "struct-basic",
      "title": "基本結構體",
      "description": "結構體定義和使用",
      "code": "struct Student {\n    char name[50];\n    int age;\n    float grade;\n};\n\nstruct Student student1;\nstrcpy(student1.name, \"小明\");\nstudent1.age = 18;\nstudent1.grade = 85.5;\n\nprintf(\"姓名: %s\\n\", student1.name);\nprintf(\"年齡: %d\\n\", student1.age);\nprintf(\"成績: %.1f\\n\", student1.grade);",
      "language": "c",
      "topic": "C 進階特性"
    },
    {
      "id": "file-io",
      "title": "檔案輸入輸出",
      "description": "基本檔案讀寫操作",
      "code": "#include <stdio.h>\n\nint main() {\n    FILE *file;\n    \n    // 寫入檔案\n    file = fopen(\"output.txt\", \"w\");\n    if (file != NULL) {\n        fprintf(file, \"Hello, File!\\n\");\n        fclose(file);\n    }\n    \n    // 讀取檔案\n    file = fopen(\"output.txt\", \"r\");\n    if (file != NULL) {\n        char buffer[100];\n        fgets(buffer, 100, file);\n        printf(\"從檔案讀取: %s\", buffer);\n        fclose(file);\n    }\n    \n    return 0;\n}",
      "language": "c",
      "topic": "C 進階特性"
    },
    {
      "id": "c-malloc-free",
      "title": "動態記憶體分配",
      "description": "使用 malloc 和 free 管理記憶體",
      "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    // 動態分配記憶體\n    int *numbers = malloc(5 * sizeof(int));\n    \n    if (numbers == NULL) {\n        printf(\"記憶體分配失敗\\n\");\n        return 1;\n    }\n    \n    // 使用動態記憶體\n    for (int i = 0; i < 5; i++) {\n        numbers[i] = i * 10;\n        printf(\"numbers[%d] = %d\\n\", i, numbers[i]);\n    }\n    \n    // 釋放記憶體\n    free(numbers);\n    return 0;\n}",
      "language": "c",
      "topic": "C 進階特性",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["記憶體管理", "malloc", "free", "指標", "原子式"]
      },
      "documentation": "# 動態記憶體分配\n\n## 功能說明\n動態記憶體分配允許程式在執行時根據需要分配和釋放記憶體，提供更靈活的記憶體使用方式。\n\n## 核心函數\n- **malloc()** - 分配指定大小的記憶體區塊\n- **free()** - 釋放之前分配的記憶體\n- **calloc()** - 分配並初始化為零的記憶體\n- **realloc()** - 重新調整記憶體區塊大小\n\n## 使用流程\n1. **計算大小** - 確定需要的記憶體大小\n2. **分配記憶體** - 使用 malloc 分配\n3. **檢查結果** - 驗證分配是否成功\n4. **使用記憶體** - 正常存取和操作\n5. **釋放記憶體** - 使用 free 釋放\n\n## 注意事項\n- 總是檢查 malloc 的回傳值\n- 每個 malloc 都要對應一個 free\n- 避免重複釋放同一塊記憶體\n- 不要使用已釋放的記憶體\n\n## 常見錯誤\n- **記憶體洩漏** - 忘記呼叫 free\n- **雙重釋放** - 多次 free 同一指標\n- **懸掛指標** - 使用已釋放的記憶體\n- **緩衝區溢位** - 存取超出分配範圍\n\n## 最佳實踐\n- 分配後立即檢查是否成功\n- 釋放後將指標設為 NULL\n- 使用工具檢查記憶體洩漏\n- 在函數結束前釋放所有記憶體"
    },
    {
      "id": "c-enum-typedef",
      "title": "列舉和類型定義",
      "description": "enum 列舉和 typedef 類型別名",
      "code": "#include <stdio.h>\n\n// 列舉定義\nenum Weekday {\n    MONDAY = 1,\n    TUESDAY,\n    WEDNESDAY,\n    THURSDAY,\n    FRIDAY,\n    SATURDAY,\n    SUNDAY\n};\n\n// 類型別名\ntypedef unsigned int uint;\ntypedef struct {\n    int x, y;\n} Point;\n\n// 函數指標類型\ntypedef int (*Operation)(int, int);\n\nint add(int a, int b) { return a + b; }\nint multiply(int a, int b) { return a * b; }\n\nint main() {\n    // 使用列舉\n    enum Weekday today = WEDNESDAY;\n    printf(\"今天是星期 %d\\n\", today);\n    \n    switch (today) {\n        case MONDAY:\n        case TUESDAY:\n        case WEDNESDAY:\n        case THURSDAY:\n        case FRIDAY:\n            printf(\"工作日\\n\");\n            break;\n        case SATURDAY:\n        case SUNDAY:\n            printf(\"週末\\n\");\n            break;\n    }\n    \n    // 使用 typedef\n    uint count = 100;\n    printf(\"計數: %u\\n\", count);\n    \n    Point p1 = {10, 20};\n    printf(\"點座標: (%d, %d)\\n\", p1.x, p1.y);\n    \n    // 使用函數指標\n    Operation op = add;\n    printf(\"5 + 3 = %d\\n\", op(5, 3));\n    \n    op = multiply;\n    printf(\"5 * 3 = %d\\n\", op(5, 3));\n    \n    return 0;\n}",
      "language": "c",
      "topic": "C 進階特性",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["列舉", "typedef", "函數指標", "類型定義", "原子式"]
      },
      "documentation": "# 列舉和類型定義\n\n## 功能說明\nenum 列舉和 typedef 是 C 語言中提高程式碼可讀性和維護性的重要工具。\n\n## enum 列舉\n### 基本語法\n```c\nenum Color {\n    RED,      // 預設值 0\n    GREEN,    // 1\n    BLUE      // 2\n};\n\n// 指定值\nenum Status {\n    ERROR = -1,\n    SUCCESS = 0,\n    WARNING = 1\n};\n```\n\n### 列舉特性\n- **常數集合** - 定義一組相關的命名常數\n- **自動編號** - 預設從 0 開始依序遞增\n- **自訂值** - 可以指定特定的整數值\n- **類型安全** - 提供比 #define 更好的類型檢查\n\n## typedef 類型別名\n### 基本用法\n```c\n// 基本類型別名\ntypedef unsigned int uint;\ntypedef unsigned char byte;\n\n// 結構體別名\ntypedef struct {\n    int x, y;\n} Point;\n\n// 陣列類型\ntypedef int Matrix[3][3];\n\n// 函數指標類型\ntypedef int (*Compare)(const void*, const void*);\n```\n\n### 優點\n- **可讀性** - 使程式碼更容易理解\n- **移植性** - 便於跨平台程式設計\n- **維護性** - 修改類型定義即可影響整個程式\n- **抽象性** - 隱藏複雜的類型聲明\n\n## 函數指標\n### 定義和使用\n```c\n// 函數指標變數\nint (*operation)(int, int);\n\n// 使用 typedef 簡化\ntypedef int (*Operation)(int, int);\nOperation op;\n```\n\n### 應用場景\n- **回調函數** - 事件處理和通知機制\n- **策略模式** - 動態選擇演算法\n- **函數表** - 實現狀態機或命令分發\n\n## 最佳實踐\n\n### 命名規範\n```c\n// 列舉使用全大寫\nenum { MAX_SIZE, MIN_SIZE };\n\n// typedef 使用 Pascal 命名\ntypedef struct Node Node;\n```\n\n### 使用建議\n- **enum vs #define** - 優先使用 enum 定義相關常數\n- **typedef 結構體** - 簡化結構體聲明\n- **函數指標** - 提高程式的靈活性\n\n## 實際應用\n- **狀態機** - 使用 enum 定義狀態\n- **錯誤處理** - enum 定義錯誤碼\n- **跨平台** - typedef 處理平台差異\n- **API 設計** - 函數指標實現回調"
    },
    {
      "id": "c-linked-list",
      "title": "鏈結串列基礎",
      "description": "動態資料結構和鏈結串列操作",
      "code": "#include <stdio.h>\n#include <stdlib.h>\n\n// 節點結構定義\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\ntypedef struct Node Node;\n\n// 建立新節點\nNode* createNode(int data) {\n    Node* newNode = malloc(sizeof(Node));\n    if (newNode == NULL) {\n        printf(\"記憶體分配失敗\\n\");\n        return NULL;\n    }\n    newNode->data = data;\n    newNode->next = NULL;\n    return newNode;\n}\n\n// 在串列頭部插入\nNode* insertAtHead(Node* head, int data) {\n    Node* newNode = createNode(data);\n    if (newNode == NULL) return head;\n    \n    newNode->next = head;\n    return newNode;\n}\n\n// 顯示串列\nvoid printList(Node* head) {\n    Node* current = head;\n    printf(\"串列內容: \");\n    while (current != NULL) {\n        printf(\"%d -> \", current->data);\n        current = current->next;\n    }\n    printf(\"NULL\\n\");\n}\n\n// 釋放串列記憶體\nvoid freeList(Node* head) {\n    Node* current = head;\n    Node* next;\n    \n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n}\n\nint main() {\n    Node* head = NULL;\n    \n    // 插入一些資料\n    head = insertAtHead(head, 30);\n    head = insertAtHead(head, 20);\n    head = insertAtHead(head, 10);\n    \n    // 顯示串列\n    printList(head);\n    \n    // 釋放記憶體\n    freeList(head);\n    \n    return 0;\n}",
      "language": "c",
      "topic": "C 進階特性",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["鏈結串列", "動態結構", "指標", "記憶體管理", "原子式"]
      },
      "documentation": "# 鏈結串列基礎\n\n## 功能說明\n鏈結串列是一種動態資料結構，每個節點包含資料和指向下一個節點的指標。\n\n## 鏈結串列特性\n### 優點\n- **動態大小** - 可在執行時調整大小\n- **記憶體效率** - 只分配需要的記憶體\n- **插入刪除** - O(1) 時間複雜度（在已知位置）\n\n### 缺點\n- **隨機存取** - 不支援，必須循序存取\n- **額外記憶體** - 每個節點需要額外的指標空間\n- **快取局部性** - 比陣列差\n\n## 核心操作\n\n### 1. 節點結構\n```c\nstruct Node {\n    int data;           // 資料欄位\n    struct Node* next;  // 指向下一個節點\n};\n```\n\n### 2. 建立節點\n```c\nNode* createNode(int data) {\n    Node* node = malloc(sizeof(Node));\n    if (node) {\n        node->data = data;\n        node->next = NULL;\n    }\n    return node;\n}\n```\n\n### 3. 插入操作\n**頭部插入：**\n```c\nhead = insertAtHead(head, data);\n```\n\n**尾部插入：**\n```c\nvoid insertAtTail(Node** head, int data) {\n    Node* newNode = createNode(data);\n    if (*head == NULL) {\n        *head = newNode;\n        return;\n    }\n    \n    Node* current = *head;\n    while (current->next != NULL) {\n        current = current->next;\n    }\n    current->next = newNode;\n}\n```\n\n### 4. 刪除操作\n```c\nNode* deleteNode(Node* head, int data) {\n    if (head == NULL) return NULL;\n    \n    // 刪除頭節點\n    if (head->data == data) {\n        Node* temp = head;\n        head = head->next;\n        free(temp);\n        return head;\n    }\n    \n    // 尋找要刪除的節點\n    Node* current = head;\n    while (current->next && current->next->data != data) {\n        current = current->next;\n    }\n    \n    if (current->next) {\n        Node* temp = current->next;\n        current->next = temp->next;\n        free(temp);\n    }\n    \n    return head;\n}\n```\n\n### 5. 搜尋操作\n```c\nNode* search(Node* head, int data) {\n    Node* current = head;\n    while (current != NULL) {\n        if (current->data == data) {\n            return current;\n        }\n        current = current->next;\n    }\n    return NULL;\n}\n```\n\n## 記憶體管理\n### 重要原則\n- **每個 malloc 對應一個 free**\n- **釋放前檢查指標不為 NULL**\n- **釋放後將指標設為 NULL**\n\n### 完整釋放\n```c\nvoid freeList(Node* head) {\n    while (head != NULL) {\n        Node* temp = head;\n        head = head->next;\n        free(temp);\n    }\n}\n```\n\n## 變種結構\n- **雙向鏈結串列** - 每個節點有前後兩個指標\n- **環形鏈結串列** - 最後一個節點指向第一個\n- **帶頭節點** - 使用虛擬頭節點簡化操作\n\n## 應用場景\n- **動態陣列** - 不確定大小的資料集合\n- **堆疊/佇列** - 實現其他資料結構\n- **圖的鄰接表** - 表示圖的連接關係\n- **記憶體管理** - 作業系統的記憶體分配"
    },
    {
      "id": "c-process-management",
      "title": "程序管理",
      "description": "使用 fork 和 exec 建立和管理程序",
      "code": "#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n\nint main() {\n    pid_t pid;\n    int status;\n    \n    printf(\"父程序 PID: %d\\n\", getpid());\n    \n    // 建立子程序\n    pid = fork();\n    \n    if (pid == -1) {\n        perror(\"fork 失敗\");\n        exit(1);\n    } else if (pid == 0) {\n        // 子程序程式碼\n        printf(\"子程序 PID: %d\\n\", getpid());\n        printf(\"子程序執行中...\\n\");\n        sleep(2);\n        printf(\"子程序結束\\n\");\n        exit(0);\n    } else {\n        // 父程序程式碼\n        printf(\"父程序建立了子程序 PID: %d\\n\", pid);\n        \n        // 等待子程序結束\n        wait(&status);\n        printf(\"子程序已結束，狀態: %d\\n\", status);\n    }\n    \n    return 0;\n}",
      "language": "c",
      "topic": "C 系統程式",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "advanced",
        "tags": ["程序控制", "fork", "wait", "系統程式", "原子式"]
      },
      "documentation": "# 程序管理\n\n## 功能說明\n程序管理是系統程式設計的核心，允許程式建立新程序、控制執行流程，並管理程序間的關係。\n\n## 核心系統呼叫\n- **fork()** - 建立子程序\n- **exec()** - 執行新程式\n- **wait()** - 等待子程序結束\n- **getpid()** - 取得程序 ID\n- **getppid()** - 取得父程序 ID\n\n## fork() 工作原理\n1. **程序複製** - 建立父程序的完整副本\n2. **回傳值區別** - 父程序得到子程序 PID，子程序得到 0\n3. **記憶體分離** - 子程序有獨立的記憶體空間\n4. **並行執行** - 父子程序同時執行\n\n## 程序狀態\n- **RUNNING** - 正在執行或等待執行\n- **SLEEPING** - 等待資源或事件\n- **STOPPED** - 被信號停止\n- **ZOMBIE** - 已結束但尚未被父程序回收\n\n## 程序同步\n- **wait()** - 等待任一子程序結束\n- **waitpid()** - 等待特定子程序\n- **WNOHANG** - 非阻塞等待選項\n\n## exec 家族函數\n- **execl()** - 用參數列表執行\n- **execv()** - 用參數陣列執行\n- **execle()** - 包含環境變數\n- **execvp()** - 在 PATH 中尋找\n\n## 應用場景\n- **Shell 程式** - 命令列解釋器\n- **伺服器程式** - 多程序服務架構\n- **並行計算** - 任務分散處理\n- **系統工具** - 系統管理程式\n\n## 注意事項\n- 處理 fork 失敗的情況\n- 避免殭屍程序的產生\n- 正確處理信號\n- 管理程序資源"
    },
    {
      "id": "c-socket-programming",
      "title": "Socket 網路程式設計",
      "description": "TCP Socket 伺服器和客戶端通訊",
      "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#define PORT 8080\n#define BUFFER_SIZE 1024\n\n// 簡單的 TCP 伺服器\nint create_server() {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int opt = 1;\n    int addrlen = sizeof(address);\n    char buffer[BUFFER_SIZE] = {0};\n    char *hello = \"Hello from server\";\n    \n    // 建立 socket\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n    \n    // 設定 socket 選項\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        exit(EXIT_FAILURE);\n    }\n    \n    // 設定地址\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(PORT);\n    \n    // 綁定 socket\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        exit(EXIT_FAILURE);\n    }\n    \n    // 開始監聽\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        exit(EXIT_FAILURE);\n    }\n    \n    printf(\"伺服器在 port %d 等待連接...\\n\", PORT);\n    \n    // 接受連接\n    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, \n                           (socklen_t*)&addrlen)) < 0) {\n        perror(\"accept\");\n        exit(EXIT_FAILURE);\n    }\n    \n    // 讀取客戶端訊息\n    read(new_socket, buffer, BUFFER_SIZE);\n    printf(\"接收到: %s\\n\", buffer);\n    \n    // 發送回應\n    send(new_socket, hello, strlen(hello), 0);\n    printf(\"回應已發送\\n\");\n    \n    close(new_socket);\n    close(server_fd);\n    return 0;\n}\n\nint main() {\n    create_server();\n    return 0;\n}",
      "language": "c",
      "topic": "C 系統程式",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "advanced",
        "tags": ["網路程式", "Socket", "TCP", "伺服器", "原子式"]
      },
      "documentation": "# Socket 網路程式設計\n\n## 功能說明\nSocket 是網路程式設計的基礎，提供程序間通訊的標準介面，支援本地和網路通訊。\n\n## Socket 類型\n- **SOCK_STREAM** - TCP 協議，可靠的連接導向\n- **SOCK_DGRAM** - UDP 協議，不可靠的無連接\n- **SOCK_RAW** - 原始 socket，直接存取網路層\n\n## TCP 伺服器流程\n1. **socket()** - 建立 socket\n2. **bind()** - 綁定地址和埠口\n3. **listen()** - 開始監聽連接\n4. **accept()** - 接受客戶端連接\n5. **read/write** - 資料傳輸\n6. **close()** - 關閉連接\n\n## TCP 客戶端流程\n1. **socket()** - 建立 socket\n2. **connect()** - 連接到伺服器\n3. **read/write** - 資料傳輸\n4. **close()** - 關閉連接\n\n## 地址結構\n```c\nstruct sockaddr_in {\n    short sin_family;      // AF_INET\n    unsigned short sin_port;  // 埠口號\n    struct in_addr sin_addr;  // IP 地址\n    char sin_zero[8];      // 填充位元組\n};\n```\n\n## 常用函數\n- **htons()** - 主機位元組序轉網路位元組序\n- **inet_addr()** - 字串 IP 轉二進位\n- **inet_ntoa()** - 二進位 IP 轉字串\n- **gethostbyname()** - 域名解析\n\n## 錯誤處理\n- 檢查所有系統呼叫的回傳值\n- 使用 perror() 顯示錯誤資訊\n- 適當關閉 socket 釋放資源\n- 處理 SIGPIPE 信號\n\n## 應用場景\n- **Web 伺服器** - HTTP 服務\n- **聊天程式** - 即時通訊\n- **檔案傳輸** - FTP 協議\n- **資料庫連接** - 客戶端/伺服器架構\n\n## 安全考量\n- 輸入驗證和緩衝區保護\n- 連接數量限制\n- 超時處理\n- 加密通訊 (TLS/SSL)"
    },
    {
      "id": "c-signal-handling",
      "title": "信號處理",
      "description": "捕捉和處理系統信號",
      "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n\n// 信號處理函數\nvoid signal_handler(int signum) {\n    switch (signum) {\n        case SIGINT:\n            printf(\"\\n捕捉到 SIGINT (Ctrl+C)\\n\");\n            printf(\"程式即將結束...\\n\");\n            exit(0);\n            break;\n        case SIGUSR1:\n            printf(\"接收到使用者自定義信號 SIGUSR1\\n\");\n            break;\n        case SIGALRM:\n            printf(\"警報信號 SIGALRM 觸發\\n\");\n            break;\n        default:\n            printf(\"接收到未知信號: %d\\n\", signum);\n    }\n}\n\nint main() {\n    // 註冊信號處理函數\n    signal(SIGINT, signal_handler);   // Ctrl+C\n    signal(SIGUSR1, signal_handler);  // 使用者信號1\n    signal(SIGALRM, signal_handler);  // 警報信號\n    \n    printf(\"程序 PID: %d\\n\", getpid());\n    printf(\"程式運行中，可以測試信號:\\n\");\n    printf(\"- 按 Ctrl+C 發送 SIGINT\\n\");\n    printf(\"- 使用 'kill -USR1 %d' 發送 SIGUSR1\\n\", getpid());\n    printf(\"- 使用 'kill -ALRM %d' 發送 SIGALRM\\n\", getpid());\n    \n    // 設定警報，5秒後觸發 SIGALRM\n    alarm(5);\n    printf(\"5秒後將觸發警報信號\\n\");\n    \n    // 主迴圈\n    while (1) {\n        printf(\"程式運行中... (PID: %d)\\n\", getpid());\n        sleep(2);\n    }\n    \n    return 0;\n}",
      "language": "c",
      "topic": "C 系統程式",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "advanced",
        "tags": ["信號處理", "SIGINT", "異步處理", "系統程式", "原子式"]
      },
      "documentation": "# 信號處理\n\n## 功能說明\n信號是 Unix/Linux 系統中程序間通訊的重要機制，用於處理異步事件和程序控制。\n\n## 常見信號\n- **SIGINT** (2) - 中斷信號 (Ctrl+C)\n- **SIGTERM** (15) - 終止信號\n- **SIGKILL** (9) - 強制終止 (無法捕捉)\n- **SIGUSR1/SIGUSR2** - 使用者自定義信號\n- **SIGALRM** (14) - 警報信號\n- **SIGCHLD** (17) - 子程序結束信號\n\n## 信號處理方式\n1. **預設行為** - 系統預設處理\n2. **忽略信號** - SIG_IGN\n3. **自定義處理** - 註冊處理函數\n\n## signal() vs sigaction()\n- **signal()** - 簡單的信號註冊\n- **sigaction()** - 更強大和可靠的機制\n- **sigaction()** 提供更多控制選項\n\n## 信號安全\n- **異步安全函數** - 可在信號處理函數中安全使用\n- **避免複雜操作** - 信號處理函數應該簡短\n- **使用 volatile** - 全域變數應標記為 volatile\n\n## 信號遮罩\n- **sigprocmask()** - 設定信號遮罩\n- **SIG_BLOCK** - 阻塞信號\n- **SIG_UNBLOCK** - 解除阻塞\n- **SIG_SETMASK** - 設定新遮罩\n\n## 實際應用\n- **優雅關閉** - 捕捉終止信號進行清理\n- **定時任務** - 使用 SIGALRM 實現定時器\n- **程序通訊** - 使用自定義信號通訊\n- **除錯輔助** - 捕捉異常信號進行除錯\n\n## 最佳實踐\n- 只在信號處理函數中使用異步安全函數\n- 避免在處理函數中進行複雜操作\n- 使用 sigaction() 而非 sigaction()\n- 正確處理信號遮罩"
    },
    {
      "id": "c-pipe-communication",
      "title": "管道通訊",
      "description": "使用管道進行程序間通訊",
      "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/wait.h>\n\nint main() {\n    int pipefd[2];  // 管道檔案描述符 [0-讀取端, 1-寫入端]\n    pid_t pid;\n    char write_msg[] = \"Hello from parent process!\";\n    char read_msg[100];\n    \n    // 建立管道\n    if (pipe(pipefd) == -1) {\n        perror(\"pipe 建立失敗\");\n        exit(EXIT_FAILURE);\n    }\n    \n    // 建立子程序\n    pid = fork();\n    \n    if (pid == -1) {\n        perror(\"fork 失敗\");\n        exit(EXIT_FAILURE);\n    }\n    \n    if (pid == 0) {\n        // 子程序：讀取資料\n        close(pipefd[1]);  // 關閉寫入端\n        \n        printf(\"子程序等待接收資料...\\n\");\n        \n        // 從管道讀取資料\n        ssize_t bytes_read = read(pipefd[0], read_msg, sizeof(read_msg) - 1);\n        if (bytes_read > 0) {\n            read_msg[bytes_read] = '\\0';  // 確保字串結尾\n            printf(\"子程序接收到: %s\\n\", read_msg);\n        }\n        \n        close(pipefd[0]);  // 關閉讀取端\n        exit(0);\n        \n    } else {\n        // 父程序：寫入資料\n        close(pipefd[0]);  // 關閉讀取端\n        \n        printf(\"父程序發送資料: %s\\n\", write_msg);\n        \n        // 向管道寫入資料\n        write(pipefd[1], write_msg, strlen(write_msg));\n        \n        close(pipefd[1]);  // 關閉寫入端\n        \n        // 等待子程序結束\n        wait(NULL);\n        printf(\"父程序：通訊完成\\n\");\n    }\n    \n    return 0;\n}",
      "language": "c",
      "topic": "C 系統程式",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "advanced",
        "tags": ["管道", "IPC", "程序通訊", "pipe", "原子式"]
      },
      "documentation": "# 管道通訊\n\n## 功能說明\n管道是 Unix/Linux 系統中最基本的程序間通訊（IPC）機制之一，允許不同程序之間傳遞資料。\n\n## 管道類型\n\n### 1. 匿名管道（Anonymous Pipe）\n- **用途** - 父子程序間通訊\n- **特性** - 單向、先進先出（FIFO）\n- **生命週期** - 隨程序結束而消失\n\n### 2. 命名管道（Named Pipe/FIFO）\n- **用途** - 任意程序間通訊\n- **特性** - 在檔案系統中有名稱\n- **持久性** - 獨立於程序存在\n\n## 管道建立和使用\n\n### pipe() 系統呼叫\n```c\nint pipefd[2];\nint result = pipe(pipefd);\n// pipefd[0] - 讀取端\n// pipefd[1] - 寫入端\n```\n\n### 基本操作流程\n1. **建立管道** - 使用 pipe() 建立\n2. **分叉程序** - fork() 建立子程序\n3. **關閉不需要的端點** - 每個程序關閉不使用的端點\n4. **讀寫資料** - 使用 read()/write()\n5. **關閉管道** - 完成後關閉所有端點\n\n## 重要概念\n\n### 單向通訊\n- 管道只能單向傳輸資料\n- 需要雙向通訊時，建立兩個管道\n\n### 阻塞行為\n- **讀取阻塞** - 管道為空時，read() 會阻塞\n- **寫入阻塞** - 管道滿時，write() 會阻塞\n- **EOF 條件** - 所有寫入端關閉時，read() 回傳 0\n\n### 緩衝區大小\n- **PIPE_BUF** - 原子寫入的最大大小\n- **系統限制** - 通常為 4KB 到 64KB\n\n## 錯誤處理\n\n### 常見錯誤\n```c\n// SIGPIPE 信號\n// 向已關閉讀取端的管道寫入時產生\nsignal(SIGPIPE, SIG_IGN);  // 忽略 SIGPIPE\n\n// 檢查系統呼叫回傳值\nif (pipe(pipefd) == -1) {\n    perror(\"pipe\");\n    exit(EXIT_FAILURE);\n}\n```\n\n## 進階應用\n\n### 命名管道（FIFO）\n```c\n// 建立命名管道\nmkfifo(\"/tmp/mypipe\", 0666);\n\n// 開啟命名管道\nint fd = open(\"/tmp/mypipe\", O_RDWR);\n```\n\n### 非阻塞 I/O\n```c\n// 設定非阻塞模式\nint flags = fcntl(pipefd[0], F_GETFL);\nfcntl(pipefd[0], F_SETFL, flags | O_NONBLOCK);\n```\n\n### 管道重導向\n```c\n// 將標準輸出重導向到管道\ndup2(pipefd[1], STDOUT_FILENO);\nexecl(\"/bin/ls\", \"ls\", \"-l\", NULL);\n```\n\n## 實際應用場景\n\n### Shell 管道\n```bash\n# Shell 命令管道\nls -l | grep \".txt\" | wc -l\n```\n\n### 生產者-消費者模式\n```c\n// 一個程序產生資料，另一個程序處理資料\nproducer() -> pipe -> consumer()\n```\n\n### 過濾器程式\n```c\n// 資料流經多個處理階段\ninput -> filter1 -> filter2 -> output\n```\n\n## 最佳實踐\n\n### 記憶體管理\n- 及時關閉不需要的檔案描述符\n- 避免檔案描述符洩漏\n\n### 錯誤處理\n- 檢查所有系統呼叫的回傳值\n- 適當處理 SIGPIPE 信號\n\n### 效能考量\n- 考慮緩衝區大小對效能的影響\n- 大量資料傳輸時考慮其他 IPC 機制\n\n## 替代方案\n- **共享記憶體** - 大量資料傳輸\n- **訊息佇列** - 結構化訊息\n- **Socket** - 網路通訊\n- **信號量** - 同步控制"
    },
    {
      "id": "c-shared-memory",
      "title": "共享記憶體",
      "description": "使用共享記憶體進行高效程序間通訊",
      "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/shm.h>\n#include <sys/wait.h>\n#include <string.h>\n\n#define SHM_SIZE 1024  // 共享記憶體大小\n\nint main() {\n    int shmid;\n    char *shm_ptr;\n    pid_t pid;\n    \n    // 建立共享記憶體段\n    shmid = shmget(IPC_PRIVATE, SHM_SIZE, IPC_CREAT | 0666);\n    if (shmid == -1) {\n        perror(\"shmget 失敗\");\n        exit(EXIT_FAILURE);\n    }\n    \n    printf(\"共享記憶體 ID: %d\\n\", shmid);\n    \n    // 建立子程序\n    pid = fork();\n    \n    if (pid == -1) {\n        perror(\"fork 失敗\");\n        exit(EXIT_FAILURE);\n    }\n    \n    if (pid == 0) {\n        // 子程序：讀取共享記憶體\n        printf(\"子程序啟動，正在連接共享記憶體...\\n\");\n        \n        // 連接到共享記憶體\n        shm_ptr = shmat(shmid, NULL, 0);\n        if (shm_ptr == (char *) -1) {\n            perror(\"shmat 失敗\");\n            exit(EXIT_FAILURE);\n        }\n        \n        // 等待父程序寫入資料（簡單的同步）\n        sleep(2);\n        \n        // 讀取共享記憶體中的資料\n        printf(\"子程序讀取到: %s\\n\", shm_ptr);\n        \n        // 子程序也寫入一些資料\n        strcat(shm_ptr, \" [子程序已讀取]\");\n        \n        // 分離共享記憶體\n        if (shmdt(shm_ptr) == -1) {\n            perror(\"shmdt 失敗\");\n        }\n        \n        printf(\"子程序結束\\n\");\n        exit(0);\n        \n    } else {\n        // 父程序：寫入共享記憶體\n        printf(\"父程序啟動，正在連接共享記憶體...\\n\");\n        \n        // 連接到共享記憶體\n        shm_ptr = shmat(shmid, NULL, 0);\n        if (shm_ptr == (char *) -1) {\n            perror(\"shmat 失敗\");\n            exit(EXIT_FAILURE);\n        }\n        \n        // 寫入資料到共享記憶體\n        strcpy(shm_ptr, \"Hello from parent process!\");\n        printf(\"父程序寫入: %s\\n\", shm_ptr);\n        \n        // 等待子程序完成\n        wait(NULL);\n        \n        // 檢查子程序是否修改了資料\n        printf(\"最終內容: %s\\n\", shm_ptr);\n        \n        // 分離共享記憶體\n        if (shmdt(shm_ptr) == -1) {\n            perror(\"shmdt 失敗\");\n        }\n        \n        // 刪除共享記憶體段\n        if (shmctl(shmid, IPC_RMID, NULL) == -1) {\n            perror(\"shmctl 失敗\");\n        }\n        \n        printf(\"父程序：共享記憶體已清理\\n\");\n    }\n    \n    return 0;\n}",
      "language": "c",
      "topic": "C 系統程式",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "advanced",
        "tags": ["共享記憶體", "IPC", "shmget", "高效通訊", "原子式"]
      },
      "documentation": "# 共享記憶體\n\n## 功能說明\n共享記憶體是最快的程序間通訊（IPC）機制，允許多個程序直接存取同一塊實體記憶體區域。\n\n## 共享記憶體優勢\n\n### 效能優勢\n- **零拷貝** - 資料不需要在核心和使用者空間間複製\n- **高頻寬** - 最快的 IPC 機制\n- **低延遲** - 直接記憶體存取\n\n### 使用場景\n- **大量資料傳輸** - 圖像、音訊、視訊資料\n- **高頻通訊** - 即時系統、遊戲引擎\n- **資料庫系統** - 緩衝池管理\n\n## System V 共享記憶體 API\n\n### 1. shmget() - 建立/取得共享記憶體\n```c\nint shmget(key_t key, size_t size, int shmflg);\n\n// 參數說明\n// key: 唯一識別碼 (IPC_PRIVATE 或 ftok() 產生)\n// size: 共享記憶體大小（位元組）\n// shmflg: 權限和選項 (IPC_CREAT | 0666)\n```\n\n### 2. shmat() - 連接共享記憶體\n```c\nvoid *shmat(int shmid, const void *shmaddr, int shmflg);\n\n// 回傳: 共享記憶體的虛擬位址\n// shmaddr: 通常設為 NULL，讓系統選擇位址\n// shmflg: 選項 (0 表示讀寫，SHM_RDONLY 表示唯讀)\n```\n\n### 3. shmdt() - 分離共享記憶體\n```c\nint shmdt(const void *shmaddr);\n\n// 分離程序與共享記憶體的連接\n// 不會刪除共享記憶體段\n```\n\n### 4. shmctl() - 控制共享記憶體\n```c\nint shmctl(int shmid, int cmd, struct shmid_ds *buf);\n\n// cmd 選項:\n// IPC_RMID: 刪除共享記憶體段\n// IPC_STAT: 取得狀態資訊\n// IPC_SET: 設定屬性\n```\n\n## 記憶體金鑰管理\n\n### IPC_PRIVATE\n```c\n// 建立私有共享記憶體（僅限親屬程序）\nint shmid = shmget(IPC_PRIVATE, size, IPC_CREAT | 0666);\n```\n\n### ftok() 產生金鑰\n```c\n// 根據檔案路徑和專案ID產生唯一金鑰\nkey_t key = ftok(\"/tmp/myfile\", 'A');\nint shmid = shmget(key, size, IPC_CREAT | 0666);\n```\n\n## 同步問題和解決方案\n\n### 問題\n- **競爭條件** - 多個程序同時存取\n- **資料一致性** - 讀寫衝突\n- **同步需求** - 需要額外的同步機制\n\n### 解決方案\n\n#### 1. 信號量同步\n```c\n// 使用信號量控制存取\nsem_t *mutex = sem_open(\"/shm_mutex\", O_CREAT, 0644, 1);\n\n// 寫入資料\nsem_wait(mutex);\nstrcpy(shm_ptr, \"data\");\nsem_post(mutex);\n```\n\n#### 2. 檔案鎖定\n```c\n// 使用檔案鎖同步\nstruct flock lock;\nlock.l_type = F_WRLCK;\nfcntl(fd, F_SETLKW, &lock);\n```\n\n#### 3. 原子操作\n```c\n// 使用原子變數\n#include <stdatomic.h>\natomic_int *counter = (atomic_int*)shm_ptr;\natomic_fetch_add(counter, 1);\n```\n\n## 記憶體佈局設計\n\n### 結構化共享記憶體\n```c\nstruct SharedData {\n    int header_magic;      // 魔數驗證\n    int version;          // 版本號\n    size_t data_size;     // 資料大小\n    char data[1000];      // 實際資料\n    int checksum;         // 校驗和\n};\n```\n\n### 環形緩衝區\n```c\nstruct RingBuffer {\n    int head;             // 寫入位置\n    int tail;             // 讀取位置\n    int size;             // 緩衝區大小\n    char buffer[BUFFER_SIZE];\n};\n```\n\n## 錯誤處理和除錯\n\n### 常見錯誤\n- **EINVAL** - 無效的共享記憶體 ID\n- **EACCES** - 權限不足\n- **ENOMEM** - 記憶體不足\n- **EEXIST** - 共享記憶體已存在\n\n### 除錯工具\n```bash\n# 檢視系統共享記憶體\nipcs -m\n\n# 刪除殘留的共享記憶體\nipcrm -m <shmid>\n\n# 檢視記憶體使用\ncat /proc/meminfo | grep Shm\n```\n\n## 最佳實踐\n\n### 資源管理\n- **及時清理** - 程序結束前刪除共享記憶體\n- **錯誤處理** - 檢查所有系統呼叫回傳值\n- **權限控制** - 設定適當的存取權限\n\n### 效能優化\n- **記憶體對齊** - 考慮處理器快取行大小\n- **分頁大小** - 使用系統分頁大小的倍數\n- **避免偽共享** - 將不同的資料放在不同快取行\n\n### 可移植性\n- **POSIX 共享記憶體** - 使用 shm_open() API\n- **跨平台考量** - 考慮不同作業系統的差異\n\n## POSIX 共享記憶體\n```c\n#include <sys/mman.h>\n#include <fcntl.h>\n\n// POSIX 方式\nint fd = shm_open(\"/myshm\", O_CREAT | O_RDWR, 0666);\nftruncate(fd, SIZE);\nvoid *ptr = mmap(NULL, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n```"
    },
    {
      "id": "python-hello-world",
      "title": "Hello World",
      "description": "Python的第一個程式",
      "code": "print(\"Hello, World!\")",
      "language": "python",
      "topic": "基礎",
      "metadata": {
        "usage": 15,
        "popularity": 95,
        "lastUsedAt": "2025-01-15T11:45:00.000Z"
      },
      "documentation": "# Python Hello World\n\n## 功能簡介\nPython 的 Hello World 程式展示了 Python 語言的簡潔性。相較於其他程式語言，Python 只需要一行程式碼就能完成 Hello World 的輸出，這正體現了 Python「簡潔易讀」的設計哲學。\n\n## 模板內容\n```python\nprint(\"Hello, World!\")\n```\n\n## 範例輸入\n```\n(此程式不需要輸入)\n```\n\n## 範例輸出\n```\nHello, World!\n```\n\n## 重點說明\n- `print()` - Python 內建的輸出函數，會自動在結尾加上換行\n- 不需要 import 任何模組，print 是內建函數\n- 不需要宣告 main 函數，Python 會從上到下執行程式碼\n- 使用雙引號或單引號都可以表示字串\n- Python 語法簡潔，沒有分號結尾的要求\n\n## 相關模板\n- 變數宣告 - 學習 Python 變數的動態特性\n- 輸入輸出 - 學習 input() 函數和格式化輸出"
    },
    {
      "id": "python-variables",
      "title": "變數宣告",
      "description": "Python基本變數宣告和賦值",
      "code": "# 整數\nnumber = 42\n\n# 字串\nname = \"Python\"\n\n# 浮點數\npi = 3.14159\n\n# 布林值\nis_learning = True\n\nprint(f\"數字: {number}\")\nprint(f\"名稱: {name}\")\nprint(f\"圓周率: {pi}\")\nprint(f\"正在學習: {is_learning}\")",
      "language": "python",
      "topic": "基礎"
    },
    {
      "id": "python-input-output",
      "title": "輸入輸出",
      "description": "Python基本輸入輸出操作",
      "code": "# 輸入\nname = input(\"請輸入您的姓名: \")\nage = int(input(\"請輸入您的年齡: \"))\n\n# 輸出\nprint(f\"您好，{name}！\")\nprint(f\"您今年 {age} 歲\")\n\n# 格式化輸出\nprint(\"姓名: {}, 年齡: {}\".format(name, age))",
      "language": "python",
      "topic": "基礎"
    },
    {
      "id": "python-if-else",
      "title": "條件判斷",
      "description": "Python的if-elif-else條件判斷",
      "code": "score = 85\n\nif score >= 90:\n    grade = \"A\"\nelif score >= 80:\n    grade = \"B\"\nelif score >= 70:\n    grade = \"C\"\nelse:\n    grade = \"D\"\n\nprint(f\"分數: {score}, 等級: {grade}\")",
      "language": "python",
      "topic": "基礎"
    },
    {
      "id": "python-for-loop",
      "title": "For 迴圈",
      "description": "Python的for迴圈結構",
      "code": "# 基本for迴圈\nfor i in range(5):\n    print(f\"第 {i + 1} 次迴圈\")\n\n# 遍歷列表\nfruits = [\"蘋果\", \"香蕉\", \"橘子\"]\nfor fruit in fruits:\n    print(f\"我喜歡 {fruit}\")\n\n# 使用enumerate\nfor index, fruit in enumerate(fruits):\n    print(f\"{index + 1}. {fruit}\")",
      "language": "python",
      "topic": "基礎",
      "metadata": {
        "usage": 7,
        "popularity": 70,
        "lastUsedAt": "2025-01-15T08:30:00.000Z"
      }
    },
    {
      "id": "python-while-loop",
      "title": "While 迴圈",
      "description": "Python的while迴圈結構",
      "code": "count = 0\nwhile count < 5:\n    print(f\"計數: {count}\")\n    count += 1\n\n# while True 迴圈與 break\nwhile True:\n    user_input = input(\"輸入 'quit' 結束程式: \")\n    if user_input.lower() == 'quit':\n        break\n    print(f\"您輸入了: {user_input}\")",
      "language": "python",
      "topic": "基礎"
    },
    {
      "id": "python-function",
      "title": "函數定義",
      "description": "Python函數定義和呼叫",
      "code": "# 基本函數\ndef greet(name):\n    return f\"您好，{name}！\"\n\n# 有預設參數的函數\ndef add(a, b=0):\n    return a + b\n\n# 多個參數的函數\ndef calculate(x, y, operation=\"add\"):\n    if operation == \"add\":\n        return x + y\n    elif operation == \"subtract\":\n        return x - y\n    elif operation == \"multiply\":\n        return x * y\n    else:\n        return \"未知操作\"\n\n# 使用函數\nprint(greet(\"小明\"))\nprint(add(5, 3))\nprint(calculate(10, 3, \"multiply\"))",
      "language": "python",
      "topic": "進階"
    },
    {
      "id": "python-list",
      "title": "列表操作",
      "description": "Python列表的基本操作",
      "code": "# 建立列表\nnumbers = [1, 2, 3, 4, 5]\nfruits = [\"蘋果\", \"香蕉\", \"橘子\"]\n\n# 新增元素\nfruits.append(\"葡萄\")\nfruits.insert(1, \"草莓\")\n\n# 移除元素\nfruits.remove(\"香蕉\")\nlast_fruit = fruits.pop()\n\n# 列表操作\nprint(f\"水果列表: {fruits}\")\nprint(f\"列表長度: {len(fruits)}\")\nprint(f\"第一個水果: {fruits[0]}\")\nprint(f\"最後取出的水果: {last_fruit}\")\n\n# 列表切片\nprint(f\"前兩個水果: {fruits[:2]}\")",
      "language": "python",
      "topic": "進階"
    },
    {
      "id": "python-dictionary",
      "title": "字典操作",
      "description": "Python字典的基本操作",
      "code": "# 建立字典\nstudent = {\n    \"name\": \"小明\",\n    \"age\": 18,\n    \"grade\": 85.5,\n    \"subjects\": [\"數學\", \"物理\", \"化學\"]\n}\n\n# 存取字典\nprint(f\"姓名: {student['name']}\")\nprint(f\"年齡: {student.get('age', '未知')}\")\n\n# 修改字典\nstudent[\"grade\"] = 90.0\nstudent[\"school\"] = \"台灣大學\"\n\n# 遍歷字典\nfor key, value in student.items():\n    print(f\"{key}: {value}\")\n\n# 字典方法\nprint(f\"所有鍵: {list(student.keys())}\")\nprint(f\"所有值: {list(student.values())}\")",
      "language": "python",
      "topic": "進階"
    },
    {
      "id": "python-class",
      "title": "類別定義",
      "description": "Python類別和物件導向程式設計",
      "code": "class Student:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n        self.grades = []\n    \n    def add_grade(self, grade):\n        self.grades.append(grade)\n    \n    def get_average(self):\n        if not self.grades:\n            return 0\n        return sum(self.grades) / len(self.grades)\n    \n    def introduce(self):\n        return f\"我是 {self.name}，今年 {self.age} 歲\"\n\n# 使用類別\nstudent1 = Student(\"小明\", 18)\nstudent1.add_grade(85)\nstudent1.add_grade(92)\nstudent1.add_grade(78)\n\nprint(student1.introduce())\nprint(f\"平均成績: {student1.get_average():.1f}\")",
      "language": "python",
      "topic": "進階"
    },
    {
      "id": "python-file-io",
      "title": "檔案處理",
      "description": "Python檔案讀寫操作",
      "code": "# 寫入檔案\nwith open(\"output.txt\", \"w\", encoding=\"utf-8\") as file:\n    file.write(\"Hello, Python!\\n\")\n    file.write(\"這是第二行\\n\")\n    \n    # 寫入多行\n    lines = [\"第三行\", \"第四行\", \"第五行\"]\n    for line in lines:\n        file.write(line + \"\\n\")\n\n# 讀取檔案\ntry:\n    with open(\"output.txt\", \"r\", encoding=\"utf-8\") as file:\n        # 讀取所有內容\n        content = file.read()\n        print(\"檔案內容:\")\n        print(content)\n        \n    # 逐行讀取\n    with open(\"output.txt\", \"r\", encoding=\"utf-8\") as file:\n        print(\"\\n逐行讀取:\")\n        for line_num, line in enumerate(file, 1):\n            print(f\"第 {line_num} 行: {line.strip()}\")\n            \nexcept FileNotFoundError:\n    print(\"檔案不存在！\")",
      "language": "python",
      "topic": "進階"
    },
    {
      "id": "js-hello-world",
      "title": "Hello World",
      "description": "JavaScript的第一個程式",
      "code": "console.log(\"Hello, World!\");",
      "language": "javascript",
      "topic": "基礎",
      "metadata": {
        "usage": 5,
        "popularity": 60,
        "lastUsedAt": "2025-01-14T16:20:00.000Z"
      },
      "documentation": "# JavaScript Hello World\n\n## 功能簡介\nJavaScript 的 Hello World 程式使用 console.log() 函數將訊息輸出到開發者控制台。這是學習 JavaScript 的起點，無論是在瀏覽器環境還是 Node.js 環境都能執行。\n\n## 模板內容\n```javascript\nconsole.log(\"Hello, World!\");\n```\n\n## 範例輸入\n```\n(此程式不需要輸入)\n```\n\n## 範例輸出\n```\nHello, World!\n```\n\n## 重點說明\n- `console.log()` - JavaScript 內建的控制台輸出函數\n- 在瀏覽器中，輸出會顯示在開發者工具的 Console 頁籤\n- 在 Node.js 中，輸出會顯示在終端/命令列\n- JavaScript 語句建議以分號結尾（雖然不是強制性的）\n- 字串可以使用單引號、雙引號或反引號（模板字串）\n- console 是全域物件，不需要匯入\n\n## 相關模板\n- 變數宣告 - 學習 let、const、var 的使用\n- 輸入輸出 - 學習瀏覽器的 prompt() 和 alert()"
    },
    {
      "id": "js-variables",
      "title": "變數宣告",
      "description": "JavaScript基本變數宣告",
      "code": "// 使用 let 宣告變數\nlet number = 42;\nlet name = \"JavaScript\";\nlet pi = 3.14159;\nlet isLearning = true;\n\n// 使用 const 宣告常數\nconst MAX_VALUE = 100;\n\n// 輸出變數\nconsole.log(`數字: ${number}`);\nconsole.log(`名稱: ${name}`);\nconsole.log(`圓周率: ${pi}`);\nconsole.log(`正在學習: ${isLearning}`);\nconsole.log(`最大值: ${MAX_VALUE}`);",
      "language": "javascript",
      "topic": "基礎"
    },
    {
      "id": "js-input-output",
      "title": "輸入輸出",
      "description": "JavaScript基本輸入輸出（瀏覽器環境）",
      "code": "// 瀏覽器環境的輸入輸出\nlet name = prompt(\"請輸入您的姓名:\");\nlet age = parseInt(prompt(\"請輸入您的年齡:\"));\n\n// 輸出到控制台\nconsole.log(`您好，${name}！`);\nconsole.log(`您今年 ${age} 歲`);\n\n// 顯示警告框\nalert(`歡迎 ${name}，您今年 ${age} 歲！`);\n\n// 輸出到網頁（假設有 HTML 元素）\n// document.getElementById('output').innerHTML = `姓名: ${name}, 年齡: ${age}`;",
      "language": "javascript",
      "topic": "基礎"
    },
    {
      "id": "js-if-else",
      "title": "條件判斷",
      "description": "JavaScript的if-else條件判斷",
      "code": "let score = 85;\nlet grade;\n\nif (score >= 90) {\n    grade = \"A\";\n} else if (score >= 80) {\n    grade = \"B\";\n} else if (score >= 70) {\n    grade = \"C\";\n} else {\n    grade = \"D\";\n}\n\nconsole.log(`分數: ${score}, 等級: ${grade}`);\n\n// 三元運算子\nlet status = (score >= 60) ? \"及格\" : \"不及格\";\nconsole.log(`狀態: ${status}`);",
      "language": "javascript",
      "topic": "基礎"
    },
    {
      "id": "js-for-loop",
      "title": "For 迴圈",
      "description": "JavaScript的for迴圈結構",
      "code": "// 基本for迴圈\nfor (let i = 0; i < 5; i++) {\n    console.log(`第 ${i + 1} 次迴圈`);\n}\n\n// 遍歷陣列\nlet fruits = [\"蘋果\", \"香蕉\", \"橘子\"];\nfor (let i = 0; i < fruits.length; i++) {\n    console.log(`我喜歡 ${fruits[i]}`);\n}\n\n// for...of 迴圈\nfor (let fruit of fruits) {\n    console.log(`水果: ${fruit}`);\n}\n\n// for...in 迴圈（用於物件）\nlet student = {name: \"小明\", age: 18};\nfor (let key in student) {\n    console.log(`${key}: ${student[key]}`);\n}",
      "language": "javascript",
      "topic": "基礎"
    },
    {
      "id": "js-while-loop",
      "title": "While 迴圈",
      "description": "JavaScript的while迴圈結構",
      "code": "// while 迴圈\nlet count = 0;\nwhile (count < 5) {\n    console.log(`計數: ${count}`);\n    count++;\n}\n\n// do...while 迴圈\nlet input;\ndo {\n    input = prompt(\"請輸入一個數字 (輸入 0 結束):\");\n    console.log(`您輸入了: ${input}`);\n} while (input !== \"0\");\n\nconsole.log(\"程式結束\");",
      "language": "javascript",
      "topic": "基礎"
    },
    {
      "id": "js-function",
      "title": "函數定義",
      "description": "JavaScript函數定義和呼叫",
      "code": "// 函數宣告\nfunction greet(name) {\n    return `您好，${name}！`;\n}\n\n// 函數表達式\nconst add = function(a, b) {\n    return a + b;\n};\n\n// 箭頭函數\nconst multiply = (x, y) => x * y;\n\n// 預設參數\nfunction introduce(name, age = 18) {\n    return `我是 ${name}，今年 ${age} 歲`;\n}\n\n// 使用函數\nconsole.log(greet(\"小明\"));\nconsole.log(add(5, 3));\nconsole.log(multiply(4, 6));\nconsole.log(introduce(\"小華\"));\nconsole.log(introduce(\"小美\", 20));",
      "language": "javascript",
      "topic": "進階"
    },
    {
      "id": "js-array",
      "title": "陣列操作",
      "description": "JavaScript陣列的基本操作",
      "code": "// 建立陣列\nlet numbers = [1, 2, 3, 4, 5];\nlet fruits = [\"蘋果\", \"香蕉\", \"橘子\"];\n\n// 新增元素\nfruits.push(\"葡萄\");           // 在末尾新增\nfruits.unshift(\"草莓\");        // 在開頭新增\n\n// 移除元素\nlet lastFruit = fruits.pop();     // 移除末尾元素\nlet firstFruit = fruits.shift();  // 移除開頭元素\n\n// 陣列方法\nconsole.log(`水果陣列: ${fruits}`);\nconsole.log(`陣列長度: ${fruits.length}`);\nconsole.log(`第一個水果: ${fruits[0]}`);\n\n// 高階函數\nlet doubledNumbers = numbers.map(n => n * 2);\nlet evenNumbers = numbers.filter(n => n % 2 === 0);\nlet sum = numbers.reduce((total, n) => total + n, 0);\n\nconsole.log(`雙倍數字: ${doubledNumbers}`);\nconsole.log(`偶數: ${evenNumbers}`);\nconsole.log(`總和: ${sum}`);",
      "language": "javascript",
      "topic": "進階"
    },
    {
      "id": "js-object",
      "title": "物件操作",
      "description": "JavaScript物件的基本操作",
      "code": "// 建立物件\nlet student = {\n    name: \"小明\",\n    age: 18,\n    grade: 85.5,\n    subjects: [\"數學\", \"物理\", \"化學\"],\n    \n    // 物件方法\n    introduce: function() {\n        return `我是 ${this.name}，今年 ${this.age} 歲`;\n    },\n    \n    // ES6 簡寫方法\n    study() {\n        console.log(`${this.name} 正在學習`);\n    }\n};\n\n// 存取物件屬性\nconsole.log(`姓名: ${student.name}`);\nconsole.log(`年齡: ${student[\"age\"]}`);\n\n// 修改物件\nstudent.grade = 90.0;\nstudent.school = \"台灣大學\";\n\n// 呼叫方法\nconsole.log(student.introduce());\nstudent.study();\n\n// 物件解構\nconst {name, age, grade} = student;\nconsole.log(`解構後: ${name}, ${age}, ${grade}`);\n\n// 遍歷物件\nfor (let key in student) {\n    if (typeof student[key] !== 'function') {\n        console.log(`${key}: ${student[key]}`);\n    }\n}",
      "language": "javascript",
      "topic": "進階"
    },
    {
      "id": "js-class",
      "title": "類別定義",
      "description": "JavaScript ES6類別和物件導向程式設計",
      "code": "class Student {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n        this.grades = [];\n    }\n    \n    addGrade(grade) {\n        this.grades.push(grade);\n    }\n    \n    getAverage() {\n        if (this.grades.length === 0) return 0;\n        const sum = this.grades.reduce((total, grade) => total + grade, 0);\n        return sum / this.grades.length;\n    }\n    \n    introduce() {\n        return `我是 ${this.name}，今年 ${this.age} 歲`;\n    }\n    \n    // 靜態方法\n    static compareStudents(student1, student2) {\n        return student1.getAverage() - student2.getAverage();\n    }\n}\n\n// 使用類別\nconst student1 = new Student(\"小明\", 18);\nstudent1.addGrade(85);\nstudent1.addGrade(92);\nstudent1.addGrade(78);\n\nconsole.log(student1.introduce());\nconsole.log(`平均成績: ${student1.getAverage().toFixed(1)}`);\n\n// 繼承\nclass HighSchoolStudent extends Student {\n    constructor(name, age, year) {\n        super(name, age);\n        this.year = year;\n    }\n    \n    introduce() {\n        return `${super.introduce()}，我是高中${this.year}年級學生`;\n    }\n}\n\nconst hsStudent = new HighSchoolStudent(\"小華\", 17, 2);\nconsole.log(hsStudent.introduce());",
      "language": "javascript",
      "topic": "進階"
    },
    {
      "id": "js-async",
      "title": "非同步程式設計",
      "description": "JavaScript Promise 和 async/await",
      "code": "// Promise 範例\nfunction fetchData(delay) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (delay < 3000) {\n                resolve(`資料載入成功！延遲 ${delay}ms`);\n            } else {\n                reject('載入超時！');\n            }\n        }, delay);\n    });\n}\n\n// 使用 Promise\nfetchData(1000)\n    .then(result => {\n        console.log(result);\n        return fetchData(2000);\n    })\n    .then(result => {\n        console.log(result);\n    })\n    .catch(error => {\n        console.error(`錯誤: ${error}`);\n    });\n\n// 使用 async/await\nasync function loadAllData() {\n    try {\n        console.log('開始載入資料...');\n        \n        const result1 = await fetchData(500);\n        console.log(result1);\n        \n        const result2 = await fetchData(1000);\n        console.log(result2);\n        \n        console.log('所有資料載入完成！');\n    } catch (error) {\n        console.error(`載入失敗: ${error}`);\n    }\n}\n\n// 呼叫非同步函數\nloadAllData();",
      "language": "javascript",
      "topic": "進階"
    },
    {
      "id": "cpp-simple-var",
      "title": "變數宣告",
      "description": "單一變數的簡單宣告",
      "code": "int number = 42;",
      "language": "cpp",
      "topic": "C++ 基礎語法",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["變數", "宣告", "原子式"]
      },
      "documentation": "# 變數宣告\n\n## 功能說明\n變數是用來儲存資料的容器，必須先宣告才能使用。\n\n## 基本語法\n```cpp\n資料型別 變數名稱 = 初始值;\n```\n\n## 常用資料型別\n```cpp\n// 整數型別\nint age = 25;              // 32位元整數\nshort count = 100;         // 短整數\nlong distance = 1000000L;  // 長整數\n\n// 浮點數型別\nfloat height = 175.5f;     // 單精度浮點數\ndouble weight = 65.8;      // 雙精度浮點數\n\n// 字元型別\nchar grade = 'A';          // 單一字元\n\n// 布林型別\nbool isValid = true;       // 真或假\nbool isReady = false;\n```\n\n## 命名規則\n- 變數名稱只能包含字母、數字和底線\n- 不能以數字開頭\n- 不能使用 C++ 關鍵字\n- 建議使用有意義的名稱\n\n```cpp\n// 好的命名\nint studentAge = 20;\ndouble bankBalance = 1500.50;\nbool isLoggedIn = false;\n\n// 避免的命名\nint x = 20;        // 意義不明\ndouble a1b2c3;     // 難以理解\n```\n\n## 實用範例\n```cpp\n#include <iostream>\n\nint main() {\n    // 學生資料\n    int studentID = 12345;\n    std::string studentName = \"王小明\";\n    double averageScore = 85.7;\n    bool isPassed = (averageScore >= 60);\n    \n    std::cout << \"學號: \" << studentID << std::endl;\n    std::cout << \"姓名: \" << studentName << std::endl;\n    std::cout << \"平均分數: \" << averageScore << std::endl;\n    std::cout << \"是否及格: \" << (isPassed ? \"是\" : \"否\") << std::endl;\n    \n    return 0;\n}\n```"
    },
    {
      "id": "cpp-simple-cout",
      "title": "輸出語句",
      "description": "基本的 cout 輸出",
      "code": "std::cout << \"Hello World\" << std::endl;",
      "language": "cpp",
      "topic": "C++ 基礎語法",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["輸出", "cout", "原子式"]
      },
      "documentation": "# 輸出語句\n\n## 功能說明\n使用 std::cout 將資料輸出到螢幕上，是程式與使用者互動的基本方式。\n\n## 基本語法\n```cpp\nstd::cout << 資料 << 資料 << ... << std::endl;\n```\n\n## 輸出不同資料型別\n```cpp\n#include <iostream>\n#include <string>\n\nint main() {\n    // 輸出文字\n    std::cout << \"Hello World!\" << std::endl;\n    \n    // 輸出數字\n    std::cout << 42 << std::endl;          // 整數\n    std::cout << 3.14159 << std::endl;     // 浮點數\n    \n    // 輸出變數\n    int age = 25;\n    std::string name = \"Alice\";\n    std::cout << \"姓名: \" << name << std::endl;\n    std::cout << \"年齡: \" << age << std::endl;\n    \n    return 0;\n}\n```\n\n## 連續輸出\n```cpp\n// 在同一行輸出多個值\nstd::cout << \"姓名: \" << name << \", 年齡: \" << age << std::endl;\n\n// 分別輸出\nstd::cout << \"第一行\" << std::endl;\nstd::cout << \"第二行\" << std::endl;\n```\n\n## 換行方式\n```cpp\nstd::cout << \"使用 endl\" << std::endl;     // 換行並清空緩衝區\nstd::cout << \"使用 \\n\\n\";                  // 只換行，效率較高\n```\n\n## 格式化輸出\n```cpp\n#include <iomanip>\n\n// 設定小數位數\nstd::cout << std::fixed << std::setprecision(2);\nstd::cout << \"金額: $\" << 123.456 << std::endl;  // 輸出: 金額: $123.46\n\n// 設定欄位寬度\nstd::cout << std::setw(10) << \"右對齊\" << std::endl;\nstd::cout << std::left << std::setw(10) << \"左對齊\" << std::endl;\n```\n\n## 實用範例\n```cpp\n#include <iostream>\n#include <string>\n\nint main() {\n    std::string product = \"筆記型電腦\";\n    double price = 25999.99;\n    int quantity = 2;\n    double total = price * quantity;\n    \n    std::cout << \"===== 購物清單 =====\" << std::endl;\n    std::cout << \"商品: \" << product << std::endl;\n    std::cout << \"單價: $\" << price << std::endl;\n    std::cout << \"數量: \" << quantity << std::endl;\n    std::cout << \"總額: $\" << total << std::endl;\n    std::cout << \"=====================\" << std::endl;\n    \n    return 0;\n}\n```"
    },
    {
      "id": "cpp-simple-cin",
      "title": "輸入語句",
      "description": "基本的 cin 輸入",
      "code": "int number;\nstd::cin >> number;",
      "language": "cpp",
      "topic": "C++ 基礎語法",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["輸入", "cin", "原子式"]
      },
      "documentation": "# 輸入語句\n\n## 功能說明\n使用 std::cin 從鍵盤讀取使用者輸入的資料。\n\n## 基本語法\n```cpp\nstd::cin >> 變數;\n```\n\n## 讀取不同資料型別\n```cpp\n#include <iostream>\n#include <string>\n\nint main() {\n    // 讀取整數\n    int age;\n    std::cout << \"請輸入年齡: \";\n    std::cin >> age;\n    \n    // 讀取浮點數\n    double height;\n    std::cout << \"請輸入身高(公分): \";\n    std::cin >> height;\n    \n    // 讀取單一字元\n    char grade;\n    std::cout << \"請輸入成績等級(A-F): \";\n    std::cin >> grade;\n    \n    // 讀取字串(不含空格)\n    std::string name;\n    std::cout << \"請輸入姓名: \";\n    std::cin >> name;\n    \n    return 0;\n}\n```\n\n## 連續讀取\n```cpp\nint a, b, c;\n\n// 方法一：分別讀取\nstd::cin >> a >> b >> c;\n\n// 方法二：逐一讀取\nstd::cin >> a;\nstd::cin >> b;\nstd::cin >> c;\n```\n\n## 讀取含空格的字串\n```cpp\n#include <iostream>\n#include <string>\n\nint main() {\n    std::string fullName;\n    \n    std::cout << \"請輸入全名: \";\n    std::cin.ignore();  // 清除緩衝區\n    std::getline(std::cin, fullName);  // 讀取整行\n    \n    std::cout << \"您的全名是: \" << fullName << std::endl;\n    \n    return 0;\n}\n```\n\n## 輸入驗證\n```cpp\n#include <iostream>\n\nint main() {\n    int number;\n    \n    std::cout << \"請輸入一個整數: \";\n    \n    if (std::cin >> number) {\n        std::cout << \"您輸入的數字是: \" << number << std::endl;\n    } else {\n        std::cout << \"輸入格式錯誤！\" << std::endl;\n        std::cin.clear();  // 清除錯誤標誌\n        std::cin.ignore(); // 清除緩衝區\n    }\n    \n    return 0;\n}\n```\n\n## 實用範例\n```cpp\n#include <iostream>\n#include <string>\n\nint main() {\n    std::string studentName;\n    int math, english, science;\n    \n    std::cout << \"=== 學生成績輸入系統 ===\" << std::endl;\n    \n    std::cout << \"請輸入學生姓名: \";\n    std::cin >> studentName;\n    \n    std::cout << \"請輸入數學成績: \";\n    std::cin >> math;\n    \n    std::cout << \"請輸入英文成績: \";\n    std::cin >> english;\n    \n    std::cout << \"請輸入理化成績: \";\n    std::cin >> science;\n    \n    double average = (math + english + science) / 3.0;\n    \n    std::cout << \"\\n=== 成績報告 ===\" << std::endl;\n    std::cout << \"學生: \" << studentName << std::endl;\n    std::cout << \"數學: \" << math << std::endl;\n    std::cout << \"英文: \" << english << std::endl;\n    std::cout << \"理化: \" << science << std::endl;\n    std::cout << \"平均: \" << average << std::endl;\n    \n    return 0;\n}\n```"
    },
    {
      "id": "cpp-include",
      "title": "包含標頭檔",
      "description": "基本的 include 指令",
      "code": "#include <iostream>",
      "language": "cpp",
      "topic": "C++ 基礎語法",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["include", "標頭檔", "原子式"]
      },
      "documentation": "# 包含標頭檔\n\n## 功能說明\n包含標頭檔是 C++ 程式的第一步，用來引入需要的函式庫功能。\n\n## 基本語法\n```cpp\n#include <標頭檔名稱>  // 系統標頭檔\n#include \"檔案名稱\"    // 自定義標頭檔\n```\n\n## 常用系統標頭檔\n```cpp\n// 基本輸入輸出\n#include <iostream>\n\n// 字串處理\n#include <string>\n\n// 數學函數\n#include <cmath>\n\n// 容器類別\n#include <vector>      // 動態陣列\n#include <array>       // 固定大小陣列\n#include <map>         // 鍵值對映射\n\n// 檔案處理\n#include <fstream>\n\n// 時間處理\n#include <chrono>\n```\n\n## 實用範例\n```cpp\n#include <iostream>\n#include <string>\n#include <cmath>\n\nint main() {\n    // 使用 iostream 的功能\n    std::cout << \"Hello World!\" << std::endl;\n    \n    // 使用 string 的功能\n    std::string message = \"計算結果\";\n    \n    // 使用 cmath 的功能\n    double result = std::sqrt(16.0);\n    \n    std::cout << message << \": \" << result << std::endl;\n    \n    return 0;\n}\n```"
    },
    {
      "id": "cpp-const",
      "title": "常數宣告",
      "description": "基本的常數定義",
      "code": "const int MAX_SIZE = 100;",
      "language": "cpp",
      "topic": "C++ 基礎語法",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["常數", "const", "原子式"]
      },
      "documentation": "# 常數宣告\n\n## 功能說明\n常數是在程式執行期間不會改變的值，使用 const 關鍵字定義。\n\n## 基本語法\n```cpp\nconst 資料型別 常數名稱 = 值;\n```\n\n## 常數的優點\n- **防止意外修改** - 編譯器會檢查並防止修改\n- **程式可讀性** - 給數值有意義的名稱\n- **維護方便** - 集中定義，修改容易\n- **效能提升** - 編譯器可進行最佳化\n\n## 命名慣例\n```cpp\n// 全大寫加底線 (推薦)\nconst int MAX_STUDENTS = 50;\nconst double PI_VALUE = 3.14159;\nconst std::string DEFAULT_NAME = \"Unknown\";\n\n// 駝峰命名法\nconst int maxRetries = 3;\nconst bool debugMode = true;\n```\n\n## 實用範例\n```cpp\n#include <iostream>\n#include <string>\n\n// 全域常數\nconst int CLASS_SIZE = 30;\nconst double PASSING_GRADE = 60.0;\nconst std::string SCHOOL_NAME = \"國立大學\";\n\nint main() {\n    // 區域常數\n    const double TAX_RATE = 0.05;\n    \n    double price = 100.0;\n    double totalPrice = price * (1 + TAX_RATE);\n    \n    std::cout << \"學校: \" << SCHOOL_NAME << std::endl;\n    std::cout << \"班級人數上限: \" << CLASS_SIZE << std::endl;\n    std::cout << \"及格分數: \" << PASSING_GRADE << std::endl;\n    std::cout << \"商品含稅價格: $\" << totalPrice << std::endl;\n    \n    return 0;\n}\n```"
    },
    {
      "id": "cpp-comment",
      "title": "註解語法",
      "description": "基本的註解寫法",
      "code": "// 這是單行註解\n/* 這是\n   多行註解 */",
      "language": "cpp",
      "topic": "C++ 基礎語法",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["註解", "說明", "原子式"]
      },
      "documentation": "# 註解語法\n\n## 功能說明\n註解是給程式設計師閱讀的說明文字，編譯器會忽略註解內容。\n\n## 註解類型\n\n### 單行註解\n```cpp\n// 這是單行註解\nint age = 25;  // 變數說明也可以放在行尾\n```\n\n### 多行註解\n```cpp\n/*\n這是多行註解\n可以跨越多行\n通常用於較長的說明\n*/\n```\n\n## 註解的用途\n\n### 1. 程式碼說明\n```cpp\n// 計算圓的面積\nconst double PI = 3.14159;\ndouble radius = 5.0;\ndouble area = PI * radius * radius;\n```\n\n### 2. 演算法解釋\n```cpp\n/*\n氣泡排序演算法\n1. 比較相鄰的兩個元素\n2. 如果順序錯誤就交換\n3. 重複直到沒有需要交換的元素\n*/\n```\n\n### 3. 暫時停用程式碼\n```cpp\nstd::cout << \"除錯訊息\";\n// std::cout << \"這行程式碼被註解掉了\";\n```\n\n### 4. 版權和授權資訊\n```cpp\n/*\n檔案名稱: calculator.cpp\n作者: 張三\n建立日期: 2024年1月1日\n說明: 簡單計算機程式\n*/\n```\n\n## 好的註解習慣\n```cpp\n// 好的註解：說明為什麼\n// 使用二分搜尋法提高搜尋效率\nint binarySearch(int arr[], int size, int target) {\n    // ...\n}\n\n// 避免的註解：只說明做什麼\n// 設定 i 等於 0\nint i = 0;\n```\n\n## 實用範例\n```cpp\n/*\n程式名稱: 學生成績管理系統\n功能: 計算平均分數和等級\n版本: 1.0\n*/\n\n#include <iostream>\n\nint main() {\n    // 宣告變數儲存學生資料\n    int math = 85;     // 數學成績\n    int english = 92;  // 英文成績\n    int science = 78;  // 理化成績\n    \n    /*\n    計算平均分數\n    使用整數除法會無條件捨去小數部分\n    所以先轉換為浮點數\n    */\n    double average = (math + english + science) / 3.0;\n    \n    // 根據平均分數判定等級\n    char grade;\n    if (average >= 90) {\n        grade = 'A';     // 優秀\n    } else if (average >= 80) {\n        grade = 'B';     // 良好\n    } else if (average >= 70) {\n        grade = 'C';     // 普通\n    } else if (average >= 60) {\n        grade = 'D';     // 及格\n    } else {\n        grade = 'F';     // 不及格\n    }\n    \n    // 輸出結果\n    std::cout << \"平均分數: \" << average << std::endl;\n    std::cout << \"成績等級: \" << grade << std::endl;\n    \n    return 0;  // 程式正常結束\n}\n```"
    },
    {
      "id": "cpp-simple-calc",
      "title": "簡單運算",
      "description": "基本的數學運算",
      "code": "int result = a + b;",
      "language": "cpp",
      "topic": "C++ 基礎語法",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["運算", "數學", "原子式"]
      },
      "documentation": "# 簡單運算\n\n## 功能說明\nC++ 提供完整的數學運算子，用於執行基本的數學運算。\n\n## 基本算術運算子\n```cpp\nint a = 10, b = 3;\n\nint sum = a + b;        // 加法: 13\nint diff = a - b;       // 減法: 7\nint product = a * b;    // 乘法: 30\nint quotient = a / b;   // 除法: 3 (整數除法)\nint remainder = a % b;  // 餘數: 1\n```\n\n## 浮點數運算\n```cpp\ndouble x = 10.0, y = 3.0;\n\ndouble result1 = x / y;      // 3.33333...\ndouble result2 = x + y;      // 13.0\ndouble result3 = x - y;      // 7.0\ndouble result4 = x * y;      // 30.0\n// 注意：% 運算子不適用於浮點數\n```\n\n## 複合指定運算子\n```cpp\nint num = 10;\n\nnum += 5;    // 等同於 num = num + 5;  結果: 15\nnum -= 3;    // 等同於 num = num - 3;  結果: 12\nnum *= 2;    // 等同於 num = num * 2;  結果: 24\nnum /= 4;    // 等同於 num = num / 4;  結果: 6\nnum %= 5;    // 等同於 num = num % 5;  結果: 1\n```\n\n## 遞增遞減運算子\n```cpp\nint count = 5;\n\n// 前置遞增/遞減\nint a = ++count;  // count 先加 1，再賦值給 a，a=6, count=6\nint b = --count;  // count 先減 1，再賦值給 b，b=5, count=5\n\n// 後置遞增/遞減\nint c = count++;  // 先賦值給 c，count 再加 1，c=5, count=6\nint d = count--;  // 先賦值給 d，count 再減 1，d=6, count=5\n```\n\n## 實用範例\n```cpp\n#include <iostream>\n\nint main() {\n    // 計算商品總價\n    double unitPrice = 25.99;    // 單價\n    int quantity = 3;            // 數量\n    double discount = 0.1;       // 10% 折扣\n    \n    double subtotal = unitPrice * quantity;           // 小計\n    double discountAmount = subtotal * discount;      // 折扣金額\n    double total = subtotal - discountAmount;         // 總價\n    \n    std::cout << \"單價: $\" << unitPrice << std::endl;\n    std::cout << \"數量: \" << quantity << std::endl;\n    std::cout << \"小計: $\" << subtotal << std::endl;\n    std::cout << \"折扣: $\" << discountAmount << std::endl;\n    std::cout << \"總價: $\" << total << std::endl;\n    \n    // 計算平均分數\n    int score1 = 85, score2 = 92, score3 = 78;\n    double average = (score1 + score2 + score3) / 3.0;  // 注意用 3.0 而非 3\n    \n    std::cout << \"\n平均分數: \" << average << std::endl;\n    \n    return 0;\n}\n```"
    },
    {
      "id": "cpp-type-cast",
      "title": "型別轉換",
      "description": "基本的資料型別轉換",
      "code": "double result = static_cast<double>(intValue);",
      "language": "cpp",
      "topic": "C++ 基礎語法",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["轉換", "型別", "原子式"]
      },
      "documentation": "# 型別轉換\n\n## 功能說明\n型別轉換允許將一種資料型別的值轉換為另一種型別。\n\n## C++ 風格轉換（推薦）\n\n### static_cast （静態轉換）\n```cpp\n// 整數與浮點數轉換\nint intValue = 42;\ndouble doubleValue = static_cast<double>(intValue);  // 42.0\n\ndouble pi = 3.14159;\nint truncated = static_cast<int>(pi);               // 3 (截去小數)\n\n// 字元與整數轉換\nchar letter = 'A';\nint asciiValue = static_cast<int>(letter);          // 65\n\nint num = 66;\nchar character = static_cast<char>(num);            // 'B'\n```\n\n## C 風格轉換\n```cpp\n// 較簡潔但不安全的寫法\nint i = (int)3.14;        // 3\ndouble d = (double)42;    // 42.0\nchar c = (char)65;        // 'A'\n```\n\n## 常見轉換情境\n\n### 1. 整數除法轉浮點數\n```cpp\nint a = 7, b = 3;\n\n// 錯誤：整數除法結果只有整數部分\ndouble wrong = a / b;                    // 2.0\n\n// 正確：先轉換其中一個為浮點數\ndouble correct = static_cast<double>(a) / b;  // 2.33333\n// 或\ndouble correct2 = a / static_cast<double>(b); // 2.33333\n```\n\n### 2. 字元與 ASCII 值\n```cpp\n// 字元轉 ASCII\nchar grade = 'A';\nint ascii = static_cast<int>(grade);     // 65\n\n// ASCII 轉字元\nint value = 97;\nchar letter = static_cast<char>(value);  // 'a'\n\n// 大小寫轉換\nchar upper = 'A';\nchar lower = static_cast<char>(upper + 32);  // 'a'\n```\n\n### 3. 數學運算的精度控制\n```cpp\nint totalScore = 275;\nint subjectCount = 3;\n\n// 保持浮點數精度\ndouble average = static_cast<double>(totalScore) / subjectCount;  // 91.6667\n```\n\n## 注意事項\n- **精度損失**：浮點數轉整數會截去小數部分\n- **值範圍**：轉換時注意目標型別的值範圍\n- **安全性**：優先使用 static_cast 而非 C 風格轉換\n\n## 實用範例\n```cpp\n#include <iostream>\n\nint main() {\n    // 温度轉換：攝氏轉華氏\n    double celsius = 25.0;\n    double fahrenheit = celsius * 9.0 / 5.0 + 32.0;\n    \n    std::cout << celsius << \"°C = \" << fahrenheit << \"°F\" << std::endl;\n    \n    // 百分比計算\n    int correctAnswers = 85;\n    int totalQuestions = 100;\n    \n    double percentage = static_cast<double>(correctAnswers) / totalQuestions * 100;\n    \n    std::cout << \"正確率: \" << percentage << \"%\" << std::endl;\n    \n    // 字元編碼轉換\n    char startChar = 'A';\n    std::cout << \"字母表: \";\n    \n    for (int i = 0; i < 5; i++) {\n        char currentChar = static_cast<char>(startChar + i);\n        std::cout << currentChar << \" \";\n    }\n    std::cout << std::endl;  // 輸出: A B C D E\n    \n    return 0;\n}\n```"
    },
    {
      "id": "cpp-simple-if",
      "title": "簡單條件",
      "description": "基本的 if 判斷",
      "code": "if (x > 0) {\n    std::cout << \"正數\" << std::endl;\n}",
      "language": "cpp",
      "topic": "C++ 基礎語法",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["條件", "if", "原子式"]
      },
      "documentation": "# 簡單條件\n\n## 功能說明\nif 判斷式是程式流程控制的基礎，根據條件是否成立來決定是否執行特定程式碼。\n\n## 基本語法\n```cpp\nif (條件) {\n    // 條件為真時執行的程式碼\n}\n```\n\n## 比較運算子\n```cpp\nint a = 10, b = 5;\n\nif (a > b)   { /* a 大於 b */ }      // 大於\nif (a < b)   { /* a 小於 b */ }      // 小於\nif (a >= b)  { /* a 大於等於 b */ } // 大於等於\nif (a <= b)  { /* a 小於等於 b */ } // 小於等於\nif (a == b)  { /* a 等於 b */ }      // 等於\nif (a != b)  { /* a 不等於 b */ }    // 不等於\n```\n\n## 布林運算\n```cpp\nbool isLoggedIn = true;\nbool hasPermission = false;\n\nif (isLoggedIn)           { /* 已登入 */ }\nif (!hasPermission)       { /* 沒有權限 */ }\nif (isLoggedIn && hasPermission) { /* 已登入且有權限 */ }\nif (isLoggedIn || hasPermission) { /* 已登入或有權限 */ }\n```\n\n## 實用範例\n\n### 1. 數字判斷\n```cpp\n#include <iostream>\n\nint main() {\n    int number;\n    std::cout << \"請輸入一個整數: \";\n    std::cin >> number;\n    \n    if (number > 0) {\n        std::cout << number << \" 是正數\" << std::endl;\n    }\n    \n    if (number == 0) {\n        std::cout << \"這是零\" << std::endl;\n    }\n    \n    if (number < 0) {\n        std::cout << number << \" 是負數\" << std::endl;\n    }\n    \n    return 0;\n}\n```\n\n### 2. 年齡判斷\n```cpp\n#include <iostream>\n\nint main() {\n    int age;\n    std::cout << \"請輸入您的年齡: \";\n    std::cin >> age;\n    \n    if (age >= 18) {\n        std::cout << \"您是成年人\" << std::endl;\n    }\n    \n    if (age < 18 && age >= 0) {\n        std::cout << \"您是未成年人\" << std::endl;\n    }\n    \n    if (age < 0) {\n        std::cout << \"年齡不可能為負數!\" << std::endl;\n    }\n    \n    return 0;\n}\n```\n\n### 3. 密碼驗證\n```cpp\n#include <iostream>\n#include <string>\n\nint main() {\n    std::string password;\n    std::cout << \"請輸入密碼: \";\n    std::cin >> password;\n    \n    if (password == \"123456\") {\n        std::cout << \"登入成功!\" << std::endl;\n    } else {\n        std::cout << \"密碼錯誤!\" << std::endl;\n    }\n    \n    return 0;\n}\n```\n\n### 4. 成績判斷\n```cpp\n#include <iostream>\n\nint main() {\n    double score;\n    std::cout << \"請輸入成績 (0-100): \";\n    std::cin >> score;\n    \n    // 成績範圍檢查\n    if (score >= 0 && score <= 100) {\n        if (score >= 60) {\n            std::cout << \"及格! 成績: \" << score << std::endl;\n        } else {\n            std::cout << \"不及格! 成績: \" << score << std::endl;\n        }\n    } else {\n        std::cout << \"成績範圍錯誤! 請輸入 0-100 之間的數字\" << std::endl;\n    }\n    \n    return 0;\n}\n```"
    },
    {
      "id": "cpp-simple-loop",
      "title": "簡單迴圈",
      "description": "基本的 for 迴圈",
      "code": "for (int i = 0; i < 5; i++) {\n    std::cout << i << \" \";\n}",
      "language": "cpp",
      "topic": "C++ 基礎語法",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["迴圈", "for", "原子式"]
      },
      "documentation": "# 簡單迴圈\n\n## 功能說明\nfor 迴圈是重複執行程式碼的基本結構，當你知道需要執行多少次時使用。\n\n## 基本語法\n```cpp\nfor (初始化; 條件判斷; 更新) {\n    // 重複執行的程式碼\n}\n```\n\n## 迴圈結構說明\n```cpp\nfor (int i = 0; i < 5; i++) {\n//   ^^^^^^^^  ^^^^^  ^^^^\n//   初始化    條件   更新\n    std::cout << i << \" \";\n}\n// 執行順序：\n// 1. 初始化 i = 0\n// 2. 檢查條件 i < 5 (0 < 5 為真)\n// 3. 執行迴圈內容\n// 4. 更新 i++ (i變成1)\n// 5. 重複步驟2-4直到條件為假\n```\n\n## 常見迴圈模式\n\n### 1. 從0開始計數\n```cpp\nfor (int i = 0; i < 10; i++) {\n    std::cout << \"第 \" << i << \" 次\" << std::endl;\n}\n// 輸出: 0, 1, 2, ..., 9 (共10次)\n```\n\n### 2. 從1開始計數\n```cpp\nfor (int i = 1; i <= 10; i++) {\n    std::cout << i << \" \";\n}\n// 輸出: 1 2 3 4 5 6 7 8 9 10\n```\n\n### 3. 倒數迴圈\n```cpp\nfor (int i = 10; i >= 1; i--) {\n    std::cout << i << \" \";\n}\n// 輸出: 10 9 8 7 6 5 4 3 2 1\n```\n\n### 4. 步進迴圈\n```cpp\nfor (int i = 0; i <= 20; i += 2) {\n    std::cout << i << \" \";\n}\n// 輸出: 0 2 4 6 8 10 12 14 16 18 20\n```\n\n## 實用範例\n\n### 1. 計算總和\n```cpp\n#include <iostream>\n\nint main() {\n    int sum = 0;\n    \n    // 計算1到100的總和\n    for (int i = 1; i <= 100; i++) {\n        sum += i;\n    }\n    \n    std::cout << \"1到100的總和: \" << sum << std::endl;  // 5050\n    \n    return 0;\n}\n```\n\n### 2. 乘法表\n```cpp\n#include <iostream>\n\nint main() {\n    int number = 7;\n    \n    std::cout << number << \" 的乘法表:\" << std::endl;\n    \n    for (int i = 1; i <= 9; i++) {\n        int result = number * i;\n        std::cout << number << \" x \" << i << \" = \" << result << std::endl;\n    }\n    \n    return 0;\n}\n```\n\n### 3. 尋找最大值\n```cpp\n#include <iostream>\n\nint main() {\n    int numbers[] = {23, 67, 45, 89, 12, 56, 78};\n    int size = 7;\n    int maxValue = numbers[0];  // 假設第一個是最大值\n    \n    for (int i = 1; i < size; i++) {\n        if (numbers[i] > maxValue) {\n            maxValue = numbers[i];\n        }\n    }\n    \n    std::cout << \"最大值: \" << maxValue << std::endl;  // 89\n    \n    return 0;\n}\n```\n\n### 4. 星號圖案\n```cpp\n#include <iostream>\n\nint main() {\n    int rows = 5;\n    \n    // 印出直角三角形\n    for (int i = 1; i <= rows; i++) {\n        for (int j = 1; j <= i; j++) {\n            std::cout << \"* \";\n        }\n        std::cout << std::endl;\n    }\n    /*\n    輸出:\n    * \n    * * \n    * * * \n    * * * * \n    * * * * * \n    */\n    \n    return 0;\n}\n```\n\n## 迴圈控制\n```cpp\n// break: 立即跳出迴圈\nfor (int i = 0; i < 10; i++) {\n    if (i == 5) {\n        break;  // 當 i=5 時跳出\n    }\n    std::cout << i << \" \";  // 輸出: 0 1 2 3 4\n}\n\n// continue: 跳過本次迭代\nfor (int i = 0; i < 10; i++) {\n    if (i % 2 == 0) {\n        continue;  // 跳過偶數\n    }\n    std::cout << i << \" \";  // 輸出: 1 3 5 7 9\n}\n```"
    },
    {
      "id": "cpp-string-declare",
      "title": "字串宣告",
      "description": "基本的字串變數宣告",
      "code": "std::string message = \"Hello World\";",
      "language": "cpp",
      "topic": "C++ 基礎語法",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["字串", "宣告", "原子式"]
      },
      "documentation": "# 字串宣告\n\n最基本的字串變數宣告語法。\n\n```cpp\n#include <string>\n\nstd::string text = \"文字內容\";\nstd::string empty;\nstd::string name(\"張三\");\nstd::string repeated(5, 'A');  // \"AAAAA\"\n```"
    },
    {
      "id": "cpp-string-concat",
      "title": "字串連接",
      "description": "基本的字串連接操作",
      "code": "std::string result = str1 + str2;",
      "language": "cpp",
      "topic": "C++ 基礎語法",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["字串", "連接", "原子式"]
      },
      "documentation": "# 字串連接\n\n最基本的字串連接語法。\n\n```cpp\nstd::string first = \"Hello\";\nstd::string second = \"World\";\nstd::string result = first + \" \" + second;\n\n// 或使用 += 運算子\nfirst += \" World\";\n```"
    },
    {
      "id": "cpp-string-length",
      "title": "字串長度",
      "description": "取得字串長度",
      "code": "int len = text.length();",
      "language": "cpp",
      "topic": "C++ 基礎語法",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["字串", "長度", "原子式"]
      },
      "documentation": "# 字串長度\n\n取得字串長度的基本語法。\n\n```cpp\nstd::string text = \"Hello\";\nint len = text.length();     // 5\nint size = text.size();      // 5 (同 length)\nbool isEmpty = text.empty(); // false\n```"
    },
    {
      "id": "cpp-string-compare",
      "title": "字串比較",
      "description": "基本的字串比較",
      "code": "if (str1 == str2) {\n    // 字串相等\n}",
      "language": "cpp",
      "topic": "C++ 基礎語法",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["字串", "比較", "原子式"]
      },
      "documentation": "# 字串比較\n\n最基本的字串比較語法。\n\n```cpp\nstd::string a = \"apple\";\nstd::string b = \"banana\";\n\nif (a == b) { }      // 相等比較\nif (a != b) { }      // 不等比較\nif (a < b) { }       // 字典序比較\n```"
    },
    {
      "id": "cpp-array-declare",
      "title": "陣列宣告",
      "description": "基本的陣列宣告",
      "code": "int numbers[5] = {1, 2, 3, 4, 5};",
      "language": "cpp",
      "topic": "C++ 基礎語法",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["陣列", "宣告", "原子式"]
      },
      "documentation": "# 陣列宣告\n\n最基本的陣列宣告語法。\n\n```cpp\nint arr[5];                    // 宣告 5 個整數的陣列\nint nums[3] = {1, 2, 3};      // 初始化陣列\ndouble prices[] = {1.5, 2.0}; // 自動計算大小\nchar chars[10] = {'A', 'B'};   // 部分初始化\n```"
    },
    {
      "id": "cpp-class-basic",
      "title": "基本類別宣告",
      "description": "最簡單的類別定義",
      "code": "class Student {\npublic:\n    std::string name;\n    int age;\n};",
      "language": "cpp",
      "topic": "C++ 物件導向",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["類別", "class", "原子式"]
      },
      "documentation": "# 基本類別宣告\n\n## 功能說明\n類別是物件導向程式設計的基礎，用來定義物件的屬性和行為。\n\n## 基本語法\n```cpp\nclass 類別名稱 {\npublic:\n    // 公開成員\nprivate:\n    // 私有成員\nprotected:\n    // 保護成員\n};\n```\n\n## 存取修飾子\n- **public**: 任何地方都能存取\n- **private**: 只有類別內部能存取\n- **protected**: 類別內部和子類別能存取\n\n## 實用範例\n```cpp\n#include <iostream>\n#include <string>\n\nclass Student {\npublic:\n    std::string name;\n    int age;\n    double gpa;\n    \n    // 顯示學生資訊\n    void display() {\n        std::cout << \"姓名: \" << name << std::endl;\n        std::cout << \"年齡: \" << age << std::endl;\n        std::cout << \"GPA: \" << gpa << std::endl;\n    }\n};\n\nint main() {\n    Student s1;\n    s1.name = \"王小明\";\n    s1.age = 20;\n    s1.gpa = 3.8;\n    \n    s1.display();\n    \n    return 0;\n}\n```"
    },
    {
      "id": "cpp-constructor",
      "title": "建構子",
      "description": "類別的建構子函數",
      "code": "class Person {\npublic:\n    Person(std::string n, int a) : name(n), age(a) {}\nprivate:\n    std::string name;\n    int age;\n};",
      "language": "cpp",
      "topic": "C++ 物件導向",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["建構子", "constructor", "原子式"]
      },
      "documentation": "# 建構子\n\n## 功能說明\n建構子是物件建立時自動呼叫的特殊函數，用來初始化物件。\n\n## 基本語法\n```cpp\nclass ClassName {\npublic:\n    ClassName(參數列表) : 成員初始化列表 {\n        // 建構子主體\n    }\n};\n```\n\n## 建構子類型\n\n### 1. 預設建構子\n```cpp\nclass Student {\npublic:\n    Student() {  // 無參數建構子\n        name = \"未知\";\n        age = 0;\n    }\nprivate:\n    std::string name;\n    int age;\n};\n```\n\n### 2. 參數化建構子\n```cpp\nclass Student {\npublic:\n    Student(std::string n, int a) {\n        name = n;\n        age = a;\n    }\nprivate:\n    std::string name;\n    int age;\n};\n```\n\n### 3. 成員初始化列表\n```cpp\nclass Student {\npublic:\n    Student(std::string n, int a) : name(n), age(a) {\n        // 更有效率的初始化方式\n    }\nprivate:\n    std::string name;\n    int age;\n};\n```\n\n## 實用範例\n```cpp\n#include <iostream>\n#include <string>\n\nclass BankAccount {\npublic:\n    // 預設建構子\n    BankAccount() : accountNumber(\"\"), balance(0.0) {\n        std::cout << \"建立空帳戶\" << std::endl;\n    }\n    \n    // 參數化建構子\n    BankAccount(std::string account, double initialBalance) \n        : accountNumber(account), balance(initialBalance) {\n        std::cout << \"建立帳戶: \" << account << std::endl;\n    }\n    \n    void showInfo() {\n        std::cout << \"帳號: \" << accountNumber << std::endl;\n        std::cout << \"餘額: $\" << balance << std::endl;\n    }\n    \nprivate:\n    std::string accountNumber;\n    double balance;\n};\n\nint main() {\n    BankAccount account1;  // 使用預設建構子\n    BankAccount account2(\"12345\", 1000.0);  // 使用參數化建構子\n    \n    account1.showInfo();\n    account2.showInfo();\n    \n    return 0;\n}\n```"
    },
    {
      "id": "cpp-destructor",
      "title": "解構子",
      "description": "類別的解構子函數",
      "code": "class Resource {\npublic:\n    ~Resource() {\n        // 清理資源\n    }\n};",
      "language": "cpp",
      "topic": "C++ 物件導向",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["解構子", "destructor", "原子式"]
      },
      "documentation": "# 解構子\n\n## 功能說明\n解構子是物件銷毀時自動呼叫的特殊函數，用來清理資源。\n\n## 基本語法\n```cpp\nclass ClassName {\npublic:\n    ~ClassName() {\n        // 清理程式碼\n    }\n};\n```\n\n## 解構子特性\n- 名稱是類別名稱前加 ~\n- 沒有參數和回傳值\n- 每個類別只能有一個解構子\n- 物件超出作用域時自動呼叫\n\n## 實用範例\n```cpp\n#include <iostream>\n#include <string>\n\nclass FileHandler {\npublic:\n    FileHandler(std::string filename) : fileName(filename) {\n        std::cout << \"開啟檔案: \" << fileName << std::endl;\n    }\n    \n    ~FileHandler() {\n        std::cout << \"關閉檔案: \" << fileName << std::endl;\n    }\n    \nprivate:\n    std::string fileName;\n};\n\nclass DynamicArray {\npublic:\n    DynamicArray(int size) : size(size) {\n        data = new int[size];\n        std::cout << \"配置 \" << size << \" 個整數的記憶體\" << std::endl;\n    }\n    \n    ~DynamicArray() {\n        delete[] data;\n        std::cout << \"釋放記憶體\" << std::endl;\n    }\n    \nprivate:\n    int* data;\n    int size;\n};\n\nint main() {\n    {\n        FileHandler file(\"data.txt\");\n        DynamicArray arr(100);\n        \n        // 在這個區塊結束時，解構子會自動被呼叫\n    }\n    \n    std::cout << \"程式繼續執行\" << std::endl;\n    \n    return 0;\n}\n```"
    },
    {
      "id": "cpp-member-function",
      "title": "成員函數",
      "description": "類別的成員函數定義",
      "code": "class Calculator {\npublic:\n    int add(int a, int b) {\n        return a + b;\n    }\n};",
      "language": "cpp",
      "topic": "C++ 物件導向",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["成員函數", "method", "原子式"]
      },
      "documentation": "# 成員函數\n\n## 功能說明\n成員函數是定義在類別內部的函數，用來操作物件的資料和實現物件的行為。\n\n## 基本語法\n```cpp\nclass ClassName {\npublic:\n    return_type functionName(parameters) {\n        // 函數實作\n    }\n};\n```\n\n## 成員函數類型\n\n### 1. 一般成員函數\n```cpp\nclass Counter {\npublic:\n    void increment() {\n        count++;\n    }\n    \n    int getValue() {\n        return count;\n    }\n    \nprivate:\n    int count = 0;\n};\n```\n\n### 2. const 成員函數\n```cpp\nclass Point {\npublic:\n    double getDistance() const {  // 不會修改物件狀態\n        return sqrt(x*x + y*y);\n    }\n    \nprivate:\n    double x, y;\n};\n```\n\n### 3. 類別外定義\n```cpp\nclass Calculator {\npublic:\n    int multiply(int a, int b);  // 宣告\n};\n\n// 在類別外定義\nint Calculator::multiply(int a, int b) {\n    return a * b;\n}\n```\n\n## 實用範例\n```cpp\n#include <iostream>\n#include <string>\n\nclass BankAccount {\npublic:\n    BankAccount(std::string account, double initial) \n        : accountNumber(account), balance(initial) {}\n    \n    // 存款\n    void deposit(double amount) {\n        if (amount > 0) {\n            balance += amount;\n            std::cout << \"存款 $\" << amount << \" 成功\" << std::endl;\n        }\n    }\n    \n    // 提款\n    bool withdraw(double amount) {\n        if (amount > 0 && amount <= balance) {\n            balance -= amount;\n            std::cout << \"提款 $\" << amount << \" 成功\" << std::endl;\n            return true;\n        }\n        std::cout << \"提款失敗：餘額不足或金額無效\" << std::endl;\n        return false;\n    }\n    \n    // 查詢餘額 (const 函數)\n    double getBalance() const {\n        return balance;\n    }\n    \n    // 顯示帳戶資訊\n    void showAccount() const {\n        std::cout << \"帳號: \" << accountNumber << std::endl;\n        std::cout << \"餘額: $\" << balance << std::endl;\n    }\n    \nprivate:\n    std::string accountNumber;\n    double balance;\n};\n\nint main() {\n    BankAccount account(\"123-456-789\", 1000.0);\n    \n    account.showAccount();\n    account.deposit(500.0);\n    account.withdraw(200.0);\n    account.showAccount();\n    \n    std::cout << \"當前餘額: $\" << account.getBalance() << std::endl;\n    \n    return 0;\n}\n```"
    },
    {
      "id": "cpp-private-public",
      "title": "存取修飾子",
      "description": "public 和 private 存取控制",
      "code": "class Example {\npublic:\n    int publicVar;\nprivate:\n    int privateVar;\n};",
      "language": "cpp",
      "topic": "C++ 物件導向",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["存取控制", "public", "private", "原子式"]
      },
      "documentation": "# 存取修飾子\n\n## 功能說明\n存取修飾子控制類別成員的可見性和存取權限，實現封裝的概念。\n\n## 存取修飾子類型\n\n### public (公開)\n- 任何地方都可以存取\n- 類別的對外介面\n\n### private (私有)\n- 只有類別內部可以存取\n- 實現資料隱藏\n\n### protected (保護)\n- 類別內部和子類別可以存取\n- 繼承時使用\n\n## 實用範例\n```cpp\n#include <iostream>\n#include <string>\n\nclass Student {\npublic:\n    // 公開介面：外部可以呼叫\n    Student(std::string name, int age) : name_(name), age_(age) {}\n    \n    void setGrade(double grade) {\n        if (isValidGrade(grade)) {\n            grade_ = grade;\n        } else {\n            std::cout << \"無效的成績!\" << std::endl;\n        }\n    }\n    \n    double getGrade() const {\n        return grade_;\n    }\n    \n    void displayInfo() const {\n        std::cout << \"姓名: \" << name_ << std::endl;\n        std::cout << \"年齡: \" << age_ << std::endl;\n        std::cout << \"成績: \" << grade_ << std::endl;\n        std::cout << \"等級: \" << calculateGradeLevel() << std::endl;\n    }\n    \nprivate:\n    // 私有資料：外部無法直接存取\n    std::string name_;\n    int age_;\n    double grade_ = 0.0;\n    \n    // 私有輔助函數：內部使用\n    bool isValidGrade(double grade) const {\n        return grade >= 0.0 && grade <= 100.0;\n    }\n    \n    std::string calculateGradeLevel() const {\n        if (grade_ >= 90) return \"A\";\n        if (grade_ >= 80) return \"B\";\n        if (grade_ >= 70) return \"C\";\n        if (grade_ >= 60) return \"D\";\n        return \"F\";\n    }\n};\n\nint main() {\n    Student student(\"王小明\", 20);\n    \n    // 正確：使用公開介面\n    student.setGrade(85.5);\n    student.displayInfo();\n    \n    // 錯誤：無法直接存取私有成員\n    // student.name_ = \"李小華\";  // 編譯錯誤\n    // student.grade_ = 95.0;     // 編譯錯誤\n    \n    // 正確：透過公開方法存取\n    std::cout << \"目前成績: \" << student.getGrade() << std::endl;\n    \n    return 0;\n}\n```"
    },
    {
      "id": "cpp-inheritance",
      "title": "繼承",
      "description": "基本的類別繼承",
      "code": "class Animal {\npublic:\n    void eat() { /* ... */ }\n};\n\nclass Dog : public Animal {\npublic:\n    void bark() { /* ... */ }\n};",
      "language": "cpp",
      "topic": "C++ 物件導向",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["繼承", "inheritance", "原子式"]
      },
      "documentation": "# 繼承\n\n## 功能說明\n繼承允許一個類別獲得另一個類別的屬性和方法，實現程式碼重用和建立類別階層。\n\n## 基本語法\n```cpp\nclass 子類別 : 存取修飾子 父類別 {\n    // 子類別的成員\n};\n```\n\n## 繼承類型\n- **public 繼承**: 最常用，保持原有存取層級\n- **private 繼承**: 父類別的 public 成員變成 private\n- **protected 繼承**: 父類別的 public 成員變成 protected\n\n## 實用範例\n```cpp\n#include <iostream>\n#include <string>\n\n// 基底類別\nclass Vehicle {\nprotected:\n    std::string brand;\n    int year;\n    \npublic:\n    Vehicle(std::string b, int y) : brand(b), year(y) {}\n    \n    void start() {\n        std::cout << brand << \" 引擎啟動\" << std::endl;\n    }\n    \n    void stop() {\n        std::cout << brand << \" 引擎關閉\" << std::endl;\n    }\n    \n    virtual void displayInfo() {\n        std::cout << \"品牌: \" << brand << std::endl;\n        std::cout << \"年份: \" << year << std::endl;\n    }\n};\n\n// 衍生類別：汽車\nclass Car : public Vehicle {\nprivate:\n    int doors;\n    \npublic:\n    Car(std::string b, int y, int d) : Vehicle(b, y), doors(d) {}\n    \n    void honk() {\n        std::cout << brand << \" 按喇叭: 嘟嘟!\" << std::endl;\n    }\n    \n    void displayInfo() override {\n        Vehicle::displayInfo();  // 呼叫父類別方法\n        std::cout << \"門數: \" << doors << std::endl;\n        std::cout << \"類型: 汽車\" << std::endl;\n    }\n};\n\n// 衍生類別：機車\nclass Motorcycle : public Vehicle {\nprivate:\n    bool hasSidecar;\n    \npublic:\n    Motorcycle(std::string b, int y, bool sidecar = false) \n        : Vehicle(b, y), hasSidecar(sidecar) {}\n    \n    void wheelie() {\n        std::cout << brand << \" 後輪離地!\" << std::endl;\n    }\n    \n    void displayInfo() override {\n        Vehicle::displayInfo();\n        std::cout << \"邊車: \" << (hasSidecar ? \"有\" : \"無\") << std::endl;\n        std::cout << \"類型: 機車\" << std::endl;\n    }\n};\n\nint main() {\n    Car myCar(\"Toyota\", 2020, 4);\n    Motorcycle myBike(\"Yamaha\", 2019, false);\n    \n    std::cout << \"=== 汽車資訊 ===\" << std::endl;\n    myCar.start();        // 繼承自 Vehicle\n    myCar.honk();         // Car 特有方法\n    myCar.displayInfo();  // 覆寫的方法\n    myCar.stop();         // 繼承自 Vehicle\n    \n    std::cout << \"\\n=== 機車資訊 ===\" << std::endl;\n    myBike.start();       // 繼承自 Vehicle\n    myBike.wheelie();     // Motorcycle 特有方法\n    myBike.displayInfo(); // 覆寫的方法\n    myBike.stop();        // 繼承自 Vehicle\n    \n    return 0;\n}\n```"
    },
    {
      "id": "cpp-virtual-function",
      "title": "虛擬函數",
      "description": "虛擬函數的基本用法",
      "code": "class Base {\npublic:\n    virtual void show() {\n        // 基底實作\n    }\n};",
      "language": "cpp",
      "topic": "C++ 物件導向",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["虛擬函數", "virtual", "原子式"]
      },
      "documentation": "# 虛擬函數\n\n## 功能說明\n虛擬函數實現多型機制，允許在執行時期決定要呼叫哪個版本的函數。\n\n## 基本語法\n```cpp\nclass Base {\npublic:\n    virtual return_type functionName(parameters) {\n        // 基底實作\n    }\n};\n\nclass Derived : public Base {\npublic:\n    return_type functionName(parameters) override {\n        // 衍生類別實作\n    }\n};\n```\n\n## 關鍵字\n- **virtual**: 宣告虛擬函數\n- **override**: 明確標示覆寫父類別函數\n- **final**: 防止進一步覆寫\n\n## 實用範例\n```cpp\n#include <iostream>\n#include <vector>\n#include <memory>\n\n// 基底類別\nclass Shape {\nprotected:\n    std::string color;\n    \npublic:\n    Shape(std::string c) : color(c) {}\n    \n    // 虛擬函數\n    virtual double getArea() const = 0;  // 純虛擬函數\n    virtual void draw() const {\n        std::cout << \"繪製 \" << color << \" 的圖形\" << std::endl;\n    }\n    \n    // 虛擬解構子\n    virtual ~Shape() = default;\n};\n\n// 衍生類別：圓形\nclass Circle : public Shape {\nprivate:\n    double radius;\n    \npublic:\n    Circle(std::string c, double r) : Shape(c), radius(r) {}\n    \n    double getArea() const override {\n        return 3.14159 * radius * radius;\n    }\n    \n    void draw() const override {\n        std::cout << \"繪製半徑 \" << radius << \" 的\" << color << \"圓形\" << std::endl;\n    }\n};\n\n// 衍生類別：矩形\nclass Rectangle : public Shape {\nprivate:\n    double width, height;\n    \npublic:\n    Rectangle(std::string c, double w, double h) \n        : Shape(c), width(w), height(h) {}\n    \n    double getArea() const override {\n        return width * height;\n    }\n    \n    void draw() const override {\n        std::cout << \"繪製 \" << width << \"x\" << height \n                  << \" 的\" << color << \"矩形\" << std::endl;\n    }\n};\n\n// 示範多型\nvoid printShapeInfo(const Shape& shape) {\n    shape.draw();  // 動態決定呼叫哪個版本\n    std::cout << \"面積: \" << shape.getArea() << std::endl;\n    std::cout << \"---\" << std::endl;\n}\n\nint main() {\n    // 建立不同的圖形物件\n    Circle circle(\"紅色\", 5.0);\n    Rectangle rect(\"藍色\", 4.0, 6.0);\n    \n    // 多型的威力：同一個函數處理不同類型\n    printShapeInfo(circle);\n    printShapeInfo(rect);\n    \n    // 使用指標陣列實現多型\n    std::vector<std::unique_ptr<Shape>> shapes;\n    shapes.push_back(std::make_unique<Circle>(\"綠色\", 3.0));\n    shapes.push_back(std::make_unique<Rectangle>(\"黃色\", 5.0, 8.0));\n    shapes.push_back(std::make_unique<Circle>(\"紫色\", 7.0));\n    \n    std::cout << \"\\n=== 圖形集合 ===\" << std::endl;\n    double totalArea = 0;\n    for (const auto& shape : shapes) {\n        shape->draw();\n        double area = shape->getArea();\n        std::cout << \"面積: \" << area << std::endl;\n        totalArea += area;\n        std::cout << \"---\" << std::endl;\n    }\n    \n    std::cout << \"總面積: \" << totalArea << std::endl;\n    \n    return 0;\n}\n```"
    },
    {
      "id": "cpp-template-function",
      "title": "函數模板",
      "description": "泛型函數模板的基本用法",
      "code": "template<typename T>\nT maximum(T a, T b) {\n    return (a > b) ? a : b;\n}",
      "language": "cpp",
      "topic": "C++ 進階特性",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "advanced",
        "tags": ["模板", "template", "泛型", "原子式"]
      },
      "documentation": "# 函數模板\n\n## 功能說明\n函數模板允許編寫泛型函數，可以處理多種資料型別而不需要重複寫程式碼。\n\n## 基本語法\n```cpp\ntemplate<typename T>\nreturn_type functionName(T parameter) {\n    // 函數實作\n}\n```\n\n## 實用範例\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\n// 基本函數模板\ntemplate<typename T>\nT maximum(T a, T b) {\n    return (a > b) ? a : b;\n}\n\n// 多參數模板\ntemplate<typename T, typename U>\nauto add(T a, U b) -> decltype(a + b) {\n    return a + b;\n}\n\nint main() {\n    // 整數比較\n    int a = 10, b = 20;\n    std::cout << \"max(\" << a << \", \" << b << \") = \" \n              << maximum(a, b) << std::endl;\n    \n    // 浮點數比較\n    double x = 3.14, y = 2.71;\n    std::cout << \"max(\" << x << \", \" << y << \") = \" \n              << maximum(x, y) << std::endl;\n    \n    // 字串比較\n    std::string s1 = \"apple\", s2 = \"banana\";\n    std::cout << \"max(\" << s1 << \", \" << s2 << \") = \" \n              << maximum(s1, s2) << std::endl;\n    \n    return 0;\n}\n```"
    },
    {
      "id": "cpp-stl-vector",
      "title": "STL Vector",
      "description": "動態陣列容器的基本用法",
      "code": "#include <vector>\nstd::vector<int> numbers = {1, 2, 3, 4, 5};\nnumbers.push_back(6);",
      "language": "cpp",
      "topic": "C++ 進階特性",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "advanced",
        "tags": ["STL", "vector", "容器", "原子式"]
      },
      "documentation": "# STL Vector\n\n## 功能說明\nvector 是 C++ 標準庫中的動態陣列容器，可以自動調整大小。\n\n## 基本語法\n```cpp\n#include <vector>\nstd::vector<T> vectorName;\nstd::vector<T> vectorName = {初始值列表};\nstd::vector<T> vectorName(大小, 預設值);\n```\n\n## 常用操作\n```cpp\nvec.push_back(element);    // 在尾端加入元素\nvec.pop_back();            // 移除尾端元素\nvec.size();                // 取得大小\nvec.empty();               // 檢查是否為空\nvec.clear();               // 清空所有元素\nvec[index];                // 存取元素\nvec.at(index);             // 安全存取元素\n```\n\n## 實用範例\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5};\n    numbers.push_back(6);\n    \n    std::cout << \"numbers: \";\n    for (int num : numbers) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}\n```"
    },
    {
      "id": "cpp-smart-pointer",
      "title": "智慧指標",
      "description": "智慧指標的基本用法",
      "code": "#include <memory>\nstd::unique_ptr<int> ptr = std::make_unique<int>(42);\nstd::shared_ptr<int> shared = std::make_shared<int>(100);",
      "language": "cpp",
      "topic": "C++ 進階特性",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "advanced",
        "tags": ["智慧指標", "smart pointer", "記憶體管理", "原子式"]
      },
      "documentation": "# 智慧指標\n\n## 功能說明\n智慧指標自動管理記憶體，避免記憶體洩漏和懸空指標問題。\n\n## 主要類型\n- **unique_ptr**: 獨佔所有權\n- **shared_ptr**: 共享所有權\n- **weak_ptr**: 弱引用，不影響物件生命週期\n\n## 基本語法\n```cpp\n#include <memory>\nstd::unique_ptr<T> ptr = std::make_unique<T>(參數);\nstd::shared_ptr<T> shared = std::make_shared<T>(參數);\n```\n\n## 實用範例\n```cpp\n#include <iostream>\n#include <memory>\n\nclass Person {\npublic:\n    std::string name;\n    Person(std::string n) : name(n) {}\n};\n\nint main() {\n    auto person = std::make_unique<Person>(\"Alice\");\n    std::cout << person->name << std::endl;\n    \n    return 0;\n}\n```"
    },
    {
      "id": "cpp-lambda",
      "title": "Lambda 表達式",
      "description": "Lambda 匿名函數的基本用法",
      "code": "auto lambda = [](int x, int y) { return x + y; };\nint result = lambda(3, 4);",
      "language": "cpp",
      "topic": "C++ 進階特性",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "advanced",
        "tags": ["lambda", "匿名函數", "函數物件", "原子式"]
      },
      "documentation": "# Lambda 表達式\n\n## 功能說明\nLambda 表達式提供簡潔的方式定義匿名函數，常用於演算法和事件處理。\n\n## 基本語法\n```cpp\n[capture](parameters) -> return_type {\n    // 函數主體\n}\n```\n\n## 捕獲方式\n- `[]`: 不捕獲任何變數\n- `[=]`: 按值捕獲所有變數\n- `[&]`: 按引用捕獲所有變數\n- `[var]`: 按值捕獲特定變數\n- `[&var]`: 按引用捕獲特定變數\n\n## 實用範例\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5};\n    \n    // 使用 lambda 與 for_each\n    std::for_each(numbers.begin(), numbers.end(), \n                  [](int n) { std::cout << n << \" \"; });\n    \n    // lambda 函數變數\n    auto add = [](int a, int b) { return a + b; };\n    std::cout << add(3, 4) << std::endl;\n    \n    return 0;\n}\n```"
    },
    {
      "id": "cpp-auto-keyword",
      "title": "auto 關鍵字",
      "description": "自動型別推導的基本用法",
      "code": "auto number = 42;        // int\nauto pi = 3.14;          // double\nauto text = \"Hello\";     // const char*",
      "language": "cpp",
      "topic": "C++ 進階特性",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "advanced",
        "tags": ["auto", "型別推導", "現代C++", "原子式"]
      },
      "documentation": "# auto 關鍵字\n\n## 功能說明\nauto 關鍵字讓編譯器自動推導變數型別，簡化程式碼並提高可維護性。\n\n## 基本語法\n```cpp\nauto 變數名稱 = 初始值;\nauto 變數名稱 {初始值};\n```\n\n## 使用場合\n- 複雜型別名稱很長時\n- 模板程式設計中的未知型別\n- 迭代器和範圍迴圈\n- Lambda 表達式\n\n## 實用範例\n```cpp\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n\nint main() {\n    // 基本型別推導\n    auto number = 42;        // int\n    auto pi = 3.14159;       // double\n    auto letter = 'A';       // char\n    auto flag = true;        // bool\n    auto text = \"Hello\";     // const char*\n    \n    std::cout << \"number: \" << number << std::endl;\n    std::cout << \"pi: \" << pi << std::endl;\n    \n    // 容器型別推導\n    auto numbers = std::vector<int>{1, 2, 3, 4, 5};\n    auto words = std::vector<std::string>{\"hello\", \"world\"};\n    \n    // 迭代器簡化\n    std::map<std::string, int> scores = {\n        {\"Alice\", 95}, {\"Bob\", 87}, {\"Charlie\", 92}\n    };\n    \n    // 不使用 auto（繁瑣）\n    for (std::map<std::string, int>::iterator it = scores.begin(); \n         it != scores.end(); ++it) {\n        // ...\n    }\n    \n    // 使用 auto（簡潔）\n    for (auto it = scores.begin(); it != scores.end(); ++it) {\n        std::cout << it->first << \": \" << it->second << std::endl;\n    }\n    \n    // 範圍迴圈\n    for (const auto& pair : scores) {\n        std::cout << pair.first << \" got \" << pair.second << std::endl;\n    }\n    \n    return 0;\n}\n```"
    },
    {
      "id": "arduino-basic-setup",
      "title": "基本程式結構",
      "description": "Arduino 程式的基本架構",
      "code": "void setup() {\n  // 初始化程式碼，只執行一次\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  // 主要程式碼，重複執行\n}",
      "language": "arduino",
      "topic": "Arduino 硬體基礎",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["基礎架構", "setup", "loop", "原子式"]
      },
      "documentation": "# Arduino 基本程式結構\n\n## 功能說明\nArduino 程式必須包含兩個主要函數：setup() 和 loop()。\n\n## 基本架構\n```cpp\nvoid setup() {\n  // 初始化程式碼，在 Arduino 啟動時只執行一次\n}\n\nvoid loop() {\n  // 主要程式碼，會不斷重複執行\n}\n```\n\n## setup() 函數\n- 程式開始時執行一次\n- 用於初始化設定\n- 設定腳位模式\n- 初始化通訊協定\n- 設定初始變數值\n\n## loop() 函數\n- setup() 執行完後開始執行\n- 持續重複執行\n- 包含主要程式邏輯\n- 讀取感測器、控制輸出等\n\n## 實用範例\n```cpp\n// LED 閃爍範例\nvoid setup() {\n  pinMode(13, OUTPUT);  // 設定第13號腳位為輸出\n  Serial.begin(9600);   // 初始化序列通訊，鮑率9600\n}\n\nvoid loop() {\n  digitalWrite(13, HIGH);  // 點亮 LED\n  delay(1000);            // 等待 1 秒\n  digitalWrite(13, LOW);   // 關閉 LED\n  delay(1000);            // 等待 1 秒\n  \n  Serial.println(\"LED 閃爍中\");  // 輸出訊息到序列監視器\n}\n```"
    },
    {
      "id": "arduino-digital-output",
      "title": "數位輸出",
      "description": "控制數位腳位輸出高低電位",
      "code": "pinMode(13, OUTPUT);\ndigitalWrite(13, HIGH);  // 輸出高電位\ndigitalWrite(13, LOW);   // 輸出低電位",
      "language": "arduino",
      "topic": "Arduino 硬體基礎",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["數位輸出", "digitalWrite", "LED", "原子式"]
      },
      "documentation": "# 數位輸出\n\n## 功能說明\n數位輸出用於控制腳位輸出高電位(5V)或低電位(0V)，常用於控制 LED、繼電器等。\n\n## 基本語法\n```cpp\npinMode(pin, OUTPUT);        // 設定腳位為輸出模式\ndigitalWrite(pin, HIGH);     // 輸出高電位 (5V)\ndigitalWrite(pin, LOW);      // 輸出低電位 (0V)\n```\n\n## 腳位設定\n- **OUTPUT**: 將腳位設為輸出模式\n- 必須在 setup() 中設定\n- 一次設定，整個程式期間有效\n\n## 輸出狀態\n- **HIGH**: 高電位，通常是 5V\n- **LOW**: 低電位，通常是 0V\n- 也可使用數值：1 代表 HIGH，0 代表 LOW\n\n## 實用範例\n```cpp\nvoid setup() {\n  pinMode(13, OUTPUT);  // 內建 LED (第13號腳位)\n}\n\nvoid loop() {\n  digitalWrite(13, HIGH);  // 點亮 LED\n  delay(1000);            // 等待 1 秒\n  digitalWrite(13, LOW);   // 關閉 LED\n  delay(1000);            // 等待 1 秒\n}\n```"
    },
    {
      "id": "arduino-digital-input",
      "title": "數位輸入",
      "description": "讀取數位腳位的高低電位狀態",
      "code": "pinMode(2, INPUT_PULLUP);\nint buttonState = digitalRead(2);\nif (buttonState == LOW) {\n  // 按鈕被按下\n}",
      "language": "arduino",
      "topic": "Arduino 硬體基礎",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["數位輸入", "digitalRead", "按鈕", "原子式"]
      },
      "documentation": "# 數位輸入\n\n## 功能說明\n數位輸入用於讀取腳位的電位狀態，判斷是高電位(HIGH)還是低電位(LOW)。\n\n## 基本語法\n```cpp\npinMode(pin, INPUT);         // 設定腳位為輸入模式\npinMode(pin, INPUT_PULLUP);  // 設定為輸入模式並啟用內建上拉電阻\nint state = digitalRead(pin); // 讀取腳位狀態\n```\n\n## 輸入模式\n- **INPUT**: 一般輸入模式，需要外部上拉/下拉電阻\n- **INPUT_PULLUP**: 啟用內建上拉電阻，腳位預設為 HIGH\n\n## 讀取結果\n- **HIGH**: 高電位，邏輯 1\n- **LOW**: 低電位，邏輯 0\n\n## 實用範例\n```cpp\nvoid setup() {\n  pinMode(2, INPUT_PULLUP);  // 按鈕腳位\n  pinMode(13, OUTPUT);       // LED 腳位\n}\n\nvoid loop() {\n  int buttonState = digitalRead(2);\n  \n  if (buttonState == LOW) {  // 按鈕被按下\n    digitalWrite(13, HIGH);  // 點亮 LED\n  } else {\n    digitalWrite(13, LOW);   // 關閉 LED\n  }\n}\n```"
    },
    {
      "id": "arduino-analog-input",
      "title": "類比輸入",
      "description": "讀取類比腳位的電壓值",
      "code": "int sensorValue = analogRead(A0);\nfloat voltage = sensorValue * (5.0 / 1023.0);",
      "language": "arduino",
      "topic": "Arduino 硬體基礎",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["類比輸入", "analogRead", "感測器", "原子式"]
      },
      "documentation": "# 類比輸入\n\n## 功能說明\n類比輸入用於讀取連續變化的電壓值，將 0-5V 的電壓轉換為 0-1023 的數位值。\n\n## 基本語法\n```cpp\nint value = analogRead(pin);  // 讀取類比腳位值 (0-1023)\n```\n\n## 類比腳位\n- Arduino Uno 有 6 個類比輸入腳位：A0, A1, A2, A3, A4, A5\n- 不需要設定 pinMode，預設就是輸入模式\n- 10-bit ADC，解析度為 1024 (0-1023)\n\n## 電壓轉換\n```cpp\nfloat voltage = analogValue * (5.0 / 1023.0);  // 轉換為實際電壓\n```\n\n## 實用範例\n```cpp\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int sensorValue = analogRead(A0);\n  float voltage = sensorValue * (5.0 / 1023.0);\n  \n  Serial.print(\"類比值: \");\n  Serial.print(sensorValue);\n  Serial.print(\", 電壓: \");\n  Serial.print(voltage);\n  Serial.println(\"V\");\n  \n  delay(500);\n}\n```"
    },
    {
      "id": "arduino-pwm-output",
      "title": "PWM 輸出",
      "description": "產生脈寬調變訊號控制亮度或速度",
      "code": "pinMode(9, OUTPUT);\nanalogWrite(9, 128);  // 50% 占空比\nanalogWrite(9, 255);  // 100% 占空比",
      "language": "arduino",
      "topic": "Arduino 硬體基礎",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["PWM", "analogWrite", "亮度控制", "原子式"]
      },
      "documentation": "# PWM 輸出\n\n## 功能說明\nPWM (脈寬調變) 透過快速開關來模擬類比輸出，常用於控制 LED 亮度、馬達速度等。\n\n## 基本語法\n```cpp\nanalogWrite(pin, value);  // value: 0-255\n```\n\n## PWM 腳位\nArduino Uno 的 PWM 腳位（標示 ~ 符號）：\n- 數位腳位：3, 5, 6, 9, 10, 11\n- 輸出頻率約 490Hz (腳位 5, 6 為 980Hz)\n\n## 數值範圍\n- **0**: 完全關閉 (0% 占空比)\n- **127**: 一半亮度 (50% 占空比)\n- **255**: 最大亮度 (100% 占空比)\n\n## 實用範例\n```cpp\nvoid setup() {\n  pinMode(9, OUTPUT);\n}\n\nvoid loop() {\n  // 逐漸變亮\n  for (int brightness = 0; brightness <= 255; brightness++) {\n    analogWrite(9, brightness);\n    delay(5);\n  }\n  \n  // 逐漸變暗\n  for (int brightness = 255; brightness >= 0; brightness--) {\n    analogWrite(9, brightness);\n    delay(5);\n  }\n}\n```"
    },
    {
      "id": "arduino-serial-comm",
      "title": "序列通訊",
      "description": "透過 Serial 進行資料通訊",
      "code": "Serial.begin(9600);\nSerial.println(\"Hello World\");\nif (Serial.available()) {\n  String data = Serial.readString();\n}",
      "language": "arduino",
      "topic": "Arduino 硬體基礎",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["序列通訊", "Serial", "除錯", "原子式"]
      },
      "documentation": "# 序列通訊\n\n## 功能說明\n序列通訊用於 Arduino 與電腦之間傳輸資料，是除錯和監控的重要工具。\n\n## 基本語法\n```cpp\nSerial.begin(baudrate);        // 初始化序列通訊\nSerial.print(data);            // 輸出資料\nSerial.println(data);          // 輸出資料並換行\nSerial.available();            // 檢查是否有資料可讀\nSerial.read();                 // 讀取一個位元組\nSerial.readString();           // 讀取字串\n```\n\n## 鮑率設定\n常用鮑率：9600, 19200, 38400, 57600, 115200\n- 數值越高，傳輸速度越快\n- 必須與序列監視器設定一致\n\n## 實用範例\n```cpp\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(\"Arduino 已啟動\");\n}\n\nvoid loop() {\n  int sensorValue = analogRead(A0);\n  Serial.print(\"感測器值: \");\n  Serial.println(sensorValue);\n  delay(1000);\n}\n```"
    },
    {
      "id": "arduino-delay-timing",
      "title": "延遲與計時",
      "description": "控制程式執行時間",
      "code": "delay(1000);           // 延遲 1 秒\ndelayMicroseconds(100); // 延遲 100 微秒\nunsigned long time = millis(); // 取得執行時間",
      "language": "arduino",
      "topic": "Arduino 硬體基礎",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["延遲", "計時", "millis", "原子式"]
      },
      "documentation": "# 延遲與計時\n\n## 功能說明\n控制程式執行的時間間隔，實現定時功能和防止程式執行過快。\n\n## 延遲函數\n```cpp\ndelay(milliseconds);        // 毫秒延遲 (1/1000 秒)\ndelayMicroseconds(microseconds); // 微秒延遲 (1/1000000 秒)\n```\n\n## 計時函數\n```cpp\nmillis();     // 回傳程式啟動後的毫秒數\nmicros();     // 回傳程式啟動後的微秒數\n```\n\n## 非阻塞式計時\n使用 millis() 實現不阻塞程式執行的計時：\n\n```cpp\nunsigned long previousTime = 0;\nconst long interval = 1000;  // 間隔時間\n\nvoid loop() {\n  unsigned long currentTime = millis();\n  \n  if (currentTime - previousTime >= interval) {\n    previousTime = currentTime;\n    // 執行定時任務\n  }\n}\n```\n\n## 實用範例\n```cpp\n// 多個 LED 不同閃爍頻率\nunsigned long led1Time = 0;\nunsigned long led2Time = 0;\nconst long led1Interval = 500;   // 0.5 秒\nconst long led2Interval = 1000;  // 1 秒\n\nvoid setup() {\n  pinMode(12, OUTPUT);\n  pinMode(13, OUTPUT);\n}\n\nvoid loop() {\n  unsigned long currentTime = millis();\n  \n  // LED1 每 0.5 秒閃爍\n  if (currentTime - led1Time >= led1Interval) {\n    led1Time = currentTime;\n    digitalWrite(12, !digitalRead(12));\n  }\n  \n  // LED2 每 1 秒閃爍\n  if (currentTime - led2Time >= led2Interval) {\n    led2Time = currentTime;\n    digitalWrite(13, !digitalRead(13));\n  }\n}\n```"
    },
    {
      "id": "arduino-ultrasonic-sensor",
      "title": "超音波感測器",
      "description": "HC-SR04 超音波距離測量",
      "code": "#define TRIG_PIN 7\n#define ECHO_PIN 8\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(TRIG_PIN, OUTPUT);\n  pinMode(ECHO_PIN, INPUT);\n}\n\nvoid loop() {\n  long distance = getDistance();\n  Serial.print(\"距離: \");\n  Serial.print(distance);\n  Serial.println(\" cm\");\n  delay(500);\n}\n\nlong getDistance() {\n  digitalWrite(TRIG_PIN, LOW);\n  delayMicroseconds(2);\n  digitalWrite(TRIG_PIN, HIGH);\n  delayMicroseconds(10);\n  digitalWrite(TRIG_PIN, LOW);\n  \n  long duration = pulseIn(ECHO_PIN, HIGH);\n  long distance = duration * 0.034 / 2;\n  return distance;\n}",
      "language": "arduino",
      "topic": "Arduino 感測器與致動器",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["感測器", "超音波", "距離測量", "HC-SR04", "原子式"]
      },
      "documentation": "# 超音波感測器 (HC-SR04)\n\n## 功能說明\nHC-SR04 是一款常用的超音波距離感測器，測量範圍 2-400cm，精度約 3mm。\n\n## 工作原理\n1. **觸發訊號**: Trig 腳位發送 10μs 高電位脈衝\n2. **超音波發射**: 感測器發出 8 個 40kHz 超音波脈衝\n3. **回波接收**: Echo 腳位輸出高電位，持續時間等於超音波往返時間\n4. **距離計算**: 距離 = (時間 × 音速) / 2\n\n## 接線說明\n```\nHC-SR04    Arduino Uno\nVCC     →  5V\nGND     →  GND\nTrig    →  Pin 7\nEcho    →  Pin 8\n```\n\n## 距離計算公式\n```cpp\n// 音速約 343 m/s = 0.0343 cm/μs\n// 往返距離除以 2\ndistance_cm = duration_μs * 0.0343 / 2;\n// 簡化為:\ndistance_cm = duration_μs * 0.034 / 2;\n```\n\n## 完整範例\n```cpp\n#define TRIG_PIN 7\n#define ECHO_PIN 8\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(TRIG_PIN, OUTPUT);\n  pinMode(ECHO_PIN, INPUT);\n}\n\nvoid loop() {\n  long distance = measureDistance();\n  \n  if (distance > 0 && distance < 400) {\n    Serial.print(\"距離: \");\n    Serial.print(distance);\n    Serial.println(\" cm\");\n  } else {\n    Serial.println(\"測量超出範圍\");\n  }\n  \n  delay(100);\n}\n\nlong measureDistance() {\n  // 清除觸發腳位\n  digitalWrite(TRIG_PIN, LOW);\n  delayMicroseconds(2);\n  \n  // 發送觸發脈衝\n  digitalWrite(TRIG_PIN, HIGH);\n  delayMicroseconds(10);\n  digitalWrite(TRIG_PIN, LOW);\n  \n  // 測量回波時間\n  long duration = pulseIn(ECHO_PIN, HIGH, 30000);\n  \n  // 計算距離\n  long distance = duration * 0.034 / 2;\n  \n  return distance;\n}\n```\n\n## 應用場景\n- **避障機器人** - 偵測前方障礙物\n- **水位監測** - 測量水箱液位\n- **停車感測** - 車輛倒車雷達\n- **自動門** - 人員接近偵測\n- **垃圾桶** - 滿溢警示系統\n\n## 注意事項\n- 測量範圍：2-400cm\n- 測量角度：約 15 度\n- 避免測量軟質或斜面物體\n- 溫度會影響音速，可加入溫度補償\n- 連續測量間隔建議大於 60ms"
    },
    {
      "id": "arduino-servo-motor",
      "title": "伺服馬達控制",
      "description": "SG90 伺服馬達角度控制",
      "code": "#include <Servo.h>\n\nServo myServo;\n\nvoid setup() {\n  myServo.attach(9);  // 連接到 Pin 9\n  myServo.write(90);  // 設定到中間位置\n}\n\nvoid loop() {\n  // 掃描動作\n  for (int angle = 0; angle <= 180; angle++) {\n    myServo.write(angle);\n    delay(15);\n  }\n  \n  for (int angle = 180; angle >= 0; angle--) {\n    myServo.write(angle);\n    delay(15);\n  }\n}",
      "language": "arduino",
      "topic": "Arduino 感測器與致動器",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["致動器", "伺服馬達", "角度控制", "SG90", "原子式"]
      },
      "documentation": "# 伺服馬達控制 (SG90)\n\n## 功能說明\n伺服馬達可以精確控制軸的角度位置，常用於機器人關節、雲台控制等應用。\n\n## 工作原理\n伺服馬達內建控制電路，透過 PWM 訊號控制角度：\n- **1.0ms 脈寬**: 0 度\n- **1.5ms 脈寬**: 90 度 (中間位置)\n- **2.0ms 脈寬**: 180 度\n- **訊號週期**: 20ms (50Hz)\n\n## 接線說明\n```\nSG90 伺服馬達    Arduino Uno\n紅線 (VCC)   →  5V\n棕線 (GND)   →  GND\n橙線 (Signal) →  Pin 9 (PWM)\n```\n\n## 基本控制\n```cpp\n#include <Servo.h>\n\nServo servo;\n\nvoid setup() {\n  servo.attach(9);    // 指定控制腳位\n  servo.write(90);    // 設定角度 (0-180 度)\n}\n\nvoid loop() {\n  servo.write(0);     // 轉到 0 度\n  delay(1000);\n  servo.write(180);   // 轉到 180 度\n  delay(1000);\n}\n```\n\n## 平滑控制\n```cpp\nvoid moveServo(int targetAngle, int currentAngle) {\n  int step = (targetAngle > currentAngle) ? 1 : -1;\n  \n  for (int angle = currentAngle; angle != targetAngle; angle += step) {\n    servo.write(angle);\n    delay(20);  // 控制轉動速度\n  }\n}\n```\n\n## 多伺服馬達控制\n```cpp\n#include <Servo.h>\n\nServo servo1, servo2;\n\nvoid setup() {\n  servo1.attach(9);\n  servo2.attach(10);\n}\n\nvoid loop() {\n  // 同步控制兩個伺服馬達\n  for (int angle = 0; angle <= 180; angle += 5) {\n    servo1.write(angle);\n    servo2.write(180 - angle);  // 反向運動\n    delay(50);\n  }\n}\n```\n\n## 應用場景\n- **機器人手臂** - 關節角度控制\n- **攝影雲台** - 水平/垂直轉動\n- **自動門鎖** - 門栓控制\n- **太陽能板** - 追蹤太陽角度\n- **模型飛機** - 舵機控制\n\n## 技術規格 (SG90)\n- **工作電壓**: 4.8V - 6V\n- **轉動角度**: 180 度\n- **轉動速度**: 0.1s/60° (4.8V)\n- **扭力**: 1.8kg/cm (4.8V)\n- **控制脈寬**: 1ms - 2ms\n- **重量**: 9g\n\n## 注意事項\n- 避免在伺服馬達卡住時持續供電\n- 大扭力應用建議使用外部電源\n- 控制訊號頻率維持在 50Hz\n- 過快的角度變化可能造成抖動\n- 多個伺服馬達會增加電流需求"
    },
    {
      "id": "arduino-dht-sensor",
      "title": "溫濕度感測器",
      "description": "DHT11/DHT22 溫濕度測量",
      "code": "#include <DHT.h>\n\n#define DHT_PIN 2\n#define DHT_TYPE DHT22\n\nDHT dht(DHT_PIN, DHT_TYPE);\n\nvoid setup() {\n  Serial.begin(9600);\n  dht.begin();\n  Serial.println(\"DHT22 感測器初始化完成\");\n}\n\nvoid loop() {\n  float humidity = dht.readHumidity();\n  float temperature = dht.readTemperature();\n  \n  if (isnan(humidity) || isnan(temperature)) {\n    Serial.println(\"讀取感測器失敗！\");\n    return;\n  }\n  \n  Serial.print(\"濕度: \");\n  Serial.print(humidity);\n  Serial.print(\"%  溫度: \");\n  Serial.print(temperature);\n  Serial.println(\"°C\");\n  \n  delay(2000);\n}",
      "language": "arduino",
      "topic": "Arduino 感測器與致動器",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["感測器", "溫度", "濕度", "DHT11", "DHT22", "原子式"]
      },
      "documentation": "# 溫濕度感測器 (DHT11/DHT22)\n\n## 功能說明\nDHT 系列是常用的數位溫濕度感測器，提供校準過的數位訊號輸出。\n\n## 型號比較\n| 特性 | DHT11 | DHT22 (AM2302) |\n|------|-------|----------------|\n| 溫度範圍 | 0-50°C | -40-80°C |\n| 溫度精度 | ±2°C | ±0.5°C |\n| 濕度範圍 | 20-90% | 0-100% |\n| 濕度精度 | ±5% | ±2-5% |\n| 取樣頻率 | 1Hz | 0.5Hz |\n| 價格 | 較便宜 | 較貴但更精確 |\n\n## 接線說明\n```\nDHT11/DHT22    Arduino Uno\nVCC         →  3.3V 或 5V\nGND         →  GND\nDATA        →  Pin 2 (數位腳位)\n```\n\n## 安裝函式庫\n1. 開啟 Arduino IDE\n2. 工具 → 管理程式庫\n3. 搜尋 \"DHT sensor library\"\n4. 安裝 Adafruit DHT sensor library\n5. 同時安裝 Adafruit Unified Sensor library\n\n## 基本使用\n```cpp\n#include <DHT.h>\n\n#define DHT_PIN 2\n#define DHT_TYPE DHT22  // 或 DHT11\n\nDHT dht(DHT_PIN, DHT_TYPE);\n\nvoid setup() {\n  Serial.begin(9600);\n  dht.begin();\n}\n\nvoid loop() {\n  float h = dht.readHumidity();\n  float t = dht.readTemperature();\n  float f = dht.readTemperature(true); // 華氏溫度\n  \n  // 檢查讀取是否成功\n  if (isnan(h) || isnan(t) || isnan(f)) {\n    Serial.println(\"讀取 DHT 感測器失敗！\");\n    return;\n  }\n  \n  // 計算熱指數 (攝氏)\n  float hic = dht.computeHeatIndex(t, h, false);\n  \n  Serial.print(\"濕度: \");\n  Serial.print(h);\n  Serial.print(\"%  溫度: \");\n  Serial.print(t);\n  Serial.print(\"°C  熱指數: \");\n  Serial.print(hic);\n  Serial.println(\"°C\");\n  \n  delay(2000);\n}\n```\n\n## 錯誤處理\n```cpp\nvoid readDHTSensor() {\n  float humidity = dht.readHumidity();\n  float temperature = dht.readTemperature();\n  \n  // 檢查數值是否有效\n  if (isnan(humidity)) {\n    Serial.println(\"濕度讀取錯誤\");\n    return;\n  }\n  \n  if (isnan(temperature)) {\n    Serial.println(\"溫度讀取錯誤\");\n    return;\n  }\n  \n  // 範圍檢查\n  if (humidity < 0 || humidity > 100) {\n    Serial.println(\"濕度值超出範圍\");\n    return;\n  }\n  \n  if (temperature < -40 || temperature > 80) {\n    Serial.println(\"溫度值超出範圍\");\n    return;\n  }\n  \n  // 數值正常，進行處理\n  processData(temperature, humidity);\n}\n```\n\n## 應用場景\n- **環境監測** - 室內空氣品質監控\n- **溫室控制** - 植物生長環境管理\n- **氣象站** - 本地天氣數據收集\n- **舒適度監測** - 辦公環境最佳化\n- **食品保存** - 倉儲環境監控\n\n## 注意事項\n- DHT22 需要 2 秒的取樣間隔\n- 感測器啟動需要 1-2 秒穩定時間\n- 避免將感測器放在熱源或風口附近\n- 長期使用建議定期校準\n- 電源電壓不穩定會影響讀數準確性"
    },
    {
      "id": "arduino-pir-sensor",
      "title": "PIR 人體感測器",
      "description": "HC-SR501 人體紅外線動作偵測",
      "code": "#define PIR_PIN 2\n#define LED_PIN 13\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(PIR_PIN, INPUT);\n  pinMode(LED_PIN, OUTPUT);\n  \n  Serial.println(\"PIR 感測器預熱中...\");\n  delay(30000);  // 預熱 30 秒\n  Serial.println(\"PIR 感測器準備就緒\");\n}\n\nvoid loop() {\n  int motionDetected = digitalRead(PIR_PIN);\n  \n  if (motionDetected == HIGH) {\n    digitalWrite(LED_PIN, HIGH);\n    Serial.println(\"偵測到動作！\");\n    delay(1000);\n  } else {\n    digitalWrite(LED_PIN, LOW);\n    Serial.println(\"無動作\");\n  }\n  \n  delay(500);\n}",
      "language": "arduino",
      "topic": "Arduino 感測器與致動器",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["感測器", "PIR", "動作偵測", "人體感測", "原子式"]
      },
      "documentation": "# PIR 人體感測器 (HC-SR501)\n\n## 功能說明\nPIR (Passive Infrared) 感測器可偵測人體或動物發出的紅外線，用於動作偵測和安全系統。\n\n## 工作原理\n- **被動式偵測**: 不發射紅外線，只接收\n- **溫度變化**: 偵測視野內的溫度變化\n- **菲涅爾透鏡**: 擴大偵測範圍和靈敏度\n- **數位輸出**: HIGH (偵測到) / LOW (無偵測)\n\n## 接線說明\n```\nHC-SR501      Arduino Uno\nVCC        →  5V\nGND        →  GND\nOUT        →  Pin 2 (數位腳位)\n```\n\n## 調節參數\nHC-SR501 模組有兩個可調電位器：\n\n### 靈敏度調節 (Sensitivity)\n- **順時針**: 增加偵測距離 (最遠約 7 公尺)\n- **逆時針**: 減少偵測距離 (最近約 3 公尺)\n\n### 延遲時間調節 (Time Delay)\n- **順時針**: 增加觸發後的高電位持續時間 (最長約 200 秒)\n- **逆時針**: 減少高電位持續時間 (最短約 5 秒)\n\n## 觸發模式\n模組背面的跳線可選擇觸發模式：\n- **H (重複觸發)**: 持續偵測時輸出持續為 HIGH\n- **L (單次觸發)**: 偵測後輸出 HIGH 一段時間後自動變 LOW\n\n## 基本使用\n```cpp\n#define PIR_PIN 2\n#define BUZZER_PIN 8\n\nboolean motionState = false;\nboolean lastMotionState = false;\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(PIR_PIN, INPUT);\n  pinMode(BUZZER_PIN, OUTPUT);\n  \n  // PIR 感測器預熱\n  Serial.println(\"PIR 預熱中，請勿移動...\");\n  delay(30000);\n  Serial.println(\"PIR 準備完成\");\n}\n\nvoid loop() {\n  motionState = digitalRead(PIR_PIN);\n  \n  // 偵測狀態改變\n  if (motionState != lastMotionState) {\n    if (motionState == HIGH) {\n      Serial.println(\"動作開始！\");\n      digitalWrite(BUZZER_PIN, HIGH);\n    } else {\n      Serial.println(\"動作結束\");\n      digitalWrite(BUZZER_PIN, LOW);\n    }\n    lastMotionState = motionState;\n  }\n  \n  delay(100);\n}\n```\n\n## 進階應用 - 安全系統\n```cpp\n#define PIR_PIN 2\n#define LED_PIN 13\n#define BUZZER_PIN 8\n#define ARM_BUTTON 3\n\nboolean systemArmed = false;\nboolean alarmTriggered = false;\nunsigned long alarmStartTime = 0;\nconst unsigned long ALARM_DURATION = 10000; // 10 秒警報\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(PIR_PIN, INPUT);\n  pinMode(LED_PIN, OUTPUT);\n  pinMode(BUZZER_PIN, OUTPUT);\n  pinMode(ARM_BUTTON, INPUT_PULLUP);\n  \n  Serial.println(\"安全系統初始化...\");\n  delay(30000); // PIR 預熱\n  Serial.println(\"系統就緒\");\n}\n\nvoid loop() {\n  // 檢查佈防/撤防按鈕\n  if (digitalRead(ARM_BUTTON) == LOW) {\n    systemArmed = !systemArmed;\n    Serial.println(systemArmed ? \"系統佈防\" : \"系統撤防\");\n    digitalWrite(LED_PIN, systemArmed);\n    delay(500); // 防止按鈕彈跳\n  }\n  \n  // 在佈防狀態下檢查動作\n  if (systemArmed && digitalRead(PIR_PIN) == HIGH && !alarmTriggered) {\n    alarmTriggered = true;\n    alarmStartTime = millis();\n    Serial.println(\"警報觸發！\");\n  }\n  \n  // 處理警報\n  if (alarmTriggered) {\n    unsigned long currentTime = millis();\n    if (currentTime - alarmStartTime < ALARM_DURATION) {\n      // 閃爍警報\n      digitalWrite(BUZZER_PIN, (currentTime / 200) % 2);\n      digitalWrite(LED_PIN, (currentTime / 200) % 2);\n    } else {\n      // 警報結束\n      alarmTriggered = false;\n      digitalWrite(BUZZER_PIN, LOW);\n      digitalWrite(LED_PIN, systemArmed);\n      Serial.println(\"警報結束\");\n    }\n  }\n  \n  delay(50);\n}\n```\n\n## 應用場景\n- **自動照明** - 人員接近時開燈\n- **安全監控** - 入侵偵測警報\n- **節能控制** - 無人時關閉設備\n- **人流統計** - 計算通過人數\n- **智慧家居** - 場景自動切換\n\n## 技術規格\n- **工作電壓**: 4.5V - 20V\n- **工作電流**: <50μA\n- **偵測角度**: 約 120 度\n- **偵測距離**: 3-7 公尺\n- **延遲時間**: 5-200 秒可調\n- **預熱時間**: 10-60 秒\n\n## 注意事項\n- 首次使用需預熱 10-60 秒\n- 避免安裝在風口或熱源附近\n- 感測器方向會影響偵測範圍\n- 玻璃會阻擋紅外線偵測\n- 溫度接近體溫時靈敏度會降低"
    },
    {
      "id": "arduino-buzzer",
      "title": "蜂鳴器控制",
      "description": "有源/無源蜂鳴器聲音控制",
      "code": "#define BUZZER_PIN 8\n\nvoid setup() {\n  pinMode(BUZZER_PIN, OUTPUT);\n}\n\nvoid loop() {\n  // 簡單嗶聲\n  digitalWrite(BUZZER_PIN, HIGH);\n  delay(500);\n  digitalWrite(BUZZER_PIN, LOW);\n  delay(500);\n  \n  // 音調控制 (無源蜂鳴器)\n  tone(BUZZER_PIN, 1000, 500);  // 1kHz, 0.5秒\n  delay(1000);\n  tone(BUZZER_PIN, 2000, 300);  // 2kHz, 0.3秒\n  delay(1000);\n}",
      "language": "arduino",
      "topic": "Arduino 感測器與致動器",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["致動器", "蜂鳴器", "聲音", "警報", "tone", "原子式"]
      },
      "documentation": "# 蜂鳴器控制\n\n## 功能說明\n蜂鳴器是常用的聲音輸出元件，可產生警報聲、提示音或簡單的音樂。\n\n## 蜂鳴器類型\n\n### 有源蜂鳴器 (Active Buzzer)\n- **內建振盪電路**: 通電即發聲\n- **固定頻率**: 無法改變音調\n- **使用方式**: digitalWrite() 控制開關\n- **優點**: 使用簡單，音量較大\n- **識別**: 背面有小電路板\n\n### 無源蜂鳴器 (Passive Buzzer)\n- **需要驅動訊號**: 需要方波訊號驅動\n- **可變頻率**: 可產生不同音調\n- **使用方式**: tone() 函數或 PWM\n- **優點**: 可演奏音樂，頻率可控\n- **識別**: 背面是黑色樹脂\n\n## 接線說明\n```\n蜂鳴器        Arduino Uno\n正極 (+)   →  Pin 8 (數位腳位)\n負極 (-)   →  GND\n```\n\n## 有源蜂鳴器控制\n```cpp\n#define BUZZER_PIN 8\n\nvoid setup() {\n  pinMode(BUZZER_PIN, OUTPUT);\n}\n\nvoid loop() {\n  digitalWrite(BUZZER_PIN, HIGH);  // 開啟\n  delay(1000);\n  digitalWrite(BUZZER_PIN, LOW);   // 關閉\n  delay(1000);\n}\n```\n\n## 無源蜂鳴器 - tone() 函數\n```cpp\n#define BUZZER_PIN 8\n\nvoid setup() {\n  // 無需設定 pinMode\n}\n\nvoid loop() {\n  tone(BUZZER_PIN, 440, 1000);    // 440Hz, 1秒\n  delay(1500);\n  tone(BUZZER_PIN, 880, 500);     // 880Hz, 0.5秒\n  delay(1000);\n  noTone(BUZZER_PIN);             // 停止發聲\n  delay(1000);\n}\n```\n\n## 音調定義\n```cpp\n// 音符頻率定義 (Hz)\n#define NOTE_C4  262\n#define NOTE_D4  294\n#define NOTE_E4  330\n#define NOTE_F4  349\n#define NOTE_G4  392\n#define NOTE_A4  440\n#define NOTE_B4  494\n#define NOTE_C5  523\n\nint melody[] = {\n  NOTE_C4, NOTE_D4, NOTE_E4, NOTE_F4,\n  NOTE_G4, NOTE_A4, NOTE_B4, NOTE_C5\n};\n\nint noteDuration = 500;  // 每個音符持續時間\n\nvoid playMelody() {\n  for (int i = 0; i < 8; i++) {\n    tone(BUZZER_PIN, melody[i], noteDuration);\n    delay(noteDuration * 1.3);  // 音符間隔\n  }\n}\n```\n\n## 警報音效\n```cpp\nvoid alarmSound() {\n  for (int i = 0; i < 10; i++) {\n    tone(BUZZER_PIN, 1000, 200);\n    delay(200);\n    tone(BUZZER_PIN, 500, 200);\n    delay(200);\n  }\n}\n\nvoid sirenSound() {\n  for (int freq = 200; freq < 1000; freq += 50) {\n    tone(BUZZER_PIN, freq, 50);\n    delay(50);\n  }\n  for (int freq = 1000; freq > 200; freq -= 50) {\n    tone(BUZZER_PIN, freq, 50);\n    delay(50);\n  }\n}\n\nvoid beepBeep() {\n  for (int i = 0; i < 3; i++) {\n    tone(BUZZER_PIN, 2000, 100);\n    delay(150);\n    noTone(BUZZER_PIN);\n    delay(100);\n  }\n}\n```\n\n## 音樂播放器\n```cpp\n#define BUZZER_PIN 8\n\n// 生日快樂歌旋律\nint birthdayMelody[] = {\n  NOTE_C4, NOTE_C4, NOTE_D4, NOTE_C4, NOTE_F4, NOTE_E4,\n  NOTE_C4, NOTE_C4, NOTE_D4, NOTE_C4, NOTE_G4, NOTE_F4,\n  NOTE_C4, NOTE_C4, NOTE_C5, NOTE_A4, NOTE_F4, NOTE_E4, NOTE_D4,\n  NOTE_B4, NOTE_B4, NOTE_A4, NOTE_F4, NOTE_G4, NOTE_F4\n};\n\nint noteDurations[] = {\n  4, 8, 4, 4, 4, 2,\n  4, 8, 4, 4, 4, 2,\n  4, 8, 4, 4, 4, 4, 4,\n  4, 8, 4, 4, 4, 2\n};\n\nvoid playBirthday() {\n  for (int i = 0; i < 25; i++) {\n    int noteDuration = 1000 / noteDurations[i];\n    tone(BUZZER_PIN, birthdayMelody[i], noteDuration);\n    \n    int pauseBetweenNotes = noteDuration * 1.30;\n    delay(pauseBetweenNotes);\n    noTone(BUZZER_PIN);\n  }\n}\n```\n\n## 應用場景\n- **警報系統** - 入侵、火災、異常警報\n- **提示音** - 按鈕確認、操作回饋\n- **定時器** - 倒數計時完成提醒\n- **遊戲音效** - 得分、失敗音效\n- **音樂盒** - 簡單旋律播放\n\n## 注意事項\n- 區分有源和無源蜂鳴器使用方式\n- tone() 函數會佔用 Timer2，影響 PWM 腳位 3 和 11\n- 同時只能產生一個音調\n- 避免長時間高音量使用，保護聽力\n- 某些蜂鳴器需要串聯電阻保護\n- 多個 tone() 呼叫之間加入適當延遲"
    },
    {
      "id": "arduino-ldr-sensor",
      "title": "光敏電阻感測器",
      "description": "LDR 光線感測和自動控制",
      "code": "#define LDR_PIN A0\n#define LED_PIN 13\n#define THRESHOLD 500\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(LED_PIN, OUTPUT);\n}\n\nvoid loop() {\n  int lightValue = analogRead(LDR_PIN);\n  \n  Serial.print(\"光線強度: \");\n  Serial.println(lightValue);\n  \n  // 自動開關燈\n  if (lightValue < THRESHOLD) {\n    digitalWrite(LED_PIN, HIGH);  // 暗處開燈\n    Serial.println(\"LED 開啟\");\n  } else {\n    digitalWrite(LED_PIN, LOW);   // 亮處關燈\n    Serial.println(\"LED 關閉\");\n  }\n  \n  delay(500);\n}",
      "language": "arduino",
      "topic": "Arduino 感測器與致動器",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["感測器", "光敏電阻", "LDR", "光線感測", "自動控制", "原子式"]
      },
      "documentation": "# 光敏電阻感測器 (LDR)\n\n## 功能說明\nLDR (Light Dependent Resistor) 是一種阻值隨光線強度變化的電阻，常用於自動照明和光線偵測。\n\n## 工作原理\n- **光敏材料**: 硫化鎘 (CdS) 製成\n- **阻值變化**: 光線越強，阻值越小\n- **典型範圍**: 暗處 1MΩ，亮處 1kΩ\n- **回應時間**: 毫秒級快速反應\n\n## 電路連接\n```\n分壓電路接法：\n5V ─── 10kΩ 電阻 ─── LDR ─── GND\n                │\n              Pin A0\n```\n\n## 接線說明\n```\n光敏電阻模組     Arduino Uno\nVCC          →  5V\nGND          →  GND\nAO (類比)    →  Pin A0\n```\n\n## 基本讀取\n```cpp\n#define LDR_PIN A0\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int lightValue = analogRead(LDR_PIN);\n  \n  // 轉換為電壓\n  float voltage = lightValue * (5.0 / 1023.0);\n  \n  Serial.print(\"光線數值: \");\n  Serial.print(lightValue);\n  Serial.print(\", 電壓: \");\n  Serial.print(voltage);\n  Serial.println(\"V\");\n  \n  delay(500);\n}\n```\n\n## 自動照明系統\n```cpp\n#define LDR_PIN A0\n#define LED_PIN 9\n#define THRESHOLD_LOW 300   // 開燈門檻\n#define THRESHOLD_HIGH 700  // 關燈門檻\n\nboolean ledState = false;\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(LED_PIN, OUTPUT);\n}\n\nvoid loop() {\n  int lightValue = analogRead(LDR_PIN);\n  \n  // 遲滯比較避免閃爍\n  if (!ledState && lightValue < THRESHOLD_LOW) {\n    digitalWrite(LED_PIN, HIGH);\n    ledState = true;\n    Serial.println(\"燈光開啟\");\n  } else if (ledState && lightValue > THRESHOLD_HIGH) {\n    digitalWrite(LED_PIN, LOW);\n    ledState = false;\n    Serial.println(\"燈光關閉\");\n  }\n  \n  Serial.print(\"光線: \");\n  Serial.print(lightValue);\n  Serial.print(\", LED: \");\n  Serial.println(ledState ? \"ON\" : \"OFF\");\n  \n  delay(100);\n}\n```\n\n## PWM 調光控制\n```cpp\n#define LDR_PIN A0\n#define LED_PIN 9\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(LED_PIN, OUTPUT);\n}\n\nvoid loop() {\n  int lightValue = analogRead(LDR_PIN);\n  \n  // 反比調光：環境越暗，LED 越亮\n  int ledBrightness = map(lightValue, 0, 1023, 255, 0);\n  ledBrightness = constrain(ledBrightness, 0, 255);\n  \n  analogWrite(LED_PIN, ledBrightness);\n  \n  Serial.print(\"光線: \");\n  Serial.print(lightValue);\n  Serial.print(\", LED 亮度: \");\n  Serial.println(ledBrightness);\n  \n  delay(100);\n}\n```\n\n## 多段光線偵測\n```cpp\n#define LDR_PIN A0\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int lightValue = analogRead(LDR_PIN);\n  String lightLevel;\n  \n  if (lightValue < 200) {\n    lightLevel = \"很暗\";\n  } else if (lightValue < 400) {\n    lightLevel = \"昏暗\";\n  } else if (lightValue < 600) {\n    lightLevel = \"普通\";\n  } else if (lightValue < 800) {\n    lightLevel = \"明亮\";\n  } else {\n    lightLevel = \"非常亮\";\n  }\n  \n  Serial.print(\"光線強度: \");\n  Serial.print(lightValue);\n  Serial.print(\" - \");\n  Serial.println(lightLevel);\n  \n  delay(1000);\n}\n```\n\n## 校準和濾波\n```cpp\n#define LDR_PIN A0\n#define SAMPLES 10\n\nint calibrateMin = 1023;\nint calibrateMax = 0;\n\nvoid setup() {\n  Serial.begin(9600);\n  \n  // 校準程序\n  Serial.println(\"校準中...請改變光線條件\");\n  for (int i = 0; i < 100; i++) {\n    int reading = analogRead(LDR_PIN);\n    if (reading > calibrateMax) calibrateMax = reading;\n    if (reading < calibrateMin) calibrateMin = reading;\n    delay(100);\n  }\n  Serial.println(\"校準完成\");\n}\n\nvoid loop() {\n  // 多次取樣平均\n  long sum = 0;\n  for (int i = 0; i < SAMPLES; i++) {\n    sum += analogRead(LDR_PIN);\n    delay(10);\n  }\n  int lightValue = sum / SAMPLES;\n  \n  // 正規化到 0-100%\n  int normalizedValue = map(lightValue, calibrateMin, calibrateMax, 0, 100);\n  normalizedValue = constrain(normalizedValue, 0, 100);\n  \n  Serial.print(\"原始值: \");\n  Serial.print(lightValue);\n  Serial.print(\", 正規化: \");\n  Serial.print(normalizedValue);\n  Serial.println(\"%\");\n  \n  delay(500);\n}\n```\n\n## 應用場景\n- **自動照明** - 路燈、室內燈控制\n- **太陽能系統** - 日照強度監測\n- **安全系統** - 入侵偵測輔助\n- **攝影設備** - 自動曝光控制\n- **溫室管理** - 光照時間監控\n\n## 技術規格\n- **暗阻值**: 1MΩ - 10MΩ\n- **亮阻值**: 1kΩ - 10kΩ\n- **峰值波長**: 約 540nm (綠光)\n- **回應時間**: 上升 20ms，下降 30ms\n- **工作溫度**: -30°C 到 +70°C\n\n## 注意事項\n- 需要分壓電路才能連接 Arduino\n- 回應速度較慢，不適合快速變化偵測\n- 溫度會影響阻值，需要溫度補償\n- 老化會造成阻值漂移\n- 避免強光直射造成永久損壞"
    },
    {
      "id": "arduino-potentiometer",
      "title": "可變電阻器",
      "description": "旋鈕電位器輸入控制",
      "code": "#define POT_PIN A0\n#define LED_PIN 9\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(LED_PIN, OUTPUT);\n}\n\nvoid loop() {\n  int potValue = analogRead(POT_PIN);\n  \n  // 轉換為 PWM 值 (0-255)\n  int ledBrightness = map(potValue, 0, 1023, 0, 255);\n  \n  // 控制 LED 亮度\n  analogWrite(LED_PIN, ledBrightness);\n  \n  // 顯示數值\n  Serial.print(\"電位器: \");\n  Serial.print(potValue);\n  Serial.print(\", LED 亮度: \");\n  Serial.println(ledBrightness);\n  \n  delay(100);\n}",
      "language": "arduino",
      "topic": "Arduino 感測器與致動器",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["輸入", "可變電阻", "電位器", "類比控制", "原子式"]
      },
      "documentation": "# 可變電阻器 (電位器)\n\n## 功能說明\n電位器是一種可調節的電阻器，常用作音量控制、亮度調節等人機介面元件。\n\n## 工作原理\n- **三個接腳**: VCC、GND、輸出 (滑臂)\n- **阻值分配**: 滑臂位置決定輸出電壓\n- **線性變化**: 旋轉角度與電壓成正比\n- **即時回饋**: 立即反映位置變化\n\n## 接線說明\n```\n電位器        Arduino Uno\n左腳 (VCC)  →  5V\n中腳 (OUT)  →  Pin A0\n右腳 (GND)  →  GND\n```\n\n## 基本讀取\n```cpp\n#define POT_PIN A0\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int potValue = analogRead(POT_PIN);\n  \n  // 轉換為電壓\n  float voltage = potValue * (5.0 / 1023.0);\n  \n  // 轉換為百分比\n  int percentage = map(potValue, 0, 1023, 0, 100);\n  \n  Serial.print(\"數值: \");\n  Serial.print(potValue);\n  Serial.print(\", 電壓: \");\n  Serial.print(voltage, 2);\n  Serial.print(\"V, 百分比: \");\n  Serial.print(percentage);\n  Serial.println(\"%\");\n  \n  delay(500);\n}\n```\n\n## LED 亮度控制\n```cpp\n#define POT_PIN A0\n#define LED_PIN 9\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(LED_PIN, OUTPUT);\n}\n\nvoid loop() {\n  int potValue = analogRead(POT_PIN);\n  int brightness = map(potValue, 0, 1023, 0, 255);\n  \n  analogWrite(LED_PIN, brightness);\n  \n  Serial.print(\"電位器: \");\n  Serial.print(potValue);\n  Serial.print(\", 亮度: \");\n  Serial.println(brightness);\n  \n  delay(50);\n}\n```\n\n## 伺服馬達角度控制\n```cpp\n#include <Servo.h>\n\n#define POT_PIN A0\n#define SERVO_PIN 9\n\nServo myServo;\n\nvoid setup() {\n  Serial.begin(9600);\n  myServo.attach(SERVO_PIN);\n}\n\nvoid loop() {\n  int potValue = analogRead(POT_PIN);\n  \n  // 轉換為伺服馬達角度 (0-180 度)\n  int servoAngle = map(potValue, 0, 1023, 0, 180);\n  \n  myServo.write(servoAngle);\n  \n  Serial.print(\"電位器: \");\n  Serial.print(potValue);\n  Serial.print(\", 角度: \");\n  Serial.println(servoAngle);\n  \n  delay(15);\n}\n```\n\n## 音調頻率控制\n```cpp\n#define POT_PIN A0\n#define BUZZER_PIN 8\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int potValue = analogRead(POT_PIN);\n  \n  // 轉換為頻率 (200-2000 Hz)\n  int frequency = map(potValue, 0, 1023, 200, 2000);\n  \n  if (potValue > 10) {  // 避免極低頻率\n    tone(BUZZER_PIN, frequency);\n  } else {\n    noTone(BUZZER_PIN);\n  }\n  \n  Serial.print(\"電位器: \");\n  Serial.print(potValue);\n  Serial.print(\", 頻率: \");\n  Serial.println(frequency);\n  \n  delay(100);\n}\n```\n\n## 多段選擇器\n```cpp\n#define POT_PIN A0\n#define LED_PINS {13, 12, 11, 10, 9}\n\nint ledPins[] = LED_PINS;\nint numLeds = sizeof(ledPins) / sizeof(ledPins[0]);\n\nvoid setup() {\n  Serial.begin(9600);\n  for (int i = 0; i < numLeds; i++) {\n    pinMode(ledPins[i], OUTPUT);\n  }\n}\n\nvoid loop() {\n  int potValue = analogRead(POT_PIN);\n  \n  // 轉換為段數 (0 到 numLeds-1)\n  int selectedLed = map(potValue, 0, 1023, 0, numLeds);\n  selectedLed = constrain(selectedLed, 0, numLeds - 1);\n  \n  // 點亮對應 LED\n  for (int i = 0; i < numLeds; i++) {\n    digitalWrite(ledPins[i], i == selectedLed);\n  }\n  \n  Serial.print(\"電位器: \");\n  Serial.print(potValue);\n  Serial.print(\", 選擇 LED: \");\n  Serial.println(selectedLed);\n  \n  delay(100);\n}\n```\n\n## 數位濾波\n```cpp\n#define POT_PIN A0\n#define FILTER_SIZE 10\n\nint readings[FILTER_SIZE];\nint readIndex = 0;\nlong total = 0;\nint smoothedValue = 0;\n\nvoid setup() {\n  Serial.begin(9600);\n  \n  // 初始化陣列\n  for (int i = 0; i < FILTER_SIZE; i++) {\n    readings[i] = 0;\n  }\n}\n\nvoid loop() {\n  // 移除舊值\n  total -= readings[readIndex];\n  \n  // 讀取新值\n  readings[readIndex] = analogRead(POT_PIN);\n  \n  // 加入新值\n  total += readings[readIndex];\n  \n  // 移動索引\n  readIndex = (readIndex + 1) % FILTER_SIZE;\n  \n  // 計算平均值\n  smoothedValue = total / FILTER_SIZE;\n  \n  Serial.print(\"原始值: \");\n  Serial.print(readings[(readIndex - 1 + FILTER_SIZE) % FILTER_SIZE]);\n  Serial.print(\", 平滑值: \");\n  Serial.println(smoothedValue);\n  \n  delay(50);\n}\n```\n\n## 應用場景\n- **音量控制** - 調節音響設備音量\n- **亮度調節** - LED 燈具亮度控制\n- **馬達速度** - 直流馬達轉速調節\n- **參數設定** - 系統參數調整介面\n- **遊戲控制** - 類比遊戲手把\n\n## 技術規格\n- **阻值範圍**: 1kΩ - 1MΩ (常見 10kΩ)\n- **線性度**: ±1% - ±5%\n- **機械角度**: 270° - 300°\n- **壽命**: 10,000 - 100,000 次旋轉\n- **功率**: 0.25W - 2W\n\n## 注意事項\n- 選擇合適阻值避免負載過重\n- 機械磨損會影響線性度\n- 灰塵會造成接觸不良\n- 溫度變化會影響阻值\n- 避免超過額定功率燒毀"
    },
    {
      "id": "arduino-joystick",
      "title": "搖桿模組",
      "description": "雙軸搖桿 XY 座標輸入",
      "code": "#define JOYSTICK_X A0\n#define JOYSTICK_Y A1\n#define JOYSTICK_SW 2\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(JOYSTICK_SW, INPUT_PULLUP);\n}\n\nvoid loop() {\n  int xValue = analogRead(JOYSTICK_X);\n  int yValue = analogRead(JOYSTICK_Y);\n  int swValue = digitalRead(JOYSTICK_SW);\n  \n  // 轉換為方向\n  String direction = getDirection(xValue, yValue);\n  \n  Serial.print(\"X: \");\n  Serial.print(xValue);\n  Serial.print(\", Y: \");\n  Serial.print(yValue);\n  Serial.print(\", 方向: \");\n  Serial.print(direction);\n  Serial.print(\", 按鈕: \");\n  Serial.println(swValue == LOW ? \"按下\" : \"釋放\");\n  \n  delay(200);\n}\n\nString getDirection(int x, int y) {\n  if (x < 300) return \"左\";\n  if (x > 700) return \"右\";\n  if (y < 300) return \"下\";\n  if (y > 700) return \"上\";\n  return \"中心\";\n}",
      "language": "arduino",
      "topic": "Arduino 感測器與致動器",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["輸入", "搖桿", "XY座標", "類比輸入", "原子式"]
      },
      "documentation": "# 搖桿模組\n\n## 功能說明\n搖桿模組提供 XY 兩軸的類比輸入和一個按鈕開關，常用於遊戲控制和機器人導航。\n\n## 硬體結構\n- **X 軸電位器**: 水平方向位置\n- **Y 軸電位器**: 垂直方向位置\n- **按鈕開關**: 向下按壓觸發\n- **中心復位**: 釋放後自動回到中心\n\n## 接線說明\n```\n搖桿模組      Arduino Uno\nVCC        →  5V\nGND        →  GND\nVRx (X軸)  →  Pin A0\nVRy (Y軸)  →  Pin A1\nSW (按鈕)  →  Pin 2\n```\n\n## 基本讀取\n```cpp\n#define JOYSTICK_X A0\n#define JOYSTICK_Y A1\n#define JOYSTICK_SW 2\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(JOYSTICK_SW, INPUT_PULLUP);\n}\n\nvoid loop() {\n  int xValue = analogRead(JOYSTICK_X);\n  int yValue = analogRead(JOYSTICK_Y);\n  boolean buttonPressed = digitalRead(JOYSTICK_SW) == LOW;\n  \n  Serial.print(\"X: \");\n  Serial.print(xValue);\n  Serial.print(\", Y: \");\n  Serial.print(yValue);\n  Serial.print(\", 按鈕: \");\n  Serial.println(buttonPressed ? \"按下\" : \"釋放\");\n  \n  delay(100);\n}\n```\n\n## 方向判斷\n```cpp\n#define JOYSTICK_X A0\n#define JOYSTICK_Y A1\n#define CENTER_THRESHOLD 100\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int xValue = analogRead(JOYSTICK_X);\n  int yValue = analogRead(JOYSTICK_Y);\n  \n  // 校準中心位置 (通常約 512)\n  int xOffset = xValue - 512;\n  int yOffset = yValue - 512;\n  \n  String direction = \"\";\n  \n  // 判斷垂直方向\n  if (yOffset > CENTER_THRESHOLD) {\n    direction += \"上\";\n  } else if (yOffset < -CENTER_THRESHOLD) {\n    direction += \"下\";\n  }\n  \n  // 判斷水平方向\n  if (xOffset > CENTER_THRESHOLD) {\n    direction += \"右\";\n  } else if (xOffset < -CENTER_THRESHOLD) {\n    direction += \"左\";\n  }\n  \n  if (direction == \"\") {\n    direction = \"中心\";\n  }\n  \n  Serial.print(\"X: \");\n  Serial.print(xValue);\n  Serial.print(\", Y: \");\n  Serial.print(yValue);\n  Serial.print(\", 方向: \");\n  Serial.println(direction);\n  \n  delay(200);\n}\n```\n\n## LED 控制\n```cpp\n#define JOYSTICK_X A0\n#define JOYSTICK_Y A1\n#define LED_UP 8\n#define LED_DOWN 9\n#define LED_LEFT 10\n#define LED_RIGHT 11\n#define LED_CENTER 12\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(LED_UP, OUTPUT);\n  pinMode(LED_DOWN, OUTPUT);\n  pinMode(LED_LEFT, OUTPUT);\n  pinMode(LED_RIGHT, OUTPUT);\n  pinMode(LED_CENTER, OUTPUT);\n}\n\nvoid loop() {\n  int xValue = analogRead(JOYSTICK_X);\n  int yValue = analogRead(JOYSTICK_Y);\n  \n  // 關閉所有 LED\n  digitalWrite(LED_UP, LOW);\n  digitalWrite(LED_DOWN, LOW);\n  digitalWrite(LED_LEFT, LOW);\n  digitalWrite(LED_RIGHT, LOW);\n  digitalWrite(LED_CENTER, LOW);\n  \n  // 根據方向點亮對應 LED\n  if (yValue > 700) {\n    digitalWrite(LED_UP, HIGH);\n  } else if (yValue < 300) {\n    digitalWrite(LED_DOWN, HIGH);\n  } else if (xValue > 700) {\n    digitalWrite(LED_RIGHT, HIGH);\n  } else if (xValue < 300) {\n    digitalWrite(LED_LEFT, HIGH);\n  } else {\n    digitalWrite(LED_CENTER, HIGH);\n  }\n  \n  delay(100);\n}\n```\n\n## 伺服馬達控制\n```cpp\n#include <Servo.h>\n\n#define JOYSTICK_X A0\n#define JOYSTICK_Y A1\n#define SERVO_X_PIN 9\n#define SERVO_Y_PIN 10\n\nServo servoX, servoY;\n\nvoid setup() {\n  Serial.begin(9600);\n  servoX.attach(SERVO_X_PIN);\n  servoY.attach(SERVO_Y_PIN);\n  \n  // 初始位置設為中心\n  servoX.write(90);\n  servoY.write(90);\n}\n\nvoid loop() {\n  int xValue = analogRead(JOYSTICK_X);\n  int yValue = analogRead(JOYSTICK_Y);\n  \n  // 轉換為伺服馬達角度 (0-180 度)\n  int servoXAngle = map(xValue, 0, 1023, 0, 180);\n  int servoYAngle = map(yValue, 0, 1023, 0, 180);\n  \n  servoX.write(servoXAngle);\n  servoY.write(servoYAngle);\n  \n  Serial.print(\"X角度: \");\n  Serial.print(servoXAngle);\n  Serial.print(\", Y角度: \");\n  Serial.println(servoYAngle);\n  \n  delay(20);\n}\n```\n\n## 遊戲控制器\n```cpp\n#define JOYSTICK_X A0\n#define JOYSTICK_Y A1\n#define JOYSTICK_SW 2\n\nstruct Position {\n  int x;\n  int y;\n};\n\nPosition playerPos = {5, 5};  // 玩家位置\nboolean buttonState = false;\nboolean lastButtonState = false;\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(JOYSTICK_SW, INPUT_PULLUP);\n  \n  Serial.println(\"遊戲控制器啟動\");\n  printGameState();\n}\n\nvoid loop() {\n  int xValue = analogRead(JOYSTICK_X);\n  int yValue = analogRead(JOYSTICK_Y);\n  buttonState = digitalRead(JOYSTICK_SW) == LOW;\n  \n  // 移動控制 (防抖動)\n  static unsigned long lastMoveTime = 0;\n  if (millis() - lastMoveTime > 300) {\n    if (xValue < 300 && playerPos.x > 0) {\n      playerPos.x--;\n      lastMoveTime = millis();\n    } else if (xValue > 700 && playerPos.x < 9) {\n      playerPos.x++;\n      lastMoveTime = millis();\n    }\n    \n    if (yValue < 300 && playerPos.y > 0) {\n      playerPos.y--;\n      lastMoveTime = millis();\n    } else if (yValue > 700 && playerPos.y < 9) {\n      playerPos.y++;\n      lastMoveTime = millis();\n    }\n  }\n  \n  // 按鈕事件\n  if (buttonState && !lastButtonState) {\n    Serial.println(\"動作觸發！\");\n    printGameState();\n  }\n  \n  lastButtonState = buttonState;\n  delay(50);\n}\n\nvoid printGameState() {\n  Serial.print(\"玩家位置: (\");\n  Serial.print(playerPos.x);\n  Serial.print(\", \");\n  Serial.print(playerPos.y);\n  Serial.println(\")\");\n}\n```\n\n## 校準程序\n```cpp\n#define JOYSTICK_X A0\n#define JOYSTICK_Y A1\n\nstruct Calibration {\n  int xMin, xMax, xCenter;\n  int yMin, yMax, yCenter;\n};\n\nCalibration cal;\n\nvoid setup() {\n  Serial.begin(9600);\n  calibrateJoystick();\n}\n\nvoid calibrateJoystick() {\n  Serial.println(\"校準開始...\");\n  Serial.println(\"請將搖桿移動到各個極限位置\");\n  \n  // 初始化\n  cal.xMin = cal.yMin = 1023;\n  cal.xMax = cal.yMax = 0;\n  \n  // 校準 5 秒\n  unsigned long startTime = millis();\n  while (millis() - startTime < 5000) {\n    int x = analogRead(JOYSTICK_X);\n    int y = analogRead(JOYSTICK_Y);\n    \n    if (x < cal.xMin) cal.xMin = x;\n    if (x > cal.xMax) cal.xMax = x;\n    if (y < cal.yMin) cal.yMin = y;\n    if (y > cal.yMax) cal.yMax = y;\n    \n    delay(10);\n  }\n  \n  // 計算中心位置\n  cal.xCenter = (cal.xMin + cal.xMax) / 2;\n  cal.yCenter = (cal.yMin + cal.yMax) / 2;\n  \n  Serial.println(\"校準完成\");\n  Serial.print(\"X範圍: \");\n  Serial.print(cal.xMin);\n  Serial.print(\" - \");\n  Serial.println(cal.xMax);\n  Serial.print(\"Y範圍: \");\n  Serial.print(cal.yMin);\n  Serial.print(\" - \");\n  Serial.println(cal.yMax);\n}\n\nvoid loop() {\n  int x = analogRead(JOYSTICK_X);\n  int y = analogRead(JOYSTICK_Y);\n  \n  // 正規化到 -100 到 +100\n  int normalizedX = map(x, cal.xMin, cal.xMax, -100, 100);\n  int normalizedY = map(y, cal.yMin, cal.yMax, -100, 100);\n  \n  Serial.print(\"正規化 X: \");\n  Serial.print(normalizedX);\n  Serial.print(\", Y: \");\n  Serial.println(normalizedY);\n  \n  delay(200);\n}\n```\n\n## 應用場景\n- **遊戲控制** - 2D/3D 遊戲操控\n- **機器人遙控** - 無線遙控車\n- **攝影雲台** - 手動相機控制\n- **無人機** - 飛行方向控制\n- **工業控制** - 機械臂操作\n\n## 技術規格\n- **工作電壓**: 3.3V - 5V\n- **輸出範圍**: 0 - VCC\n- **中心位置**: VCC/2 (約 2.5V)\n- **機械角度**: 約 ±25°\n- **按鈕壽命**: >100,000 次\n\n## 注意事項\n- 中心位置可能不完全是 512，需要校準\n- 長期使用會有機械磨損\n- 溫度變化會影響中心位置\n- 按鈕需要防彈跳處理\n- 避免過度用力損壞機械結構"
    },
    {
      "id": "arduino-relay-control",
      "title": "繼電器控制",
      "description": "繼電器開關高功率設備",
      "code": "#define RELAY_PIN 7\n#define BUTTON_PIN 2\n\nboolean relayState = false;\nboolean lastButtonState = HIGH;\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(RELAY_PIN, OUTPUT);\n  pinMode(BUTTON_PIN, INPUT_PULLUP);\n  \n  digitalWrite(RELAY_PIN, LOW);  // 初始關閉\n  Serial.println(\"繼電器控制系統啟動\");\n}\n\nvoid loop() {\n  boolean buttonState = digitalRead(BUTTON_PIN);\n  \n  // 按鈕按下時切換繼電器狀態\n  if (buttonState == LOW && lastButtonState == HIGH) {\n    relayState = !relayState;\n    digitalWrite(RELAY_PIN, relayState);\n    \n    Serial.print(\"繼電器: \");\n    Serial.println(relayState ? \"開啟\" : \"關閉\");\n    \n    delay(50);  // 防彈跳\n  }\n  \n  lastButtonState = buttonState;\n  delay(10);\n}",
      "language": "arduino",
      "topic": "Arduino 感測器與致動器",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["致動器", "繼電器", "開關控制", "高功率", "原子式"]
      },
      "documentation": "# 繼電器控制\n\n## 功能說明\n繼電器是電磁控制的開關，用於 Arduino 控制高電壓、大電流的設備，實現電氣隔離。\n\n## 工作原理\n- **電磁線圈**: 低電壓控制訊號\n- **機械觸點**: 高功率開關\n- **電氣隔離**: 控制電路與負載電路分離\n- **常開/常閉**: NO (常開) 和 NC (常閉) 觸點\n\n## 繼電器類型\n### 單路繼電器模組\n- **1個控制通道**\n- **LED 指示燈**\n- **光耦隔離**\n- **適合簡單開關控制**\n\n### 多路繼電器模組\n- **2/4/8 路控制**\n- **獨立控制每一路**\n- **適合複雜自動化**\n\n## 接線說明\n```\n繼電器模組     Arduino Uno\nVCC        →  5V\nGND        →  GND\nIN         →  Pin 7 (數位腳位)\n\n負載端：\nCOM        →  電源正極\nNO         →  負載正極 (常開)\nNC         →  負載正極 (常閉)\n```\n\n## 基本控制\n```cpp\n#define RELAY_PIN 7\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(RELAY_PIN, OUTPUT);\n  digitalWrite(RELAY_PIN, LOW);  // 初始關閉\n}\n\nvoid loop() {\n  // 開啟繼電器\n  digitalWrite(RELAY_PIN, HIGH);\n  Serial.println(\"繼電器開啟\");\n  delay(2000);\n  \n  // 關閉繼電器\n  digitalWrite(RELAY_PIN, LOW);\n  Serial.println(\"繼電器關閉\");\n  delay(2000);\n}\n```\n\n## 定時控制\n```cpp\n#define RELAY_PIN 7\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(RELAY_PIN, OUTPUT);\n  digitalWrite(RELAY_PIN, LOW);\n}\n\nvoid loop() {\n  // 每小時開啟 10 分鐘\n  unsigned long currentTime = millis();\n  unsigned long hour = 3600000;      // 1 小時 = 3600000 毫秒\n  unsigned long tenMinutes = 600000; // 10 分鐘 = 600000 毫秒\n  \n  unsigned long cycleTime = currentTime % hour;\n  \n  if (cycleTime < tenMinutes) {\n    digitalWrite(RELAY_PIN, HIGH);\n    Serial.println(\"定時開啟\");\n  } else {\n    digitalWrite(RELAY_PIN, LOW);\n    Serial.println(\"定時關閉\");\n  }\n  \n  delay(5000);  // 每 5 秒檢查一次\n}\n```\n\n## 溫度控制\n```cpp\n#include <DHT.h>\n\n#define DHT_PIN 2\n#define DHT_TYPE DHT22\n#define RELAY_PIN 7\n#define TEMP_THRESHOLD 25.0  // 溫度門檻\n\nDHT dht(DHT_PIN, DHT_TYPE);\nboolean fanState = false;\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(RELAY_PIN, OUTPUT);\n  dht.begin();\n  \n  digitalWrite(RELAY_PIN, LOW);\n  Serial.println(\"溫控系統啟動\");\n}\n\nvoid loop() {\n  float temperature = dht.readTemperature();\n  \n  if (!isnan(temperature)) {\n    Serial.print(\"溫度: \");\n    Serial.print(temperature);\n    Serial.println(\"°C\");\n    \n    // 溫度控制邏輯\n    if (temperature > TEMP_THRESHOLD && !fanState) {\n      digitalWrite(RELAY_PIN, HIGH);\n      fanState = true;\n      Serial.println(\"風扇開啟\");\n    } else if (temperature <= TEMP_THRESHOLD - 2 && fanState) {\n      digitalWrite(RELAY_PIN, LOW);\n      fanState = false;\n      Serial.println(\"風扇關閉\");\n    }\n  }\n  \n  delay(2000);\n}\n```\n\n## 光線控制路燈\n```cpp\n#define LDR_PIN A0\n#define RELAY_PIN 7\n#define LIGHT_THRESHOLD 300\n\nboolean lightState = false;\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(RELAY_PIN, OUTPUT);\n  digitalWrite(RELAY_PIN, LOW);\n  \n  Serial.println(\"自動路燈系統啟動\");\n}\n\nvoid loop() {\n  int lightValue = analogRead(LDR_PIN);\n  \n  Serial.print(\"光線強度: \");\n  Serial.println(lightValue);\n  \n  // 光線控制邏輯 (添加遲滯避免閃爍)\n  if (lightValue < LIGHT_THRESHOLD && !lightState) {\n    digitalWrite(RELAY_PIN, HIGH);\n    lightState = true;\n    Serial.println(\"路燈開啟\");\n  } else if (lightValue > LIGHT_THRESHOLD + 50 && lightState) {\n    digitalWrite(RELAY_PIN, LOW);\n    lightState = false;\n    Serial.println(\"路燈關閉\");\n  }\n  \n  delay(1000);\n}\n```\n\n## 多路繼電器控制\n```cpp\n#define RELAY1_PIN 7\n#define RELAY2_PIN 8\n#define RELAY3_PIN 9\n#define RELAY4_PIN 10\n\nint relayPins[] = {RELAY1_PIN, RELAY2_PIN, RELAY3_PIN, RELAY4_PIN};\nint numRelays = 4;\n\nvoid setup() {\n  Serial.begin(9600);\n  \n  for (int i = 0; i < numRelays; i++) {\n    pinMode(relayPins[i], OUTPUT);\n    digitalWrite(relayPins[i], LOW);\n  }\n  \n  Serial.println(\"多路繼電器控制啟動\");\n}\n\nvoid loop() {\n  // 依序開啟\n  for (int i = 0; i < numRelays; i++) {\n    digitalWrite(relayPins[i], HIGH);\n    Serial.print(\"繼電器 \");\n    Serial.print(i + 1);\n    Serial.println(\" 開啟\");\n    delay(1000);\n  }\n  \n  delay(2000);\n  \n  // 依序關閉\n  for (int i = 0; i < numRelays; i++) {\n    digitalWrite(relayPins[i], LOW);\n    Serial.print(\"繼電器 \");\n    Serial.print(i + 1);\n    Serial.println(\" 關閉\");\n    delay(1000);\n  }\n  \n  delay(2000);\n}\n```\n\n## 安全保護機制\n```cpp\n#define RELAY_PIN 7\n#define EMERGENCY_STOP_PIN 2\n#define STATUS_LED_PIN 13\n\nboolean emergencyStop = false;\nboolean systemEnabled = true;\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(RELAY_PIN, OUTPUT);\n  pinMode(EMERGENCY_STOP_PIN, INPUT_PULLUP);\n  pinMode(STATUS_LED_PIN, OUTPUT);\n  \n  digitalWrite(RELAY_PIN, LOW);\n  Serial.println(\"安全繼電器系統啟動\");\n}\n\nvoid loop() {\n  // 檢查緊急停止\n  if (digitalRead(EMERGENCY_STOP_PIN) == LOW) {\n    if (!emergencyStop) {\n      emergencyStop = true;\n      systemEnabled = false;\n      digitalWrite(RELAY_PIN, LOW);\n      Serial.println(\"緊急停止觸發！\");\n    }\n  } else {\n    if (emergencyStop) {\n      emergencyStop = false;\n      Serial.println(\"緊急停止解除\");\n      delay(2000);  // 安全延遲\n      systemEnabled = true;\n    }\n  }\n  \n  // 狀態指示\n  if (systemEnabled) {\n    digitalWrite(STATUS_LED_PIN, HIGH);\n    \n    // 正常操作邏輯\n    static unsigned long lastToggle = 0;\n    if (millis() - lastToggle > 5000) {\n      boolean currentState = digitalRead(RELAY_PIN);\n      digitalWrite(RELAY_PIN, !currentState);\n      Serial.println(currentState ? \"繼電器關閉\" : \"繼電器開啟\");\n      lastToggle = millis();\n    }\n  } else {\n    // 閃爍警示\n    digitalWrite(STATUS_LED_PIN, (millis() / 500) % 2);\n  }\n  \n  delay(100);\n}\n```\n\n## 應用場景\n- **家電控制** - 電燈、風扇、空調開關\n- **工業自動化** - 馬達、加熱器、泵浦控制\n- **農業灌溉** - 水泵、電磁閥控制\n- **安全系統** - 警報器、門鎖控制\n- **智慧家居** - 遠端設備開關\n\n## 技術規格\n- **控制電壓**: 3.3V - 5V\n- **觸點電流**: 10A - 30A\n- **觸點電壓**: 250VAC / 30VDC\n- **吸合時間**: <10ms\n- **釋放時間**: <5ms\n\n## 安全注意事項\n- **高壓危險**: 220V 接線需專業人員\n- **電氣隔離**: 確保控制電路與負載隔離\n- **負載匹配**: 不可超過繼電器額定容量\n- **感性負載**: 需要加裝突波吸收器\n- **緊急停止**: 高風險應用必須有緊急停止機制"
    },
    {
      "id": "arduino-stepper-motor",
      "title": "步進馬達控制",
      "description": "28BYJ-48 步進馬達精確轉動",
      "code": "#include <Stepper.h>\n\n// 每圈步數 (28BYJ-48 減速比 1:64)\nconst int stepsPerRevolution = 2048;\n\n// 定義步進馬達連接腳位 (IN1, IN3, IN2, IN4)\nStepper myStepper(stepsPerRevolution, 8, 10, 9, 11);\n\nvoid setup() {\n  Serial.begin(9600);\n  myStepper.setSpeed(10);  // 設定轉速 (RPM)\n  Serial.println(\"步進馬達控制啟動\");\n}\n\nvoid loop() {\n  Serial.println(\"順時針旋轉一圈\");\n  myStepper.step(stepsPerRevolution);\n  delay(1000);\n  \n  Serial.println(\"逆時針旋轉一圈\");\n  myStepper.step(-stepsPerRevolution);\n  delay(1000);\n}",
      "language": "arduino",
      "topic": "Arduino 感測器與致動器",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["致動器", "步進馬達", "精確控制", "28BYJ-48", "原子式"]
      },
      "documentation": "# 步進馬達控制 (28BYJ-48)\n\n## 功能說明\n步進馬達是一種能夠精確控制轉動角度和速度的直流馬達，常用於需要精確定位的應用。\n\n## 工作原理\n- **步進驅動**: 依序切換線圈通電產生磁場\n- **精確定位**: 每個脈衝對應固定角度\n- **無需回饋**: 開環控制系統\n- **保持扭力**: 停止時仍有保持力\n\n## 28BYJ-48 規格\n- **步進角度**: 5.625° (64 步/圈)\n- **減速比**: 1:64\n- **實際步數**: 2048 步/圈 (64 × 32)\n- **工作電壓**: 5V\n- **相數**: 4 相 8 拍\n\n## 接線說明\n```\nULN2003 驅動板   Arduino Uno\nVCC           →  5V\nGND           →  GND\nIN1           →  Pin 8\nIN2           →  Pin 9\nIN3           →  Pin 10\nIN4           →  Pin 11\n\n步進馬達連接到驅動板的 4 線插座\n```\n\n## 基本控制\n```cpp\n#include <Stepper.h>\n\nconst int stepsPerRevolution = 2048;\nStepper myStepper(stepsPerRevolution, 8, 10, 9, 11);\n\nvoid setup() {\n  Serial.begin(9600);\n  myStepper.setSpeed(10);  // 10 RPM\n}\n\nvoid loop() {\n  // 順時針旋轉\n  Serial.println(\"順時針 90 度\");\n  myStepper.step(stepsPerRevolution / 4);\n  delay(1000);\n  \n  // 逆時針旋轉\n  Serial.println(\"逆時針 90 度\");\n  myStepper.step(-stepsPerRevolution / 4);\n  delay(1000);\n}\n```\n\n## 速度控制\n```cpp\n#include <Stepper.h>\n\nconst int stepsPerRevolution = 2048;\nStepper myStepper(stepsPerRevolution, 8, 10, 9, 11);\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(\"步進馬達速度測試\");\n}\n\nvoid loop() {\n  // 測試不同速度\n  int speeds[] = {5, 10, 15, 20};\n  int numSpeeds = sizeof(speeds) / sizeof(speeds[0]);\n  \n  for (int i = 0; i < numSpeeds; i++) {\n    Serial.print(\"設定速度: \");\n    Serial.print(speeds[i]);\n    Serial.println(\" RPM\");\n    \n    myStepper.setSpeed(speeds[i]);\n    myStepper.step(stepsPerRevolution / 2);  // 半圈\n    delay(1000);\n  }\n  \n  delay(2000);\n}\n```\n\n## 精確角度控制\n```cpp\n#include <Stepper.h>\n\nconst int stepsPerRevolution = 2048;\nStepper myStepper(stepsPerRevolution, 8, 10, 9, 11);\n\nvoid setup() {\n  Serial.begin(9600);\n  myStepper.setSpeed(15);\n  Serial.println(\"精確角度控制\");\n}\n\nvoid rotateAngle(float angle) {\n  int steps = (angle / 360.0) * stepsPerRevolution;\n  Serial.print(\"旋轉 \");\n  Serial.print(angle);\n  Serial.print(\" 度 (\");\n  Serial.print(steps);\n  Serial.println(\" 步)\");\n  myStepper.step(steps);\n}\n\nvoid loop() {\n  rotateAngle(45);   // 45 度\n  delay(1000);\n  \n  rotateAngle(90);   // 90 度\n  delay(1000);\n  \n  rotateAngle(-135); // 逆時針 135 度\n  delay(1000);\n  \n  rotateAngle(360);  // 完整一圈\n  delay(2000);\n}\n```\n\n## 序列控制命令\n```cpp\n#include <Stepper.h>\n\nconst int stepsPerRevolution = 2048;\nStepper myStepper(stepsPerRevolution, 8, 10, 9, 11);\n\nvoid setup() {\n  Serial.begin(9600);\n  myStepper.setSpeed(12);\n  \n  Serial.println(\"步進馬達序列控制\");\n  Serial.println(\"指令格式:\");\n  Serial.println(\"R[角度] - 相對旋轉 (R90, R-45)\");\n  Serial.println(\"S[速度] - 設定速度 (S10, S20)\");\n  Serial.println(\"H - 回到原點\");\n}\n\nfloat currentAngle = 0;\n\nvoid loop() {\n  if (Serial.available()) {\n    String command = Serial.readString();\n    command.trim();\n    \n    if (command.startsWith(\"R\")) {\n      float angle = command.substring(1).toFloat();\n      rotateRelative(angle);\n    } else if (command.startsWith(\"S\")) {\n      int speed = command.substring(1).toInt();\n      myStepper.setSpeed(speed);\n      Serial.print(\"速度設定為: \");\n      Serial.println(speed);\n    } else if (command == \"H\") {\n      goHome();\n    } else {\n      Serial.println(\"無效指令\");\n    }\n  }\n}\n\nvoid rotateRelative(float angle) {\n  int steps = (angle / 360.0) * stepsPerRevolution;\n  myStepper.step(steps);\n  currentAngle += angle;\n  \n  Serial.print(\"旋轉 \");\n  Serial.print(angle);\n  Serial.print(\" 度，目前角度: \");\n  Serial.println(currentAngle);\n}\n\nvoid goHome() {\n  Serial.println(\"回到原點\");\n  rotateRelative(-currentAngle);\n  currentAngle = 0;\n}\n```\n\n## 微步控制\n```cpp\n// 不使用 Stepper 函式庫的直接控制\n#define IN1 8\n#define IN2 9\n#define IN3 10\n#define IN4 11\n\n// 4 相 8 拍序列\nint stepSequence[8][4] = {\n  {1, 0, 0, 0},\n  {1, 1, 0, 0},\n  {0, 1, 0, 0},\n  {0, 1, 1, 0},\n  {0, 0, 1, 0},\n  {0, 0, 1, 1},\n  {0, 0, 0, 1},\n  {1, 0, 0, 1}\n};\n\nint stepCount = 0;\nint stepDelay = 2;  // 毫秒\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(IN1, OUTPUT);\n  pinMode(IN2, OUTPUT);\n  pinMode(IN3, OUTPUT);\n  pinMode(IN4, OUTPUT);\n}\n\nvoid loop() {\n  // 順時針 1024 步 (半圈)\n  for (int i = 0; i < 1024; i++) {\n    stepForward();\n    delay(stepDelay);\n  }\n  \n  delay(1000);\n  \n  // 逆時針 1024 步 (半圈)\n  for (int i = 0; i < 1024; i++) {\n    stepBackward();\n    delay(stepDelay);\n  }\n  \n  delay(1000);\n}\n\nvoid stepForward() {\n  setStep(stepCount % 8);\n  stepCount++;\n}\n\nvoid stepBackward() {\n  stepCount--;\n  setStep(stepCount % 8);\n}\n\nvoid setStep(int step) {\n  digitalWrite(IN1, stepSequence[step][0]);\n  digitalWrite(IN2, stepSequence[step][1]);\n  digitalWrite(IN3, stepSequence[step][2]);\n  digitalWrite(IN4, stepSequence[step][3]);\n}\n```\n\n## 位置記憶與恢復\n```cpp\n#include <Stepper.h>\n#include <EEPROM.h>\n\nconst int stepsPerRevolution = 2048;\nStepper myStepper(stepsPerRevolution, 8, 10, 9, 11);\n\nlong currentPosition = 0;  // 目前位置 (步數)\nconst int EEPROM_ADDRESS = 0;\n\nvoid setup() {\n  Serial.begin(9600);\n  myStepper.setSpeed(15);\n  \n  // 從 EEPROM 讀取上次位置\n  EEPROM.get(EEPROM_ADDRESS, currentPosition);\n  \n  Serial.println(\"步進馬達位置控制\");\n  Serial.print(\"上次位置: \");\n  Serial.println(currentPosition);\n}\n\nvoid loop() {\n  if (Serial.available()) {\n    String input = Serial.readString();\n    input.trim();\n    \n    if (input.startsWith(\"GOTO\")) {\n      long targetPosition = input.substring(4).toInt();\n      goToPosition(targetPosition);\n    } else if (input == \"HOME\") {\n      goToPosition(0);\n    } else if (input == \"SAVE\") {\n      savePosition();\n    } else if (input == \"POS\") {\n      Serial.print(\"目前位置: \");\n      Serial.println(currentPosition);\n    }\n  }\n}\n\nvoid goToPosition(long targetPosition) {\n  long steps = targetPosition - currentPosition;\n  \n  Serial.print(\"移動 \");\n  Serial.print(steps);\n  Serial.print(\" 步到位置 \");\n  Serial.println(targetPosition);\n  \n  myStepper.step(steps);\n  currentPosition = targetPosition;\n}\n\nvoid savePosition() {\n  EEPROM.put(EEPROM_ADDRESS, currentPosition);\n  Serial.println(\"位置已儲存\");\n}\n```\n\n## 應用場景\n- **3D 印表機** - XYZ 軸精確定位\n- **CNC 機械** - 工具精確移動\n- **攝影雲台** - 定時攝影轉動\n- **自動化設備** - 精確角度控制\n- **機器人關節** - 多軸協調運動\n\n## 技術規格 (28BYJ-48)\n- **步進角度**: 5.625°/64 步\n- **減速後**: 2048 步/圈\n- **額定電壓**: 5V\n- **額定電流**: 約 200mA\n- **最大扭力**: 約 34.3 mN⋅m\n- **最大速度**: 約 15 RPM\n\n## 注意事項\n- 需要 ULN2003 驅動板\n- 速度過快會導致失步\n- 長時間通電會發熱\n- 斷電會失去位置資訊\n- 負載過重會影響精度"
    },
    {
      "id": "arduino-dc-motor",
      "title": "直流馬達控制",
      "description": "L298N 驅動板控制直流馬達",
      "code": "#define MOTOR_PIN1 7\n#define MOTOR_PIN2 8\n#define ENABLE_PIN 9\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(MOTOR_PIN1, OUTPUT);\n  pinMode(MOTOR_PIN2, OUTPUT);\n  pinMode(ENABLE_PIN, OUTPUT);\n  \n  Serial.println(\"直流馬達控制啟動\");\n}\n\nvoid loop() {\n  // 正轉\n  motorForward(200);\n  delay(2000);\n  \n  // 停止\n  motorStop();\n  delay(1000);\n  \n  // 反轉\n  motorBackward(150);\n  delay(2000);\n  \n  // 停止\n  motorStop();\n  delay(1000);\n}\n\nvoid motorForward(int speed) {\n  digitalWrite(MOTOR_PIN1, HIGH);\n  digitalWrite(MOTOR_PIN2, LOW);\n  analogWrite(ENABLE_PIN, speed);\n  Serial.print(\"正轉，速度: \");\n  Serial.println(speed);\n}\n\nvoid motorBackward(int speed) {\n  digitalWrite(MOTOR_PIN1, LOW);\n  digitalWrite(MOTOR_PIN2, HIGH);\n  analogWrite(ENABLE_PIN, speed);\n  Serial.print(\"反轉，速度: \");\n  Serial.println(speed);\n}\n\nvoid motorStop() {\n  digitalWrite(MOTOR_PIN1, LOW);\n  digitalWrite(MOTOR_PIN2, LOW);\n  analogWrite(ENABLE_PIN, 0);\n  Serial.println(\"馬達停止\");\n}",
      "language": "arduino",
      "topic": "Arduino 感測器與致動器",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["致動器", "直流馬達", "L298N", "速度控制", "原子式"]
      },
      "documentation": "# 直流馬達控制 (L298N)\n\n## 功能說明\n直流馬達是最常用的驅動元件，配合 L298N 驅動板可以控制馬達的轉向和速度。\n\n## L298N 驅動板特性\n- **雙 H 橋設計**: 可控制 2 個直流馬達\n- **電流能力**: 每通道最大 2A\n- **電壓範圍**: 5V - 35V\n- **內建保護**: 過熱保護和反向保護\n- **PWM 調速**: 支援速度控制\n\n## 接線說明\n```\nL298N 驅動板    Arduino Uno    直流馬達\nVCC          →  5V (邏輯電源)\nGND          →  GND\nIN1          →  Pin 7\nIN2          →  Pin 8\nENA          →  Pin 9 (PWM)\nOUT1         →  馬達正極\nOUT2         →  馬達負極\n\n馬達電源 (12V) 接 L298N 的 12V 端子\n```\n\n## 基本控制\n```cpp\n#define MOTOR_IN1 7\n#define MOTOR_IN2 8\n#define MOTOR_ENA 9\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(MOTOR_IN1, OUTPUT);\n  pinMode(MOTOR_IN2, OUTPUT);\n  pinMode(MOTOR_ENA, OUTPUT);\n}\n\nvoid loop() {\n  // 正轉 3 秒\n  digitalWrite(MOTOR_IN1, HIGH);\n  digitalWrite(MOTOR_IN2, LOW);\n  analogWrite(MOTOR_ENA, 255);  // 全速\n  Serial.println(\"正轉\");\n  delay(3000);\n  \n  // 停止 1 秒\n  analogWrite(MOTOR_ENA, 0);\n  Serial.println(\"停止\");\n  delay(1000);\n  \n  // 反轉 3 秒\n  digitalWrite(MOTOR_IN1, LOW);\n  digitalWrite(MOTOR_IN2, HIGH);\n  analogWrite(MOTOR_ENA, 255);\n  Serial.println(\"反轉\");\n  delay(3000);\n  \n  // 停止 1 秒\n  analogWrite(MOTOR_ENA, 0);\n  delay(1000);\n}\n```\n\n## 速度漸變控制\n```cpp\n#define MOTOR_IN1 7\n#define MOTOR_IN2 8\n#define MOTOR_ENA 9\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(MOTOR_IN1, OUTPUT);\n  pinMode(MOTOR_IN2, OUTPUT);\n  pinMode(MOTOR_ENA, OUTPUT);\n}\n\nvoid loop() {\n  // 正轉加速\n  digitalWrite(MOTOR_IN1, HIGH);\n  digitalWrite(MOTOR_IN2, LOW);\n  \n  for (int speed = 0; speed <= 255; speed += 5) {\n    analogWrite(MOTOR_ENA, speed);\n    Serial.print(\"正轉速度: \");\n    Serial.println(speed);\n    delay(100);\n  }\n  \n  // 正轉減速\n  for (int speed = 255; speed >= 0; speed -= 5) {\n    analogWrite(MOTOR_ENA, speed);\n    Serial.print(\"正轉速度: \");\n    Serial.println(speed);\n    delay(100);\n  }\n  \n  delay(1000);\n  \n  // 反轉加速\n  digitalWrite(MOTOR_IN1, LOW);\n  digitalWrite(MOTOR_IN2, HIGH);\n  \n  for (int speed = 0; speed <= 255; speed += 5) {\n    analogWrite(MOTOR_ENA, speed);\n    Serial.print(\"反轉速度: \");\n    Serial.println(speed);\n    delay(100);\n  }\n  \n  // 反轉減速\n  for (int speed = 255; speed >= 0; speed -= 5) {\n    analogWrite(MOTOR_ENA, speed);\n    Serial.print(\"反轉速度: \");\n    Serial.println(speed);\n    delay(100);\n  }\n  \n  delay(1000);\n}\n```\n\n## 電位器控制馬達\n```cpp\n#define POT_PIN A0\n#define MOTOR_IN1 7\n#define MOTOR_IN2 8\n#define MOTOR_ENA 9\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(MOTOR_IN1, OUTPUT);\n  pinMode(MOTOR_IN2, OUTPUT);\n  pinMode(MOTOR_ENA, OUTPUT);\n}\n\nvoid loop() {\n  int potValue = analogRead(POT_PIN);\n  \n  // 將電位器值轉換為馬達控制\n  // 0-400: 反轉，400-600: 停止，600-1023: 正轉\n  if (potValue < 400) {\n    // 反轉\n    int speed = map(potValue, 0, 399, 255, 0);\n    digitalWrite(MOTOR_IN1, LOW);\n    digitalWrite(MOTOR_IN2, HIGH);\n    analogWrite(MOTOR_ENA, speed);\n    \n    Serial.print(\"反轉，速度: \");\n    Serial.println(speed);\n  } else if (potValue > 600) {\n    // 正轉\n    int speed = map(potValue, 601, 1023, 0, 255);\n    digitalWrite(MOTOR_IN1, HIGH);\n    digitalWrite(MOTOR_IN2, LOW);\n    analogWrite(MOTOR_ENA, speed);\n    \n    Serial.print(\"正轉，速度: \");\n    Serial.println(speed);\n  } else {\n    // 停止\n    analogWrite(MOTOR_ENA, 0);\n    Serial.println(\"停止\");\n  }\n  \n  delay(100);\n}\n```\n\n## 雙馬達控制 (遙控車)\n```cpp\n#define MOTOR_L_IN1 7\n#define MOTOR_L_IN2 8\n#define MOTOR_L_ENA 9\n#define MOTOR_R_IN1 4\n#define MOTOR_R_IN2 2\n#define MOTOR_R_ENA 3\n\nvoid setup() {\n  Serial.begin(9600);\n  \n  // 左馬達\n  pinMode(MOTOR_L_IN1, OUTPUT);\n  pinMode(MOTOR_L_IN2, OUTPUT);\n  pinMode(MOTOR_L_ENA, OUTPUT);\n  \n  // 右馬達\n  pinMode(MOTOR_R_IN1, OUTPUT);\n  pinMode(MOTOR_R_IN2, OUTPUT);\n  pinMode(MOTOR_R_ENA, OUTPUT);\n  \n  Serial.println(\"雙馬達控制啟動\");\n  Serial.println(\"指令: W(前進) S(後退) A(左轉) D(右轉) X(停止)\");\n}\n\nvoid loop() {\n  if (Serial.available()) {\n    char command = Serial.read();\n    \n    switch (command) {\n      case 'W':\n      case 'w':\n        moveForward(200);\n        break;\n      case 'S':\n      case 's':\n        moveBackward(200);\n        break;\n      case 'A':\n      case 'a':\n        turnLeft(200);\n        break;\n      case 'D':\n      case 'd':\n        turnRight(200);\n        break;\n      case 'X':\n      case 'x':\n        stopMotors();\n        break;\n    }\n  }\n}\n\nvoid moveForward(int speed) {\n  // 左馬達正轉\n  digitalWrite(MOTOR_L_IN1, HIGH);\n  digitalWrite(MOTOR_L_IN2, LOW);\n  analogWrite(MOTOR_L_ENA, speed);\n  \n  // 右馬達正轉\n  digitalWrite(MOTOR_R_IN1, HIGH);\n  digitalWrite(MOTOR_R_IN2, LOW);\n  analogWrite(MOTOR_R_ENA, speed);\n  \n  Serial.println(\"前進\");\n}\n\nvoid moveBackward(int speed) {\n  // 左馬達反轉\n  digitalWrite(MOTOR_L_IN1, LOW);\n  digitalWrite(MOTOR_L_IN2, HIGH);\n  analogWrite(MOTOR_L_ENA, speed);\n  \n  // 右馬達反轉\n  digitalWrite(MOTOR_R_IN1, LOW);\n  digitalWrite(MOTOR_R_IN2, HIGH);\n  analogWrite(MOTOR_R_ENA, speed);\n  \n  Serial.println(\"後退\");\n}\n\nvoid turnLeft(int speed) {\n  // 左馬達停止\n  analogWrite(MOTOR_L_ENA, 0);\n  \n  // 右馬達正轉\n  digitalWrite(MOTOR_R_IN1, HIGH);\n  digitalWrite(MOTOR_R_IN2, LOW);\n  analogWrite(MOTOR_R_ENA, speed);\n  \n  Serial.println(\"左轉\");\n}\n\nvoid turnRight(int speed) {\n  // 左馬達正轉\n  digitalWrite(MOTOR_L_IN1, HIGH);\n  digitalWrite(MOTOR_L_IN2, LOW);\n  analogWrite(MOTOR_L_ENA, speed);\n  \n  // 右馬達停止\n  analogWrite(MOTOR_R_ENA, 0);\n  \n  Serial.println(\"右轉\");\n}\n\nvoid stopMotors() {\n  analogWrite(MOTOR_L_ENA, 0);\n  analogWrite(MOTOR_R_ENA, 0);\n  Serial.println(\"停止\");\n}\n```\n\n## 編碼器回饋控制\n```cpp\n#define MOTOR_IN1 7\n#define MOTOR_IN2 8\n#define MOTOR_ENA 9\n#define ENCODER_A 2\n#define ENCODER_B 3\n\nvolatile long encoderCount = 0;\nlong targetPosition = 1000;  // 目標位置\nint motorSpeed = 0;\n\nvoid setup() {\n  Serial.begin(9600);\n  \n  pinMode(MOTOR_IN1, OUTPUT);\n  pinMode(MOTOR_IN2, OUTPUT);\n  pinMode(MOTOR_ENA, OUTPUT);\n  \n  pinMode(ENCODER_A, INPUT_PULLUP);\n  pinMode(ENCODER_B, INPUT_PULLUP);\n  \n  // 編碼器中斷\n  attachInterrupt(digitalPinToInterrupt(ENCODER_A), encoderISR, RISING);\n  \n  Serial.println(\"編碼器回饋控制啟動\");\n}\n\nvoid loop() {\n  // 簡單 PID 控制\n  long error = targetPosition - encoderCount;\n  \n  if (abs(error) > 10) {\n    motorSpeed = constrain(error * 2, -255, 255);\n    \n    if (motorSpeed > 0) {\n      digitalWrite(MOTOR_IN1, HIGH);\n      digitalWrite(MOTOR_IN2, LOW);\n      analogWrite(MOTOR_ENA, motorSpeed);\n    } else {\n      digitalWrite(MOTOR_IN1, LOW);\n      digitalWrite(MOTOR_IN2, HIGH);\n      analogWrite(MOTOR_ENA, -motorSpeed);\n    }\n  } else {\n    analogWrite(MOTOR_ENA, 0);\n    motorSpeed = 0;\n  }\n  \n  Serial.print(\"位置: \");\n  Serial.print(encoderCount);\n  Serial.print(\", 目標: \");\n  Serial.print(targetPosition);\n  Serial.print(\", 速度: \");\n  Serial.println(motorSpeed);\n  \n  // 檢查序列指令\n  if (Serial.available()) {\n    targetPosition = Serial.parseInt();\n    Serial.print(\"新目標位置: \");\n    Serial.println(targetPosition);\n  }\n  \n  delay(50);\n}\n\nvoid encoderISR() {\n  if (digitalRead(ENCODER_B) == HIGH) {\n    encoderCount++;\n  } else {\n    encoderCount--;\n  }\n}\n```\n\n## 應用場景\n- **遙控車** - 移動機器人底盤\n- **風扇控制** - 可變速散熱系統\n- **輸送帶** - 自動化生產線\n- **攪拌器** - 實驗室設備\n- **電動工具** - DIY 自動化工具\n\n## 技術規格 (L298N)\n- **工作電壓**: 5V - 35V\n- **邏輯電壓**: 5V\n- **最大電流**: 2A (每通道)\n- **峰值電流**: 3A\n- **驅動方式**: H 橋驅動\n- **控制方式**: TTL/CMOS 相容\n\n## 注意事項\n- 馬達電源與邏輯電源分離\n- 大電流馬達需要外部電源\n- 感性負載需要反向保護二極體\n- 注意散熱，大電流時會發熱\n- PWM 頻率過高可能造成噪音\n- 編碼器接線要穩固避免訊號干擾"
    },
    {
      "id": "arduino-rgb-led",
      "title": "RGB LED 控制",
      "description": "三色 LED 色彩混合控制",
      "code": "#define RED_PIN 9\n#define GREEN_PIN 10\n#define BLUE_PIN 11\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(RED_PIN, OUTPUT);\n  pinMode(GREEN_PIN, OUTPUT);\n  pinMode(BLUE_PIN, OUTPUT);\n  \n  Serial.println(\"RGB LED 控制啟動\");\n}\n\nvoid loop() {\n  // 紅色\n  setColor(255, 0, 0);\n  delay(1000);\n  \n  // 綠色\n  setColor(0, 255, 0);\n  delay(1000);\n  \n  // 藍色\n  setColor(0, 0, 255);\n  delay(1000);\n  \n  // 白色\n  setColor(255, 255, 255);\n  delay(1000);\n  \n  // 紫色\n  setColor(128, 0, 128);\n  delay(1000);\n  \n  // 關閉\n  setColor(0, 0, 0);\n  delay(1000);\n}\n\nvoid setColor(int red, int green, int blue) {\n  analogWrite(RED_PIN, red);\n  analogWrite(GREEN_PIN, green);\n  analogWrite(BLUE_PIN, blue);\n  \n  Serial.print(\"RGB: (\");\n  Serial.print(red);\n  Serial.print(\", \");\n  Serial.print(green);\n  Serial.print(\", \");\n  Serial.print(blue);\n  Serial.println(\")\");\n}",
      "language": "arduino",
      "topic": "Arduino 感測器與致動器",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["輸出", "RGB LED", "色彩控制", "PWM", "原子式"]
      },
      "documentation": "# RGB LED 控制\n\n## 功能說明\nRGB LED 包含紅、綠、藍三個 LED，通過調節三色的亮度比例可以產生各種顏色。\n\n## 工作原理\n- **色彩混合**: 紅、綠、藍三原色混合\n- **PWM 調光**: 透過 PWM 控制各色亮度\n- **色域範圍**: 可產生 1677 萬種顏色 (24bit)\n- **共陰/共陽**: 兩種不同的接線方式\n\n## RGB LED 類型\n### 共陰極 (Common Cathode)\n- **共同負極**: 所有 LED 共用負極\n- **控制方式**: 高電位點亮\n- **接線**: 負極接 GND，正極接控制腳位\n\n### 共陽極 (Common Anode)\n- **共同正極**: 所有 LED 共用正極\n- **控制方式**: 低電位點亮\n- **接線**: 正極接 VCC，負極接控制腳位\n\n## 接線說明 (共陰極)\n```\nRGB LED       Arduino Uno\n紅色正極   →  Pin 9 (PWM)\n綠色正極   →  Pin 10 (PWM)\n藍色正極   →  Pin 11 (PWM)\n共同負極   →  GND\n\n※ 每個腳位串聯 220Ω 限流電阻\n```\n\n## 基本色彩\n```cpp\n#define RED_PIN 9\n#define GREEN_PIN 10\n#define BLUE_PIN 11\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(RED_PIN, OUTPUT);\n  pinMode(GREEN_PIN, OUTPUT);\n  pinMode(BLUE_PIN, OUTPUT);\n}\n\nvoid loop() {\n  // 基本顏色展示\n  showColor(\"紅色\", 255, 0, 0);\n  showColor(\"綠色\", 0, 255, 0);\n  showColor(\"藍色\", 0, 0, 255);\n  showColor(\"黃色\", 255, 255, 0);\n  showColor(\"青色\", 0, 255, 255);\n  showColor(\"紫色\", 255, 0, 255);\n  showColor(\"白色\", 255, 255, 255);\n  showColor(\"關閉\", 0, 0, 0);\n}\n\nvoid showColor(String name, int r, int g, int b) {\n  analogWrite(RED_PIN, r);\n  analogWrite(GREEN_PIN, g);\n  analogWrite(BLUE_PIN, b);\n  \n  Serial.print(name);\n  Serial.print(\": RGB(\");\n  Serial.print(r);\n  Serial.print(\", \");\n  Serial.print(g);\n  Serial.print(\", \");\n  Serial.print(b);\n  Serial.println(\")\");\n  \n  delay(1500);\n}\n```\n\n## 彩虹漸變效果\n```cpp\n#define RED_PIN 9\n#define GREEN_PIN 10\n#define BLUE_PIN 11\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(RED_PIN, OUTPUT);\n  pinMode(GREEN_PIN, OUTPUT);\n  pinMode(BLUE_PIN, OUTPUT);\n}\n\nvoid loop() {\n  // 彩虹色彩循環\n  for (int hue = 0; hue < 360; hue++) {\n    setHSV(hue, 255, 255);\n    delay(20);\n  }\n}\n\nvoid setHSV(int h, int s, int v) {\n  // HSV 轉 RGB\n  float hue = h / 60.0;\n  float saturation = s / 255.0;\n  float value = v / 255.0;\n  \n  int i = (int)hue;\n  float f = hue - i;\n  float p = value * (1 - saturation);\n  float q = value * (1 - saturation * f);\n  float t = value * (1 - saturation * (1 - f));\n  \n  float r, g, b;\n  \n  switch (i) {\n    case 0: r = value; g = t; b = p; break;\n    case 1: r = q; g = value; b = p; break;\n    case 2: r = p; g = value; b = t; break;\n    case 3: r = p; g = q; b = value; break;\n    case 4: r = t; g = p; b = value; break;\n    case 5: r = value; g = p; b = q; break;\n    default: r = g = b = 0; break;\n  }\n  \n  analogWrite(RED_PIN, (int)(r * 255));\n  analogWrite(GREEN_PIN, (int)(g * 255));\n  analogWrite(BLUE_PIN, (int)(b * 255));\n}\n```\n\n## 呼吸燈效果\n```cpp\n#define RED_PIN 9\n#define GREEN_PIN 10\n#define BLUE_PIN 11\n\nvoid setup() {\n  pinMode(RED_PIN, OUTPUT);\n  pinMode(GREEN_PIN, OUTPUT);\n  pinMode(BLUE_PIN, OUTPUT);\n}\n\nvoid loop() {\n  // 紅色呼吸燈\n  breathe(255, 0, 0, 2000);\n  \n  // 綠色呼吸燈\n  breathe(0, 255, 0, 2000);\n  \n  // 藍色呼吸燈\n  breathe(0, 0, 255, 2000);\n  \n  // 白色呼吸燈\n  breathe(255, 255, 255, 2000);\n}\n\nvoid breathe(int r, int g, int b, int duration) {\n  // 漸亮\n  for (int brightness = 0; brightness <= 255; brightness++) {\n    analogWrite(RED_PIN, (r * brightness) / 255);\n    analogWrite(GREEN_PIN, (g * brightness) / 255);\n    analogWrite(BLUE_PIN, (b * brightness) / 255);\n    delay(duration / 512);\n  }\n  \n  // 漸暗\n  for (int brightness = 255; brightness >= 0; brightness--) {\n    analogWrite(RED_PIN, (r * brightness) / 255);\n    analogWrite(GREEN_PIN, (g * brightness) / 255);\n    analogWrite(BLUE_PIN, (b * brightness) / 255);\n    delay(duration / 512);\n  }\n}\n```\n\n## 序列控制\n```cpp\n#define RED_PIN 9\n#define GREEN_PIN 10\n#define BLUE_PIN 11\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(RED_PIN, OUTPUT);\n  pinMode(GREEN_PIN, OUTPUT);\n  pinMode(BLUE_PIN, OUTPUT);\n  \n  Serial.println(\"RGB LED 序列控制\");\n  Serial.println(\"格式: R,G,B (例如: 255,0,128)\");\n  Serial.println(\"預設顏色: RED, GREEN, BLUE, WHITE, OFF\");\n}\n\nvoid loop() {\n  if (Serial.available()) {\n    String input = Serial.readString();\n    input.trim();\n    \n    if (input.equalsIgnoreCase(\"RED\")) {\n      setColor(255, 0, 0);\n    } else if (input.equalsIgnoreCase(\"GREEN\")) {\n      setColor(0, 255, 0);\n    } else if (input.equalsIgnoreCase(\"BLUE\")) {\n      setColor(0, 0, 255);\n    } else if (input.equalsIgnoreCase(\"WHITE\")) {\n      setColor(255, 255, 255);\n    } else if (input.equalsIgnoreCase(\"OFF\")) {\n      setColor(0, 0, 0);\n    } else {\n      parseRGB(input);\n    }\n  }\n}\n\nvoid parseRGB(String rgbString) {\n  int r = 0, g = 0, b = 0;\n  int commaIndex1 = rgbString.indexOf(',');\n  int commaIndex2 = rgbString.indexOf(',', commaIndex1 + 1);\n  \n  if (commaIndex1 > 0 && commaIndex2 > commaIndex1) {\n    r = rgbString.substring(0, commaIndex1).toInt();\n    g = rgbString.substring(commaIndex1 + 1, commaIndex2).toInt();\n    b = rgbString.substring(commaIndex2 + 1).toInt();\n    \n    r = constrain(r, 0, 255);\n    g = constrain(g, 0, 255);\n    b = constrain(b, 0, 255);\n    \n    setColor(r, g, b);\n  } else {\n    Serial.println(\"格式錯誤！請使用 R,G,B 格式\");\n  }\n}\n\nvoid setColor(int r, int g, int b) {\n  analogWrite(RED_PIN, r);\n  analogWrite(GREEN_PIN, g);\n  analogWrite(BLUE_PIN, b);\n  \n  Serial.print(\"設定顏色: RGB(\");\n  Serial.print(r);\n  Serial.print(\", \");\n  Serial.print(g);\n  Serial.print(\", \");\n  Serial.print(b);\n  Serial.println(\")\");\n}\n```\n\n## 溫度指示器\n```cpp\n#include <DHT.h>\n\n#define DHT_PIN 2\n#define DHT_TYPE DHT22\n#define RED_PIN 9\n#define GREEN_PIN 10\n#define BLUE_PIN 11\n\nDHT dht(DHT_PIN, DHT_TYPE);\n\nvoid setup() {\n  Serial.begin(9600);\n  dht.begin();\n  \n  pinMode(RED_PIN, OUTPUT);\n  pinMode(GREEN_PIN, OUTPUT);\n  pinMode(BLUE_PIN, OUTPUT);\n  \n  Serial.println(\"溫度 RGB 指示器啟動\");\n}\n\nvoid loop() {\n  float temperature = dht.readTemperature();\n  \n  if (!isnan(temperature)) {\n    setTemperatureColor(temperature);\n    \n    Serial.print(\"溫度: \");\n    Serial.print(temperature);\n    Serial.println(\"°C\");\n  }\n  \n  delay(2000);\n}\n\nvoid setTemperatureColor(float temp) {\n  int r, g, b;\n  \n  if (temp < 0) {\n    // 極冷 - 深藍色\n    r = 0; g = 0; b = 255;\n  } else if (temp < 10) {\n    // 冷 - 藍色到青色\n    r = 0;\n    g = map(temp, 0, 10, 0, 255);\n    b = 255;\n  } else if (temp < 20) {\n    // 涼 - 青色到綠色\n    r = 0;\n    g = 255;\n    b = map(temp, 10, 20, 255, 0);\n  } else if (temp < 30) {\n    // 適中 - 綠色到黃色\n    r = map(temp, 20, 30, 0, 255);\n    g = 255;\n    b = 0;\n  } else if (temp < 40) {\n    // 暖 - 黃色到紅色\n    r = 255;\n    g = map(temp, 30, 40, 255, 0);\n    b = 0;\n  } else {\n    // 熱 - 紅色\n    r = 255; g = 0; b = 0;\n  }\n  \n  analogWrite(RED_PIN, r);\n  analogWrite(GREEN_PIN, g);\n  analogWrite(BLUE_PIN, b);\n}\n```\n\n## 音樂節拍燈\n```cpp\n#define SOUND_PIN A0\n#define RED_PIN 9\n#define GREEN_PIN 10\n#define BLUE_PIN 11\n\nint soundThreshold = 100;\nint colorIndex = 0;\n\n// 預設顏色表\nint colors[6][3] = {\n  {255, 0, 0},    // 紅\n  {0, 255, 0},    // 綠\n  {0, 0, 255},    // 藍\n  {255, 255, 0},  // 黃\n  {255, 0, 255},  // 紫\n  {0, 255, 255}   // 青\n};\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(RED_PIN, OUTPUT);\n  pinMode(GREEN_PIN, OUTPUT);\n  pinMode(BLUE_PIN, OUTPUT);\n  \n  Serial.println(\"音樂節拍燈啟動\");\n}\n\nvoid loop() {\n  int soundLevel = analogRead(SOUND_PIN);\n  \n  if (soundLevel > soundThreshold) {\n    // 切換顏色\n    analogWrite(RED_PIN, colors[colorIndex][0]);\n    analogWrite(GREEN_PIN, colors[colorIndex][1]);\n    analogWrite(BLUE_PIN, colors[colorIndex][2]);\n    \n    colorIndex = (colorIndex + 1) % 6;\n    \n    Serial.print(\"節拍偵測，音量: \");\n    Serial.println(soundLevel);\n    \n    delay(100);  // 防止過快切換\n  } else {\n    // 關閉 LED\n    analogWrite(RED_PIN, 0);\n    analogWrite(GREEN_PIN, 0);\n    analogWrite(BLUE_PIN, 0);\n  }\n  \n  delay(50);\n}\n```\n\n## 應用場景\n- **情境照明** - 智慧家居氛圍燈\n- **狀態指示** - 設備運行狀態顯示\n- **溫度顯示** - 視覺化溫度變化\n- **音樂燈效** - 跟隨音樂節拍\n- **遊戲設備** - 遊戲狀態回饋\n\n## 技術規格\n- **發光顏色**: 紅、綠、藍三原色\n- **工作電壓**: 2V - 3.3V (每顆 LED)\n- **工作電流**: 20mA (每顆 LED)\n- **色彩範圍**: 16,777,216 色 (24bit)\n- **控制方式**: PWM 調光\n\n## 注意事項\n- 區分共陰極和共陽極接法\n- 每個 LED 需要限流電阻保護\n- PWM 頻率影響色彩平滑度\n- 高亮度時注意電流限制\n- 顏色校準可能因 LED 特性而異\n- 長時間點亮會影響 LED 壽命"
    },
    {
      "id": "arduino-keypad",
      "title": "4x4 矩陣鍵盤",
      "description": "16 鍵矩陣鍵盤輸入檢測",
      "code": "#include <Keypad.h>\n\nconst byte ROWS = 4;\nconst byte COLS = 4;\n\nchar keys[ROWS][COLS] = {\n  {'1', '2', '3', 'A'},\n  {'4', '5', '6', 'B'},\n  {'7', '8', '9', 'C'},\n  {'*', '0', '#', 'D'}\n};\n\nbyte rowPins[ROWS] = {9, 8, 7, 6};\nbyte colPins[COLS] = {5, 4, 3, 2};\n\nKeypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(\"4x4 矩陣鍵盤啟動\");\n  Serial.println(\"請按鍵...\");\n}\n\nvoid loop() {\n  char key = keypad.getKey();\n  \n  if (key) {\n    Serial.print(\"按下按鍵: \");\n    Serial.println(key);\n    \n    // 簡單功能示例\n    if (key >= '0' && key <= '9') {\n      Serial.println(\"數字鍵\");\n    } else {\n      Serial.println(\"功能鍵\");\n    }\n  }\n}",
      "language": "arduino",
      "topic": "Arduino 感測器與致動器",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["輸入", "鍵盤", "矩陣", "按鍵", "原子式"]
      },
      "documentation": "# 4x4 矩陣鍵盤\n\n## 功能說明\n矩陣鍵盤透過行列掃描的方式，用較少的腳位控制多個按鍵，常用於數字輸入和選單操作。\n\n## 工作原理\n- **矩陣掃描**: 依序掃描每一行，檢測列的狀態\n- **節省腳位**: 4x4 鍵盤只需 8 個腳位\n- **防鬼鍵**: 避免多鍵同時按下的誤判\n- **去彈跳**: 軟體濾除機械開關雜訊\n\n## 鍵盤佈局 (4x4)\n```\n[1] [2] [3] [A]\n[4] [5] [6] [B]\n[7] [8] [9] [C]\n[*] [0] [#] [D]\n```\n\n## 接線說明\n```\n4x4 鍵盤模組    Arduino Uno\nR1 (列1)     →  Pin 9\nR2 (列2)     →  Pin 8\nR3 (列3)     →  Pin 7\nR4 (列4)     →  Pin 6\nC1 (行1)     →  Pin 5\nC2 (行2)     →  Pin 4\nC3 (行3)     →  Pin 3\nC4 (行4)     →  Pin 2\n```\n\n## 安裝函式庫\n1. 開啟 Arduino IDE\n2. 工具 → 管理程式庫\n3. 搜尋 \"Keypad\"\n4. 安裝 Mark Stanley 的 Keypad library\n\n## 基本使用\n```cpp\n#include <Keypad.h>\n\nconst byte ROWS = 4;\nconst byte COLS = 4;\n\nchar keys[ROWS][COLS] = {\n  {'1', '2', '3', 'A'},\n  {'4', '5', '6', 'B'},\n  {'7', '8', '9', 'C'},\n  {'*', '0', '#', 'D'}\n};\n\nbyte rowPins[ROWS] = {9, 8, 7, 6};\nbyte colPins[COLS] = {5, 4, 3, 2};\n\nKeypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(\"鍵盤測試啟動\");\n}\n\nvoid loop() {\n  char key = keypad.getKey();\n  \n  if (key != NO_KEY) {\n    Serial.print(\"按鍵: \");\n    Serial.println(key);\n  }\n}\n```\n\n## 密碼鎖系統\n```cpp\n#include <Keypad.h>\n\nconst byte ROWS = 4;\nconst byte COLS = 4;\n\nchar keys[ROWS][COLS] = {\n  {'1', '2', '3', 'A'},\n  {'4', '5', '6', 'B'},\n  {'7', '8', '9', 'C'},\n  {'*', '0', '#', 'D'}\n};\n\nbyte rowPins[ROWS] = {9, 8, 7, 6};\nbyte colPins[COLS] = {5, 4, 3, 2};\n\nKeypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);\n\nString correctPassword = \"1234\";\nString inputPassword = \"\";\nboolean isLocked = true;\n\n#define LED_PIN 13\n#define BUZZER_PIN 12\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(LED_PIN, OUTPUT);\n  pinMode(BUZZER_PIN, OUTPUT);\n  \n  digitalWrite(LED_PIN, LOW);\n  \n  Serial.println(\"密碼鎖系統啟動\");\n  Serial.println(\"請輸入密碼 (按 # 確認, * 清除)\");\n}\n\nvoid loop() {\n  char key = keypad.getKey();\n  \n  if (key != NO_KEY) {\n    Serial.print(\"按鍵: \");\n    Serial.println(key);\n    \n    if (key == '#') {\n      // 確認密碼\n      checkPassword();\n    } else if (key == '*') {\n      // 清除輸入\n      inputPassword = \"\";\n      Serial.println(\"密碼清除\");\n    } else if (key >= '0' && key <= '9') {\n      // 數字輸入\n      if (inputPassword.length() < 10) {\n        inputPassword += key;\n        Serial.print(\"已輸入: \");\n        for (int i = 0; i < inputPassword.length(); i++) {\n          Serial.print(\"*\");\n        }\n        Serial.println();\n      }\n    }\n  }\n}\n\nvoid checkPassword() {\n  if (inputPassword == correctPassword) {\n    isLocked = false;\n    digitalWrite(LED_PIN, HIGH);\n    Serial.println(\"密碼正確！門鎖已開啟\");\n    \n    // 成功音效\n    tone(BUZZER_PIN, 1000, 200);\n    delay(300);\n    tone(BUZZER_PIN, 1200, 200);\n    \n  } else {\n    Serial.println(\"密碼錯誤！\");\n    \n    // 錯誤音效\n    for (int i = 0; i < 3; i++) {\n      tone(BUZZER_PIN, 300, 200);\n      delay(300);\n    }\n  }\n  \n  inputPassword = \"\";\n}\n```\n\n## 計算器功能\n```cpp\n#include <Keypad.h>\n\nconst byte ROWS = 4;\nconst byte COLS = 4;\n\nchar keys[ROWS][COLS] = {\n  {'1', '2', '3', 'A'},  // A = +\n  {'4', '5', '6', 'B'},  // B = -\n  {'7', '8', '9', 'C'},  // C = *\n  {'*', '0', '#', 'D'}   // D = /, # = =, * = clear\n};\n\nbyte rowPins[ROWS] = {9, 8, 7, 6};\nbyte colPins[COLS] = {5, 4, 3, 2};\n\nKeypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);\n\nfloat firstNumber = 0;\nfloat secondNumber = 0;\nchar operation = ' ';\nString inputString = \"\";\nboolean enteringSecondNumber = false;\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(\"簡易計算器啟動\");\n  Serial.println(\"A=加法, B=減法, C=乘法, D=除法\");\n  Serial.println(\"#=等於, *=清除\");\n}\n\nvoid loop() {\n  char key = keypad.getKey();\n  \n  if (key != NO_KEY) {\n    Serial.print(\"按鍵: \");\n    Serial.println(key);\n    \n    if (key >= '0' && key <= '9') {\n      inputString += key;\n      Serial.print(\"輸入: \");\n      Serial.println(inputString);\n      \n    } else if (key == 'A' || key == 'B' || key == 'C' || key == 'D') {\n      if (inputString != \"\") {\n        firstNumber = inputString.toFloat();\n        operation = key;\n        inputString = \"\";\n        enteringSecondNumber = true;\n        \n        Serial.print(\"第一個數: \");\n        Serial.print(firstNumber);\n        Serial.print(\", 運算: \");\n        Serial.println(getOperationName(operation));\n      }\n      \n    } else if (key == '#') {\n      if (inputString != \"\" && operation != ' ') {\n        secondNumber = inputString.toFloat();\n        calculateResult();\n      }\n      \n    } else if (key == '*') {\n      // 清除\n      firstNumber = 0;\n      secondNumber = 0;\n      operation = ' ';\n      inputString = \"\";\n      enteringSecondNumber = false;\n      Serial.println(\"計算器已清除\");\n    }\n  }\n}\n\nvoid calculateResult() {\n  float result = 0;\n  \n  switch (operation) {\n    case 'A':\n      result = firstNumber + secondNumber;\n      break;\n    case 'B':\n      result = firstNumber - secondNumber;\n      break;\n    case 'C':\n      result = firstNumber * secondNumber;\n      break;\n    case 'D':\n      if (secondNumber != 0) {\n        result = firstNumber / secondNumber;\n      } else {\n        Serial.println(\"錯誤：除以零\");\n        return;\n      }\n      break;\n  }\n  \n  Serial.print(firstNumber);\n  Serial.print(\" \");\n  Serial.print(getOperationSymbol(operation));\n  Serial.print(\" \");\n  Serial.print(secondNumber);\n  Serial.print(\" = \");\n  Serial.println(result);\n  \n  // 重置\n  firstNumber = result;\n  secondNumber = 0;\n  operation = ' ';\n  inputString = \"\";\n  enteringSecondNumber = false;\n}\n\nString getOperationName(char op) {\n  switch (op) {\n    case 'A': return \"加法\";\n    case 'B': return \"減法\";\n    case 'C': return \"乘法\";\n    case 'D': return \"除法\";\n    default: return \"未知\";\n  }\n}\n\nchar getOperationSymbol(char op) {\n  switch (op) {\n    case 'A': return '+';\n    case 'B': return '-';\n    case 'C': return '*';\n    case 'D': return '/';\n    default: return '?';\n  }\n}\n```\n\n## 選單導航系統\n```cpp\n#include <Keypad.h>\n\nconst byte ROWS = 4;\nconst byte COLS = 4;\n\nchar keys[ROWS][COLS] = {\n  {'1', '2', '3', 'A'},\n  {'4', '5', '6', 'B'},\n  {'7', '8', '9', 'C'},\n  {'*', '0', '#', 'D'}\n};\n\nbyte rowPins[ROWS] = {9, 8, 7, 6};\nbyte colPins[COLS] = {5, 4, 3, 2};\n\nKeypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);\n\nint currentMenu = 0;\nint selectedItem = 0;\n\n// 選單結構\nString mainMenu[] = {\"1.系統設定\", \"2.感測器\", \"3.馬達控制\", \"4.退出\"};\nString settingsMenu[] = {\"1.時間設定\", \"2.亮度調整\", \"3.音量設定\", \"4.返回\"};\nString sensorMenu[] = {\"1.溫度感測\", \"2.濕度感測\", \"3.光線感測\", \"4.返回\"};\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(\"=== 選單導航系統 ===\");\n  showMainMenu();\n}\n\nvoid loop() {\n  char key = keypad.getKey();\n  \n  if (key != NO_KEY) {\n    handleKeyPress(key);\n  }\n}\n\nvoid handleKeyPress(char key) {\n  if (key >= '1' && key <= '4') {\n    int selection = key - '0';\n    \n    switch (currentMenu) {\n      case 0: // 主選單\n        handleMainMenu(selection);\n        break;\n      case 1: // 系統設定\n        handleSettingsMenu(selection);\n        break;\n      case 2: // 感測器\n        handleSensorMenu(selection);\n        break;\n    }\n  }\n}\n\nvoid handleMainMenu(int selection) {\n  switch (selection) {\n    case 1:\n      currentMenu = 1;\n      showSettingsMenu();\n      break;\n    case 2:\n      currentMenu = 2;\n      showSensorMenu();\n      break;\n    case 3:\n      Serial.println(\"馬達控制功能啟動...\");\n      break;\n    case 4:\n      Serial.println(\"系統退出\");\n      break;\n  }\n}\n\nvoid handleSettingsMenu(int selection) {\n  switch (selection) {\n    case 1:\n      Serial.println(\"時間設定功能\");\n      break;\n    case 2:\n      Serial.println(\"亮度調整功能\");\n      break;\n    case 3:\n      Serial.println(\"音量設定功能\");\n      break;\n    case 4:\n      currentMenu = 0;\n      showMainMenu();\n      break;\n  }\n}\n\nvoid handleSensorMenu(int selection) {\n  switch (selection) {\n    case 1:\n      Serial.println(\"溫度感測功能\");\n      break;\n    case 2:\n      Serial.println(\"濕度感測功能\");\n      break;\n    case 3:\n      Serial.println(\"光線感測功能\");\n      break;\n    case 4:\n      currentMenu = 0;\n      showMainMenu();\n      break;\n  }\n}\n\nvoid showMainMenu() {\n  Serial.println(\"\\n=== 主選單 ===\");\n  for (int i = 0; i < 4; i++) {\n    Serial.println(mainMenu[i]);\n  }\n}\n\nvoid showSettingsMenu() {\n  Serial.println(\"\\n=== 系統設定 ===\");\n  for (int i = 0; i < 4; i++) {\n    Serial.println(settingsMenu[i]);\n  }\n}\n\nvoid showSensorMenu() {\n  Serial.println(\"\\n=== 感測器選單 ===\");\n  for (int i = 0; i < 4; i++) {\n    Serial.println(sensorMenu[i]);\n  }\n}\n```\n\n## 按鍵事件處理\n```cpp\n#include <Keypad.h>\n\nconst byte ROWS = 4;\nconst byte COLS = 4;\n\nchar keys[ROWS][COLS] = {\n  {'1', '2', '3', 'A'},\n  {'4', '5', '6', 'B'},\n  {'7', '8', '9', 'C'},\n  {'*', '0', '#', 'D'}\n};\n\nbyte rowPins[ROWS] = {9, 8, 7, 6};\nbyte colPins[COLS] = {5, 4, 3, 2};\n\nKeypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(\"按鍵事件處理示範\");\n  \n  // 設定事件監聽\n  keypad.addEventListener(keypadEvent);\n}\n\nvoid loop() {\n  char key = keypad.getKey();\n  // 主循環持續檢查按鍵\n}\n\nvoid keypadEvent(KeypadEvent key) {\n  switch (keypad.getState()) {\n    case PRESSED:\n      Serial.print(\"按下: \");\n      Serial.println(key);\n      handleKeyPressed(key);\n      break;\n      \n    case RELEASED:\n      Serial.print(\"釋放: \");\n      Serial.println(key);\n      break;\n      \n    case HOLD:\n      Serial.print(\"長按: \");\n      Serial.println(key);\n      handleKeyHeld(key);\n      break;\n  }\n}\n\nvoid handleKeyPressed(char key) {\n  // 按鍵按下時的處理\n  if (key >= '1' && key <= '9') {\n    tone(11, 1000, 100);  // 數字鍵音效\n  } else {\n    tone(11, 500, 100);   // 功能鍵音效\n  }\n}\n\nvoid handleKeyHeld(char key) {\n  // 長按處理\n  if (key == '*') {\n    Serial.println(\"執行重置功能\");\n  } else if (key == '#') {\n    Serial.println(\"執行確認功能\");\n  }\n}\n```\n\n## 應用場景\n- **密碼鎖** - 安全門禁系統\n- **計算器** - 簡易數學運算\n- **選單系統** - 設備操作介面\n- **電話撥號** - 通訊設備\n- **遊戲控制** - 數字遊戲輸入\n\n## 技術規格\n- **按鍵數量**: 16 鍵 (4x4 矩陣)\n- **所需腳位**: 8 個數位腳位\n- **按鍵壽命**: >100,000 次\n- **工作電壓**: 3.3V - 5V\n- **材質**: 薄膜開關\n\n## 注意事項\n- 需要安裝 Keypad 函式庫\n- 接線順序要與程式定義一致\n- 避免同時按多個按鍵\n- 長時間按住可能觸發 HOLD 事件\n- 薄膜鍵盤壽命有限，避免用力按壓"
    },
    {
      "id": "arduino-ir-sensor",
      "title": "紅外線感測器",
      "description": "紅外線接收器和遙控器控制",
      "code": "#include <IRremote.h>\n\n#define IR_RECEIVE_PIN 11\n#define LED_PIN 13\n\nboolean ledState = false;\n\nvoid setup() {\n  Serial.begin(9600);\n  IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK);\n  pinMode(LED_PIN, OUTPUT);\n  \n  Serial.println(\"紅外線接收器啟動\");\n  Serial.println(\"請使用遙控器...\");\n}\n\nvoid loop() {\n  if (IrReceiver.decode()) {\n    // 獲取紅外線代碼\n    uint32_t irCode = IrReceiver.decodedIRData.command;\n    \n    Serial.print(\"接收到 IR 代碼: 0x\");\n    Serial.print(irCode, HEX);\n    Serial.print(\", 協定: \");\n    Serial.println(IrReceiver.decodedIRData.protocol);\n    \n    // 處理不同按鍵\n    handleIRCommand(irCode);\n    \n    IrReceiver.resume(); // 準備接收下一個信號\n  }\n}\n\nvoid handleIRCommand(uint32_t command) {\n  switch (command) {\n    case 0x1:  // 遙控器按鍵 1\n      digitalWrite(LED_PIN, HIGH);\n      Serial.println(\"LED 開啟\");\n      break;\n      \n    case 0x2:  // 遙控器按鍵 2\n      digitalWrite(LED_PIN, LOW);\n      Serial.println(\"LED 關閉\");\n      break;\n      \n    case 0x3:  // 遙控器按鍵 3\n      ledState = !ledState;\n      digitalWrite(LED_PIN, ledState);\n      Serial.println(ledState ? \"LED 開啟\" : \"LED 關閉\");\n      break;\n      \n    default:\n      Serial.println(\"未定義的按鍵\");\n      break;\n  }\n}",
      "language": "arduino",
      "topic": "Arduino 感測器與致動器",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["感測器", "紅外線", "遙控器", "IR", "原子式"]
      },
      "documentation": "# 紅外線感測器 (IR)\n\n## 功能說明\n紅外線感測器可以接收遙控器發送的紅外線信號，實現無線遙控功能。\n\n## 工作原理\n- **紅外線載波**: 38kHz 調變信號\n- **數位編碼**: 不同按鍵對應不同編碼\n- **協定解析**: 支援多種 IR 協定 (NEC, Sony, RC5 等)\n- **抗干擾**: 載波調變避免環境光干擾\n\n## 紅外線協定\n### NEC 協定\n- **最常見**: 大部分遙控器使用\n- **數據長度**: 32 位元\n- **載波頻率**: 38kHz\n- **編碼方式**: 脈衝寬度調變\n\n### Sony 協定\n- **索尼設備**: 電視、音響等\n- **數據長度**: 12/15/20 位元\n- **載波頻率**: 40kHz\n\n## 接線說明\n```\nIR 接收器      Arduino Uno\nVCC         →  5V 或 3.3V\nGND         →  GND\nOUT         →  Pin 11 (數位腳位)\n```\n\n## 安裝函式庫\n1. 開啟 Arduino IDE\n2. 工具 → 管理程式庫\n3. 搜尋 \"IRremote\"\n4. 安裝 Arduino-IRremote 函式庫\n\n## 基本接收\n```cpp\n#include <IRremote.h>\n\n#define IR_RECEIVE_PIN 11\n\nvoid setup() {\n  Serial.begin(9600);\n  IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK);\n  \n  Serial.println(\"IR 接收器準備就緒\");\n}\n\nvoid loop() {\n  if (IrReceiver.decode()) {\n    // 獲取接收到的數據\n    uint32_t command = IrReceiver.decodedIRData.command;\n    uint32_t address = IrReceiver.decodedIRData.address;\n    uint8_t protocol = IrReceiver.decodedIRData.protocol;\n    \n    Serial.print(\"協定: \");\n    Serial.print(getProtocolString(protocol));\n    Serial.print(\", 地址: 0x\");\n    Serial.print(address, HEX);\n    Serial.print(\", 指令: 0x\");\n    Serial.println(command, HEX);\n    \n    // 繼續接收\n    IrReceiver.resume();\n  }\n}\n\nconst char* getProtocolString(uint8_t protocol) {\n  switch (protocol) {\n    case NEC: return \"NEC\";\n    case SONY: return \"SONY\";\n    case RC5: return \"RC5\";\n    case RC6: return \"RC6\";\n    default: return \"UNKNOWN\";\n  }\n}\n```\n\n## LED 控制系統\n```cpp\n#include <IRremote.h>\n\n#define IR_RECEIVE_PIN 11\n#define LED_RED 9\n#define LED_GREEN 10\n#define LED_BLUE 6\n\n// 常見遙控器按鍵代碼 (需要根據實際遙控器調整)\n#define IR_POWER  0x807F\n#define IR_1      0x807E\n#define IR_2      0x807D\n#define IR_3      0x807C\n#define IR_UP     0x8077\n#define IR_DOWN   0x8076\n#define IR_LEFT   0x8075\n#define IR_RIGHT  0x8074\n\nboolean systemOn = false;\nint currentColor = 0;\nint brightness = 128;\n\nvoid setup() {\n  Serial.begin(9600);\n  IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK);\n  \n  pinMode(LED_RED, OUTPUT);\n  pinMode(LED_GREEN, OUTPUT);\n  pinMode(LED_BLUE, OUTPUT);\n  \n  Serial.println(\"IR LED 控制系統啟動\");\n  Serial.println(\"電源鍵: 開/關, 數字鍵: 顏色, 方向鍵: 亮度\");\n}\n\nvoid loop() {\n  if (IrReceiver.decode()) {\n    uint32_t command = IrReceiver.decodedIRData.command;\n    \n    Serial.print(\"IR 代碼: 0x\");\n    Serial.println(command, HEX);\n    \n    handleRemoteControl(command);\n    \n    IrReceiver.resume();\n  }\n}\n\nvoid handleRemoteControl(uint32_t command) {\n  switch (command) {\n    case IR_POWER:\n      systemOn = !systemOn;\n      Serial.println(systemOn ? \"系統開啟\" : \"系統關閉\");\n      if (!systemOn) {\n        setAllLEDs(0, 0, 0);\n      } else {\n        updateLEDs();\n      }\n      break;\n      \n    case IR_1:\n      currentColor = 1;  // 紅色\n      Serial.println(\"紅色模式\");\n      updateLEDs();\n      break;\n      \n    case IR_2:\n      currentColor = 2;  // 綠色\n      Serial.println(\"綠色模式\");\n      updateLEDs();\n      break;\n      \n    case IR_3:\n      currentColor = 3;  // 藍色\n      Serial.println(\"藍色模式\");\n      updateLEDs();\n      break;\n      \n    case IR_UP:\n      brightness = min(255, brightness + 25);\n      Serial.print(\"亮度增加: \");\n      Serial.println(brightness);\n      updateLEDs();\n      break;\n      \n    case IR_DOWN:\n      brightness = max(0, brightness - 25);\n      Serial.print(\"亮度減少: \");\n      Serial.println(brightness);\n      updateLEDs();\n      break;\n      \n    default:\n      Serial.println(\"未定義按鍵\");\n      break;\n  }\n}\n\nvoid updateLEDs() {\n  if (!systemOn) {\n    setAllLEDs(0, 0, 0);\n    return;\n  }\n  \n  switch (currentColor) {\n    case 1: // 紅色\n      setAllLEDs(brightness, 0, 0);\n      break;\n    case 2: // 綠色\n      setAllLEDs(0, brightness, 0);\n      break;\n    case 3: // 藍色\n      setAllLEDs(0, 0, brightness);\n      break;\n    default:\n      setAllLEDs(0, 0, 0);\n      break;\n  }\n}\n\nvoid setAllLEDs(int r, int g, int b) {\n  analogWrite(LED_RED, r);\n  analogWrite(LED_GREEN, g);\n  analogWrite(LED_BLUE, b);\n}\n```\n\n## 遙控代碼學習\n```cpp\n#include <IRremote.h>\n\n#define IR_RECEIVE_PIN 11\n#define MAX_CODES 10\n\nstruct IRCode {\n  uint32_t command;\n  String name;\n};\n\nIRCode learnedCodes[MAX_CODES];\nint codeCount = 0;\nboolean learningMode = false;\n\nvoid setup() {\n  Serial.begin(9600);\n  IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK);\n  \n  Serial.println(\"IR 代碼學習系統\");\n  Serial.println(\"指令:\");\n  Serial.println(\"LEARN - 進入學習模式\");\n  Serial.println(\"LIST - 顯示已學習代碼\");\n  Serial.println(\"CLEAR - 清除所有代碼\");\n}\n\nvoid loop() {\n  // 處理序列指令\n  if (Serial.available()) {\n    String command = Serial.readString();\n    command.trim();\n    command.toUpperCase();\n    \n    if (command == \"LEARN\") {\n      startLearning();\n    } else if (command == \"LIST\") {\n      listCodes();\n    } else if (command == \"CLEAR\") {\n      clearCodes();\n    }\n  }\n  \n  // 處理 IR 信號\n  if (IrReceiver.decode()) {\n    uint32_t irCommand = IrReceiver.decodedIRData.command;\n    \n    if (learningMode) {\n      learnCode(irCommand);\n    } else {\n      recognizeCode(irCommand);\n    }\n    \n    IrReceiver.resume();\n  }\n}\n\nvoid startLearning() {\n  if (codeCount >= MAX_CODES) {\n    Serial.println(\"代碼儲存已滿！\");\n    return;\n  }\n  \n  learningMode = true;\n  Serial.print(\"學習模式 - 按下要學習的遙控器按鍵 (\");\n  Serial.print(codeCount + 1);\n  Serial.println(\"/10):\");\n}\n\nvoid learnCode(uint32_t command) {\n  if (command == 0) {\n    Serial.println(\"無效代碼，請重試\");\n    return;\n  }\n  \n  learnedCodes[codeCount].command = command;\n  \n  Serial.print(\"請輸入此按鍵的名稱: \");\n  \n  // 等待序列輸入\n  while (!Serial.available()) {\n    delay(10);\n  }\n  \n  String name = Serial.readString();\n  name.trim();\n  \n  learnedCodes[codeCount].name = name;\n  codeCount++;\n  \n  Serial.print(\"已學習: \");\n  Serial.print(name);\n  Serial.print(\" (0x\");\n  Serial.print(command, HEX);\n  Serial.println(\")\");\n  \n  learningMode = false;\n  \n  if (codeCount < MAX_CODES) {\n    Serial.println(\"輸入 LEARN 繼續學習下一個按鍵\");\n  } else {\n    Serial.println(\"代碼儲存已滿\");\n  }\n}\n\nvoid recognizeCode(uint32_t command) {\n  for (int i = 0; i < codeCount; i++) {\n    if (learnedCodes[i].command == command) {\n      Serial.print(\"識別按鍵: \");\n      Serial.println(learnedCodes[i].name);\n      return;\n    }\n  }\n  \n  Serial.print(\"未知按鍵: 0x\");\n  Serial.println(command, HEX);\n}\n\nvoid listCodes() {\n  Serial.println(\"\\n=== 已學習的代碼 ===\");\n  for (int i = 0; i < codeCount; i++) {\n    Serial.print(i + 1);\n    Serial.print(\". \");\n    Serial.print(learnedCodes[i].name);\n    Serial.print(\" = 0x\");\n    Serial.println(learnedCodes[i].command, HEX);\n  }\n  Serial.println();\n}\n\nvoid clearCodes() {\n  codeCount = 0;\n  Serial.println(\"所有代碼已清除\");\n}\n```\n\n## 紅外線發射\n```cpp\n#include <IRremote.h>\n\n#define IR_SEND_PIN 3\n\nvoid setup() {\n  Serial.begin(9600);\n  IrSender.begin(IR_SEND_PIN, ENABLE_LED_FEEDBACK);\n  \n  Serial.println(\"IR 發射器啟動\");\n  Serial.println(\"指令: SEND [HEX代碼]\");\n}\n\nvoid loop() {\n  if (Serial.available()) {\n    String input = Serial.readString();\n    input.trim();\n    \n    if (input.startsWith(\"SEND \")) {\n      String hexString = input.substring(5);\n      uint32_t code = strtoul(hexString.c_str(), NULL, 16);\n      \n      Serial.print(\"發送 IR 代碼: 0x\");\n      Serial.println(code, HEX);\n      \n      IrSender.sendNEC(0x00, code, 0);  // 地址=0x00\n      \n      Serial.println(\"發送完成\");\n    }\n  }\n  \n  // 自動發送測試\n  static unsigned long lastSend = 0;\n  if (millis() - lastSend > 5000) {\n    IrSender.sendNEC(0x00, 0x12, 0);  // 每 5 秒發送測試信號\n    Serial.println(\"自動發送測試信號\");\n    lastSend = millis();\n  }\n}\n```\n\n## 應用場景\n- **家電控制** - 電視、空調、音響遙控\n- **智慧家居** - 紅外線萬能遙控器\n- **機器人** - 遙控機器人行動\n- **燈光控制** - 無線燈光開關\n- **教學設備** - 互動教學系統\n\n## 技術規格\n- **接收距離**: 通常 8-10 公尺\n- **載波頻率**: 38kHz (最常見)\n- **工作電壓**: 2.7V - 5.5V\n- **工作電流**: 約 3mA\n- **接收角度**: 約 90 度\n\n## 注意事項\n- 需要安裝 IRremote 函式庫\n- 避免強光直射干擾接收\n- 不同品牌遙控器代碼不同\n- 接收距離受環境光影響\n- 發射功率有限，避免長時間連續發射\n- 某些協定可能不相容"
    },
    {
      "id": "arduino-accelerometer",
      "title": "加速度計感測器",
      "description": "MPU6050 三軸加速度和陀螺儀",
      "code": "#include <Wire.h>\n#include <MPU6050.h>\n\nMPU6050 mpu;\n\nvoid setup() {\n  Serial.begin(9600);\n  Wire.begin();\n  \n  Serial.println(\"初始化 MPU6050...\");\n  \n  if (!mpu.begin()) {\n    Serial.println(\"MPU6050 初始化失敗！\");\n    while (1);\n  }\n  \n  mpu.setAccelerometerRange(MPU6050_RANGE_8_G);\n  mpu.setGyroRange(MPU6050_RANGE_500_DEG);\n  mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);\n  \n  Serial.println(\"MPU6050 準備就緒\");\n}\n\nvoid loop() {\n  sensors_event_t a, g, temp;\n  mpu.getEvent(&a, &g, &temp);\n  \n  Serial.print(\"加速度 X: \");\n  Serial.print(a.acceleration.x);\n  Serial.print(\", Y: \");\n  Serial.print(a.acceleration.y);\n  Serial.print(\", Z: \");\n  Serial.print(a.acceleration.z);\n  Serial.println(\" m/s²\");\n  \n  Serial.print(\"陀螺儀 X: \");\n  Serial.print(g.gyro.x);\n  Serial.print(\", Y: \");\n  Serial.print(g.gyro.y);\n  Serial.print(\", Z: \");\n  Serial.print(g.gyro.z);\n  Serial.println(\" rad/s\");\n  \n  Serial.print(\"溫度: \");\n  Serial.print(temp.temperature);\n  Serial.println(\" °C\");\n  \n  Serial.println(\"\");\n  delay(500);\n}",
      "language": "arduino",
      "topic": "Arduino 感測器與致動器",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["感測器", "加速度計", "陀螺儀", "MPU6050", "原子式"]
      },
      "documentation": "# 加速度計感測器 (MPU6050)\n\n## 功能說明\nMPU6050 是一個 6 軸慣性測量單元，包含 3 軸加速度計和 3 軸陀螺儀，常用於運動檢測和姿態感測。\n\n## 工作原理\n- **加速度計**: 測量線性加速度 (重力、運動)\n- **陀螺儀**: 測量角速度 (旋轉)\n- **MEMS 技術**: 微機電系統感測\n- **數位輸出**: I2C 通訊協定\n\n## 技術規格\n- **加速度範圍**: ±2g, ±4g, ±8g, ±16g\n- **陀螺儀範圍**: ±250°/s, ±500°/s, ±1000°/s, ±2000°/s\n- **工作電壓**: 2.375V - 3.46V\n- **通訊介面**: I2C (地址 0x68 或 0x69)\n- **內建溫度感測**: -40°C 到 +85°C\n\n## 接線說明\n```\nMPU6050       Arduino Uno\nVCC        →  3.3V 或 5V\nGND        →  GND\nSCL        →  Pin A5 (SCL)\nSDA        →  Pin A4 (SDA)\nAD0        →  GND (地址選擇)\n```\n\n## 安裝函式庫\n1. 開啟 Arduino IDE\n2. 工具 → 管理程式庫\n3. 搜尋 \"Adafruit MPU6050\"\n4. 安裝 Adafruit MPU6050 library\n5. 同時安裝相依的函式庫\n\n## 基本讀取\n```cpp\n#include <Adafruit_MPU6050.h>\n#include <Adafruit_Sensor.h>\n#include <Wire.h>\n\nAdafruit_MPU6050 mpu;\n\nvoid setup() {\n  Serial.begin(9600);\n  \n  if (!mpu.begin()) {\n    Serial.println(\"MPU6050 連接失敗\");\n    while (1) {\n      delay(10);\n    }\n  }\n  \n  Serial.println(\"MPU6050 初始化成功\");\n}\n\nvoid loop() {\n  sensors_event_t a, g, temp;\n  mpu.getEvent(&a, &g, &temp);\n  \n  Serial.print(\"加速度 X: \");\n  Serial.print(a.acceleration.x);\n  Serial.print(\", Y: \");\n  Serial.print(a.acceleration.y);\n  Serial.print(\", Z: \");\n  Serial.print(a.acceleration.z);\n  Serial.println(\" m/s²\");\n  \n  delay(500);\n}\n```\n\n## 傾斜角度計算\n```cpp\n#include <Adafruit_MPU6050.h>\n#include <Adafruit_Sensor.h>\n#include <Wire.h>\n#include <math.h>\n\nAdafruit_MPU6050 mpu;\n\nvoid setup() {\n  Serial.begin(9600);\n  mpu.begin();\n  \n  Serial.println(\"傾斜角度計\");\n}\n\nvoid loop() {\n  sensors_event_t a, g, temp;\n  mpu.getEvent(&a, &g, &temp);\n  \n  // 計算傾斜角度\n  float pitch = atan2(a.acceleration.y, \n                     sqrt(a.acceleration.x * a.acceleration.x + \n                          a.acceleration.z * a.acceleration.z)) * 180.0 / PI;\n  \n  float roll = atan2(-a.acceleration.x, a.acceleration.z) * 180.0 / PI;\n  \n  Serial.print(\"俯仰角 (Pitch): \");\n  Serial.print(pitch);\n  Serial.print(\"°, 翻滾角 (Roll): \");\n  Serial.print(roll);\n  Serial.println(\"°\");\n  \n  delay(100);\n}\n```\n\n## 運動檢測\n```cpp\n#include <Adafruit_MPU6050.h>\n#include <Adafruit_Sensor.h>\n#include <Wire.h>\n\nAdafruit_MPU6050 mpu;\n\nfloat baselineX, baselineY, baselineZ;\nfloat motionThreshold = 2.0;  // 運動門檻值\nboolean motionDetected = false;\n\nvoid setup() {\n  Serial.begin(9600);\n  mpu.begin();\n  \n  // 校準基準值\n  Serial.println(\"校準中...請保持靜止\");\n  calibrateBaseline();\n  Serial.println(\"校準完成，開始運動檢測\");\n}\n\nvoid loop() {\n  sensors_event_t a, g, temp;\n  mpu.getEvent(&a, &g, &temp);\n  \n  // 計算與基準值的差異\n  float deltaX = abs(a.acceleration.x - baselineX);\n  float deltaY = abs(a.acceleration.y - baselineY);\n  float deltaZ = abs(a.acceleration.z - baselineZ);\n  \n  float totalMotion = sqrt(deltaX*deltaX + deltaY*deltaY + deltaZ*deltaZ);\n  \n  if (totalMotion > motionThreshold) {\n    if (!motionDetected) {\n      Serial.println(\"偵測到運動！\");\n      motionDetected = true;\n    }\n  } else {\n    if (motionDetected) {\n      Serial.println(\"運動停止\");\n      motionDetected = false;\n    }\n  }\n  \n  Serial.print(\"運動強度: \");\n  Serial.println(totalMotion);\n  \n  delay(100);\n}\n\nvoid calibrateBaseline() {\n  float sumX = 0, sumY = 0, sumZ = 0;\n  int samples = 100;\n  \n  for (int i = 0; i < samples; i++) {\n    sensors_event_t a, g, temp;\n    mpu.getEvent(&a, &g, &temp);\n    \n    sumX += a.acceleration.x;\n    sumY += a.acceleration.y;\n    sumZ += a.acceleration.z;\n    \n    delay(50);\n  }\n  \n  baselineX = sumX / samples;\n  baselineY = sumY / samples;\n  baselineZ = sumZ / samples;\n  \n  Serial.print(\"基準值 - X: \");\n  Serial.print(baselineX);\n  Serial.print(\", Y: \");\n  Serial.print(baselineY);\n  Serial.print(\", Z: \");\n  Serial.println(baselineZ);\n}\n```\n\n## 步數計算器\n```cpp\n#include <Adafruit_MPU6050.h>\n#include <Adafruit_Sensor.h>\n#include <Wire.h>\n\nAdafruit_MPU6050 mpu;\n\nint stepCount = 0;\nfloat lastAcceleration = 0;\nfloat stepThreshold = 1.5;\nboolean stepDetected = false;\nunsigned long lastStepTime = 0;\nconst unsigned long stepCooldown = 300;  // 步數間隔時間 (毫秒)\n\nvoid setup() {\n  Serial.begin(9600);\n  mpu.begin();\n  \n  Serial.println(\"步數計算器啟動\");\n  Serial.println(\"開始走路來測試...\");\n}\n\nvoid loop() {\n  sensors_event_t a, g, temp;\n  mpu.getEvent(&a, &g, &temp);\n  \n  // 計算總加速度\n  float totalAccel = sqrt(a.acceleration.x * a.acceleration.x +\n                         a.acceleration.y * a.acceleration.y +\n                         a.acceleration.z * a.acceleration.z);\n  \n  // 步數檢測邏輯\n  if (totalAccel > stepThreshold && !stepDetected) {\n    unsigned long currentTime = millis();\n    \n    // 檢查步數間隔時間\n    if (currentTime - lastStepTime > stepCooldown) {\n      stepCount++;\n      stepDetected = true;\n      lastStepTime = currentTime;\n      \n      Serial.print(\"步數: \");\n      Serial.println(stepCount);\n    }\n  }\n  \n  // 重置步數檢測\n  if (totalAccel < stepThreshold && stepDetected) {\n    stepDetected = false;\n  }\n  \n  lastAcceleration = totalAccel;\n  delay(50);\n}\n```\n\n## 振動警報器\n```cpp\n#include <Adafruit_MPU6050.h>\n#include <Adafruit_Sensor.h>\n#include <Wire.h>\n\nAdafruit_MPU6050 mpu;\n\n#define BUZZER_PIN 8\n#define LED_PIN 13\n\nfloat vibrationThreshold = 15.0;\nboolean alarmActive = false;\nunsigned long alarmStartTime = 0;\nconst unsigned long alarmDuration = 5000;  // 5 秒警報\n\nvoid setup() {\n  Serial.begin(9600);\n  mpu.begin();\n  \n  pinMode(BUZZER_PIN, OUTPUT);\n  pinMode(LED_PIN, OUTPUT);\n  \n  Serial.println(\"振動警報器啟動\");\n}\n\nvoid loop() {\n  sensors_event_t a, g, temp;\n  mpu.getEvent(&a, &g, &temp);\n  \n  // 計算振動強度\n  float vibration = sqrt(a.acceleration.x * a.acceleration.x +\n                        a.acceleration.y * a.acceleration.y +\n                        a.acceleration.z * a.acceleration.z);\n  \n  // 檢測異常振動\n  if (vibration > vibrationThreshold && !alarmActive) {\n    alarmActive = true;\n    alarmStartTime = millis();\n    \n    Serial.print(\"振動警報！強度: \");\n    Serial.println(vibration);\n  }\n  \n  // 處理警報\n  if (alarmActive) {\n    unsigned long currentTime = millis();\n    \n    if (currentTime - alarmStartTime < alarmDuration) {\n      // 閃爍和蜂鳴\n      boolean flashState = (currentTime / 200) % 2;\n      digitalWrite(LED_PIN, flashState);\n      \n      if (flashState) {\n        tone(BUZZER_PIN, 1000, 100);\n      }\n    } else {\n      // 關閉警報\n      alarmActive = false;\n      digitalWrite(LED_PIN, LOW);\n      noTone(BUZZER_PIN);\n      Serial.println(\"警報結束\");\n    }\n  }\n  \n  delay(50);\n}\n```\n\n## 手勢識別\n```cpp\n#include <Adafruit_MPU6050.h>\n#include <Adafruit_Sensor.h>\n#include <Wire.h>\n\nAdafruit_MPU6050 mpu;\n\nfloat gestureThreshold = 8.0;\nboolean gestureInProgress = false;\nfloat maxX = 0, maxY = 0, maxZ = 0;\nunsigned long gestureStartTime = 0;\nconst unsigned long gestureTimeout = 1000;\n\nvoid setup() {\n  Serial.begin(9600);\n  mpu.begin();\n  \n  Serial.println(\"手勢識別系統\");\n  Serial.println(\"嘗試左右、上下搖擺...\");\n}\n\nvoid loop() {\n  sensors_event_t a, g, temp;\n  mpu.getEvent(&a, &g, &temp);\n  \n  float accelX = abs(a.acceleration.x);\n  float accelY = abs(a.acceleration.y);\n  float accelZ = abs(a.acceleration.z);\n  \n  // 開始手勢檢測\n  if ((accelX > gestureThreshold || accelY > gestureThreshold) && !gestureInProgress) {\n    gestureInProgress = true;\n    gestureStartTime = millis();\n    maxX = accelX;\n    maxY = accelY;\n    maxZ = accelZ;\n  }\n  \n  // 記錄手勢過程中的最大值\n  if (gestureInProgress) {\n    if (accelX > maxX) maxX = accelX;\n    if (accelY > maxY) maxY = accelY;\n    if (accelZ > maxZ) maxZ = accelZ;\n    \n    // 手勢結束檢測\n    if (millis() - gestureStartTime > gestureTimeout ||\n        (accelX < gestureThreshold && accelY < gestureThreshold)) {\n      \n      // 分析手勢\n      analyzeGesture();\n      \n      // 重置\n      gestureInProgress = false;\n      maxX = maxY = maxZ = 0;\n    }\n  }\n  \n  delay(50);\n}\n\nvoid analyzeGesture() {\n  Serial.print(\"手勢分析 - 最大值 X: \");\n  Serial.print(maxX);\n  Serial.print(\", Y: \");\n  Serial.print(maxY);\n  Serial.print(\", Z: \");\n  Serial.println(maxZ);\n  \n  if (maxX > maxY && maxX > maxZ) {\n    Serial.println(\"識別手勢: 左右搖擺\");\n  } else if (maxY > maxX && maxY > maxZ) {\n    Serial.println(\"識別手勢: 上下搖擺\");\n  } else if (maxZ > maxX && maxZ > maxY) {\n    Serial.println(\"識別手勢: 前後搖擺\");\n  } else {\n    Serial.println(\"手勢不明確\");\n  }\n  \n  Serial.println(\"---\");\n}\n```\n\n## 應用場景\n- **運動追蹤** - 健身和運動監測\n- **手勢控制** - 無接觸式操作界面\n- **防盜系統** - 振動和移動偵測\n- **遊戲控制** - 體感遊戲輸入\n- **機器人平衡** - 自平衡機器人\n\n## 注意事項\n- 需要安裝 Adafruit MPU6050 函式庫\n- I2C 接線要正確，注意 SDA/SCL\n- 感測器需要校準以獲得準確數據\n- 溫度會影響感測器精度\n- 避免強烈振動影響讀數\n- 電源噪音可能影響測量結果"
    },
    {
      "id": "arduino-sound-sensor",
      "title": "聲音感測器",
      "description": "麥克風模組聲音檢測",
      "code": "#define SOUND_PIN A0\n#define LED_PIN 13\n\nint soundThreshold = 100;\nint maxSound = 0;\nint soundLevel = 0;\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(LED_PIN, OUTPUT);\n  pinMode(SOUND_PIN, INPUT);\n  \n  Serial.println(\"聲音感測器啟動\");\n  Serial.println(\"聲音門檻值: \" + String(soundThreshold));\n}\n\nvoid loop() {\n  soundLevel = analogRead(SOUND_PIN);\n  \n  // 記錄最大聲音值\n  if (soundLevel > maxSound) {\n    maxSound = soundLevel;\n  }\n  \n  Serial.print(\"聲音強度: \");\n  Serial.print(soundLevel);\n  Serial.print(\", 最大值: \");\n  Serial.println(maxSound);\n  \n  // 聲音觸發 LED\n  if (soundLevel > soundThreshold) {\n    digitalWrite(LED_PIN, HIGH);\n    Serial.println(\"聲音觸發！\");\n  } else {\n    digitalWrite(LED_PIN, LOW);\n  }\n  \n  delay(50);\n}",
      "language": "arduino",
      "topic": "Arduino 感測器與致動器",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["感測器", "聲音", "麥克風", "音量檢測", "原子式"]
      },
      "documentation": "# 聲音感測器\n\n## 功能說明\n聲音感測器透過麥克風檢測環境中的聲音強度，常用於聲控開關、音量監測和噪音檢測。\n\n## 工作原理\n- **麥克風拾音**: 將聲波轉換為電信號\n- **放大電路**: 增強微弱的音頻信號\n- **類比輸出**: 輸出與聲音強度對應的電壓\n- **數位輸出**: 超過門檻值時輸出高電位\n\n## 模組類型\n### 基本聲音感測器\n- **只有類比輸出**: 連續的聲音強度值\n- **靈敏度固定**: 無法調節\n- **價格便宜**: 適合基本應用\n\n### 進階聲音感測器\n- **雙輸出**: 類比 + 數位輸出\n- **可調靈敏度**: 旋鈕調節觸發門檻\n- **LED 指示**: 聲音觸發時點亮\n\n## 接線說明\n```\n聲音感測器     Arduino Uno\nVCC         →  5V\nGND         →  GND\nAO (類比)   →  Pin A0\nDO (數位)   →  Pin 2 (可選)\n```\n\n## 基本聲音檢測\n```cpp\n#define SOUND_PIN A0\n#define LED_PIN 13\n\nint threshold = 150;\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(LED_PIN, OUTPUT);\n  Serial.println(\"聲音檢測器啟動\");\n}\n\nvoid loop() {\n  int soundValue = analogRead(SOUND_PIN);\n  \n  Serial.print(\"聲音值: \");\n  Serial.println(soundValue);\n  \n  if (soundValue > threshold) {\n    digitalWrite(LED_PIN, HIGH);\n    Serial.println(\"偵測到聲音！\");\n    delay(500);\n  } else {\n    digitalWrite(LED_PIN, LOW);\n  }\n  \n  delay(100);\n}\n```\n\n## 聲控開關\n```cpp\n#define SOUND_PIN A0\n#define RELAY_PIN 7\n#define LED_PIN 13\n\nint soundThreshold = 200;\nboolean deviceState = false;\nboolean lastSoundState = false;\nunsigned long lastTriggerTime = 0;\nconst unsigned long debounceDelay = 1000;  // 防彈跳延遲\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(RELAY_PIN, OUTPUT);\n  pinMode(LED_PIN, OUTPUT);\n  \n  digitalWrite(RELAY_PIN, LOW);\n  Serial.println(\"聲控開關系統啟動\");\n  Serial.println(\"拍手或發出聲音來控制...\");\n}\n\nvoid loop() {\n  int soundValue = analogRead(SOUND_PIN);\n  boolean soundDetected = soundValue > soundThreshold;\n  \n  // 檢測聲音觸發事件\n  if (soundDetected && !lastSoundState) {\n    unsigned long currentTime = millis();\n    \n    if (currentTime - lastTriggerTime > debounceDelay) {\n      deviceState = !deviceState;\n      digitalWrite(RELAY_PIN, deviceState);\n      digitalWrite(LED_PIN, deviceState);\n      \n      Serial.print(\"設備 \");\n      Serial.println(deviceState ? \"開啟\" : \"關閉\");\n      \n      lastTriggerTime = currentTime;\n    }\n  }\n  \n  lastSoundState = soundDetected;\n  delay(50);\n}\n```\n\n## 音量監測器\n```cpp\n#define SOUND_PIN A0\n#define NUM_LEDS 5\n\nint ledPins[NUM_LEDS] = {8, 9, 10, 11, 12};\nint soundLevels[NUM_LEDS] = {100, 200, 300, 400, 500};\n\nvoid setup() {\n  Serial.begin(9600);\n  \n  for (int i = 0; i < NUM_LEDS; i++) {\n    pinMode(ledPins[i], OUTPUT);\n  }\n  \n  Serial.println(\"音量監測器啟動\");\n}\n\nvoid loop() {\n  int soundValue = analogRead(SOUND_PIN);\n  \n  Serial.print(\"音量: \");\n  Serial.println(soundValue);\n  \n  // 控制 LED 條\n  for (int i = 0; i < NUM_LEDS; i++) {\n    if (soundValue > soundLevels[i]) {\n      digitalWrite(ledPins[i], HIGH);\n    } else {\n      digitalWrite(ledPins[i], LOW);\n    }\n  }\n  \n  delay(50);\n}\n```\n\n## 噪音警報器\n```cpp\n#define SOUND_PIN A0\n#define BUZZER_PIN 8\n#define LED_PIN 13\n\nint noiseThreshold = 300;\nint alarmDuration = 5000;  // 5 秒警報\nboolean alarmActive = false;\nunsigned long alarmStartTime = 0;\nint noiseLevelCount = 0;\nconst int noiseCountThreshold = 10;  // 連續檢測次數\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(BUZZER_PIN, OUTPUT);\n  pinMode(LED_PIN, OUTPUT);\n  \n  Serial.println(\"噪音警報器啟動\");\n  Serial.print(\"噪音門檻: \");\n  Serial.println(noiseThreshold);\n}\n\nvoid loop() {\n  int soundValue = analogRead(SOUND_PIN);\n  \n  // 連續噪音檢測\n  if (soundValue > noiseThreshold) {\n    noiseLevelCount++;\n  } else {\n    noiseLevelCount = 0;\n  }\n  \n  // 觸發警報\n  if (noiseLevelCount >= noiseCountThreshold && !alarmActive) {\n    alarmActive = true;\n    alarmStartTime = millis();\n    \n    Serial.println(\"噪音警報觸發！\");\n    Serial.print(\"音量: \");\n    Serial.println(soundValue);\n  }\n  \n  // 處理警報\n  if (alarmActive) {\n    unsigned long currentTime = millis();\n    \n    if (currentTime - alarmStartTime < alarmDuration) {\n      // 警報音效和閃爍\n      boolean flashState = (currentTime / 200) % 2;\n      digitalWrite(LED_PIN, flashState);\n      \n      if (flashState) {\n        tone(BUZZER_PIN, 1500, 100);\n      }\n    } else {\n      // 關閉警報\n      alarmActive = false;\n      digitalWrite(LED_PIN, LOW);\n      noTone(BUZZER_PIN);\n      noiseLevelCount = 0;\n      Serial.println(\"警報結束\");\n    }\n  }\n  \n  delay(100);\n}\n```\n\n## 拍手計數器\n```cpp\n#define SOUND_PIN A0\n#define LED_PIN 13\n\nint clapThreshold = 250;\nint clapCount = 0;\nboolean lastClapState = false;\nunsigned long lastClapTime = 0;\nconst unsigned long clapInterval = 300;  // 拍手間隔時間\nconst unsigned long resetTime = 5000;    // 重置時間\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(LED_PIN, OUTPUT);\n  \n  Serial.println(\"拍手計數器啟動\");\n  Serial.println(\"請拍手測試...\");\n}\n\nvoid loop() {\n  int soundValue = analogRead(SOUND_PIN);\n  boolean clapDetected = soundValue > clapThreshold;\n  unsigned long currentTime = millis();\n  \n  // 拍手檢測\n  if (clapDetected && !lastClapState) {\n    if (currentTime - lastClapTime > clapInterval) {\n      clapCount++;\n      lastClapTime = currentTime;\n      \n      Serial.print(\"拍手 #\");\n      Serial.print(clapCount);\n      Serial.print(\", 音量: \");\n      Serial.println(soundValue);\n      \n      // LED 閃爍確認\n      digitalWrite(LED_PIN, HIGH);\n      delay(100);\n      digitalWrite(LED_PIN, LOW);\n      \n      // 特殊拍手模式\n      checkClapPattern();\n    }\n  }\n  \n  // 重置計數器\n  if (currentTime - lastClapTime > resetTime && clapCount > 0) {\n    Serial.println(\"計數器重置\");\n    clapCount = 0;\n  }\n  \n  lastClapState = clapDetected;\n  delay(50);\n}\n\nvoid checkClapPattern() {\n  switch (clapCount) {\n    case 2:\n      Serial.println(\"兩聲拍手 - 功能 A\");\n      blinkLED(2);\n      break;\n    case 3:\n      Serial.println(\"三聲拍手 - 功能 B\");\n      blinkLED(3);\n      break;\n    case 5:\n      Serial.println(\"五聲拍手 - 特殊功能！\");\n      blinkLED(5);\n      // 可以在這裡加入特殊功能\n      clapCount = 0;  // 重置\n      break;\n  }\n}\n\nvoid blinkLED(int times) {\n  for (int i = 0; i < times; i++) {\n    digitalWrite(LED_PIN, HIGH);\n    delay(150);\n    digitalWrite(LED_PIN, LOW);\n    delay(150);\n  }\n}\n```\n\n## 環境音量記錄器\n```cpp\n#define SOUND_PIN A0\n\nint soundReadings[60];  // 60 秒的記錄\nint readingIndex = 0;\nint totalReadings = 0;\nlong soundSum = 0;\nboolean arrayFilled = false;\n\nvoid setup() {\n  Serial.begin(9600);\n  \n  // 初始化陣列\n  for (int i = 0; i < 60; i++) {\n    soundReadings[i] = 0;\n  }\n  \n  Serial.println(\"環境音量記錄器啟動\");\n  Serial.println(\"每秒記錄一次音量...\");\n}\n\nvoid loop() {\n  int soundValue = analogRead(SOUND_PIN);\n  \n  // 移除舊的讀數\n  soundSum -= soundReadings[readingIndex];\n  \n  // 加入新的讀數\n  soundReadings[readingIndex] = soundValue;\n  soundSum += soundValue;\n  \n  // 移動索引\n  readingIndex = (readingIndex + 1) % 60;\n  \n  if (!arrayFilled && readingIndex == 0) {\n    arrayFilled = true;\n  }\n  \n  // 計算平均值\n  int samples = arrayFilled ? 60 : readingIndex + 1;\n  int averageSound = soundSum / samples;\n  \n  // 找出最大值和最小值\n  int maxSound = 0;\n  int minSound = 1023;\n  \n  for (int i = 0; i < samples; i++) {\n    if (soundReadings[i] > maxSound) maxSound = soundReadings[i];\n    if (soundReadings[i] < minSound) minSound = soundReadings[i];\n  }\n  \n  Serial.print(\"目前: \");\n  Serial.print(soundValue);\n  Serial.print(\", 平均: \");\n  Serial.print(averageSound);\n  Serial.print(\", 最大: \");\n  Serial.print(maxSound);\n  Serial.print(\", 最小: \");\n  Serial.println(minSound);\n  \n  delay(1000);  // 每秒記錄一次\n}\n```\n\n## 應用場景\n- **聲控開關** - 拍手或語音控制燈具\n- **安全監控** - 異常聲音檢測\n- **噪音監測** - 環境噪音量測\n- **互動裝置** - 聲音觸發的藝術品\n- **音樂同步** - 跟隨音樂節拍的燈效\n\n## 技術規格\n- **工作電壓**: 3.3V - 5V\n- **輸出範圍**: 0V - VCC\n- **頻率響應**: 20Hz - 20kHz\n- **靈敏度**: 可調節 (進階模組)\n- **反應時間**: <1ms\n\n## 注意事項\n- 環境噪音會影響基準值\n- 麥克風方向影響靈敏度\n- 需要適當的觸發門檻值\n- 避免電源噪音干擾\n- 長期使用建議定期校準\n- 強烈聲音可能損壞感測器"
    },
    {
      "id": "arduino-soil-moisture",
      "title": "土壤濕度感測器",
      "description": "電阻式土壤水分檢測",
      "code": "#define SOIL_PIN A0\n#define PUMP_PIN 7\n#define LED_PIN 13\n\nint dryThreshold = 300;    // 乾燥門檻\nint wetThreshold = 600;    // 濕潤門檻\nboolean pumpActive = false;\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(PUMP_PIN, OUTPUT);\n  pinMode(LED_PIN, OUTPUT);\n  \n  digitalWrite(PUMP_PIN, LOW);\n  Serial.println(\"自動澆水系統啟動\");\n  Serial.println(\"監測土壤濕度中...\");\n}\n\nvoid loop() {\n  int soilValue = analogRead(SOIL_PIN);\n  \n  // 轉換為濕度百分比 (需要校準)\n  int moisturePercent = map(soilValue, 0, 1023, 100, 0);\n  \n  Serial.print(\"土壤濕度: \");\n  Serial.print(moisturePercent);\n  Serial.print(\"%  (原始值: \");\n  Serial.print(soilValue);\n  Serial.println(\")\");\n  \n  // 自動澆水邏輯\n  if (soilValue < dryThreshold && !pumpActive) {\n    // 土壤太乾，開始澆水\n    digitalWrite(PUMP_PIN, HIGH);\n    digitalWrite(LED_PIN, HIGH);\n    pumpActive = true;\n    Serial.println(\"啟動澆水！\");\n  } else if (soilValue > wetThreshold && pumpActive) {\n    // 土壤足夠濕潤，停止澆水\n    digitalWrite(PUMP_PIN, LOW);\n    digitalWrite(LED_PIN, LOW);\n    pumpActive = false;\n    Serial.println(\"停止澆水\");\n  }\n  \n  // 顯示狀態\n  if (pumpActive) {\n    Serial.println(\"狀態: 澆水中...\");\n  } else if (soilValue > wetThreshold) {\n    Serial.println(\"狀態: 濕度足夠\");\n  } else {\n    Serial.println(\"狀態: 監測中\");\n  }\n  \n  delay(1000);\n}",
      "language": "arduino",
      "topic": "Arduino 感測器與致動器",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["感測器", "土壤", "濕度", "農業", "自動澆水", "原子式"]
      },
      "documentation": "# 土壤濕度感測器\n\n## 功能說明\n土壤濕度感測器透過測量土壤的電阻值來判斷土壤的水分含量，常用於自動澆水系統和農業監測。\n\n## 工作原理\n- **電阻測量**: 土壤水分影響導電性\n- **濕度高**: 電阻低，輸出電壓低\n- **濕度低**: 電阻高，輸出電壓高\n- **類比輸出**: 連續的濕度值\n\n## 感測器類型\n### 電阻式感測器\n- **兩個探針**: 測量土壤電阻\n- **價格便宜**: 成本低\n- **會腐蝕**: 長期使用探針會氧化\n- **準確度**: 中等\n\n### 電容式感測器\n- **非接觸式**: 不會腐蝕\n- **更穩定**: 長期使用精度更好\n- **價格較高**: 但壽命更長\n- **抗干擾**: 較不受鹽分影響\n\n## 接線說明\n```\n土壤濕度感測器   Arduino Uno\nVCC          →  5V\nGND          →  GND\nAO (類比)    →  Pin A0\nDO (數位)    →  Pin 2 (可選)\n```\n\n## 基本濕度檢測\n```cpp\n#define SOIL_PIN A0\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(\"土壤濕度監測器\");\n}\n\nvoid loop() {\n  int soilValue = analogRead(SOIL_PIN);\n  \n  // 轉換為百分比 (需要根據實際情況校準)\n  int moisturePercent = map(soilValue, 0, 1023, 100, 0);\n  \n  Serial.print(\"土壤濕度: \");\n  Serial.print(moisturePercent);\n  Serial.print(\"%  (ADC: \");\n  Serial.print(soilValue);\n  Serial.println(\")\");\n  \n  // 濕度等級判斷\n  if (moisturePercent > 70) {\n    Serial.println(\"狀態: 非常濕潤\");\n  } else if (moisturePercent > 40) {\n    Serial.println(\"狀態: 適中\");\n  } else if (moisturePercent > 20) {\n    Serial.println(\"狀態: 乾燥\");\n  } else {\n    Serial.println(\"狀態: 非常乾燥\");\n  }\n  \n  delay(2000);\n}\n```\n\n## 校準程序\n```cpp\n#define SOIL_PIN A0\n\nint airValue = 0;     // 空氣中的讀數\nint waterValue = 0;   // 水中的讀數\nboolean calibrated = false;\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(\"土壤濕度感測器校準\");\n  calibrateSensor();\n}\n\nvoid loop() {\n  if (calibrated) {\n    int soilValue = analogRead(SOIL_PIN);\n    \n    // 使用校準值計算濕度百分比\n    int moisturePercent = map(soilValue, airValue, waterValue, 0, 100);\n    moisturePercent = constrain(moisturePercent, 0, 100);\n    \n    Serial.print(\"校準後濕度: \");\n    Serial.print(moisturePercent);\n    Serial.println(\"%\");\n  }\n  \n  delay(1000);\n}\n\nvoid calibrateSensor() {\n  Serial.println(\"開始校準...\");\n  \n  // 空氣校準\n  Serial.println(\"步驟1: 請將感測器放在空氣中，10秒後開始測量\");\n  delay(10000);\n  \n  long airSum = 0;\n  for (int i = 0; i < 100; i++) {\n    airSum += analogRead(SOIL_PIN);\n    delay(50);\n  }\n  airValue = airSum / 100;\n  \n  Serial.print(\"空氣值: \");\n  Serial.println(airValue);\n  \n  // 水中校準\n  Serial.println(\"步驟2: 請將感測器完全放入水中，10秒後開始測量\");\n  delay(10000);\n  \n  long waterSum = 0;\n  for (int i = 0; i < 100; i++) {\n    waterSum += analogRead(SOIL_PIN);\n    delay(50);\n  }\n  waterValue = waterSum / 100;\n  \n  Serial.print(\"水中值: \");\n  Serial.println(waterValue);\n  \n  if (airValue > waterValue) {\n    calibrated = true;\n    Serial.println(\"校準完成！\");\n  } else {\n    Serial.println(\"校準失敗，請重新校準\");\n  }\n}\n```\n\n## 智慧澆水系統\n```cpp\n#define SOIL_PIN A0\n#define PUMP_PIN 7\n#define BUZZER_PIN 8\n#define LED_GREEN 9\n#define LED_RED 10\n\nint dryThreshold = 30;     // 乾燥門檻 (%)\nint wetThreshold = 70;     // 濕潤門檻 (%)\nint wateringDuration = 5000; // 澆水持續時間 (毫秒)\n\nboolean isWatering = false;\nunsigned long wateringStartTime = 0;\nint airValue = 850;        // 校準值 (空氣)\nint waterValue = 400;      // 校準值 (水)\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(PUMP_PIN, OUTPUT);\n  pinMode(BUZZER_PIN, OUTPUT);\n  pinMode(LED_GREEN, OUTPUT);\n  pinMode(LED_RED, OUTPUT);\n  \n  digitalWrite(PUMP_PIN, LOW);\n  Serial.println(\"智慧澆水系統啟動\");\n}\n\nvoid loop() {\n  int soilValue = analogRead(SOIL_PIN);\n  int moisturePercent = map(soilValue, airValue, waterValue, 0, 100);\n  moisturePercent = constrain(moisturePercent, 0, 100);\n  \n  Serial.print(\"土壤濕度: \");\n  Serial.print(moisturePercent);\n  Serial.println(\"%\");\n  \n  // 澆水邏輯\n  if (!isWatering) {\n    if (moisturePercent < dryThreshold) {\n      startWatering();\n    } else if (moisturePercent > wetThreshold) {\n      // 濕度充足\n      digitalWrite(LED_GREEN, HIGH);\n      digitalWrite(LED_RED, LOW);\n    } else {\n      // 濕度適中\n      digitalWrite(LED_GREEN, LOW);\n      digitalWrite(LED_RED, LOW);\n    }\n  } else {\n    // 正在澆水\n    unsigned long currentTime = millis();\n    \n    if (currentTime - wateringStartTime >= wateringDuration || \n        moisturePercent >= wetThreshold) {\n      stopWatering();\n    }\n  }\n  \n  delay(1000);\n}\n\nvoid startWatering() {\n  isWatering = true;\n  wateringStartTime = millis();\n  \n  digitalWrite(PUMP_PIN, HIGH);\n  digitalWrite(LED_RED, HIGH);\n  digitalWrite(LED_GREEN, LOW);\n  \n  // 澆水提示音\n  for (int i = 0; i < 3; i++) {\n    tone(BUZZER_PIN, 1000, 200);\n    delay(300);\n  }\n  \n  Serial.println(\"開始澆水...\");\n}\n\nvoid stopWatering() {\n  isWatering = false;\n  \n  digitalWrite(PUMP_PIN, LOW);\n  digitalWrite(LED_RED, LOW);\n  \n  // 完成提示音\n  tone(BUZZER_PIN, 1500, 500);\n  \n  Serial.println(\"澆水完成\");\n}\n```\n\n## 多點監測系統\n```cpp\n#define NUM_SENSORS 3\n\nint soilPins[NUM_SENSORS] = {A0, A1, A2};\nint pumpPins[NUM_SENSORS] = {7, 8, 9};\nString sensorNames[NUM_SENSORS] = {\"花盆1\", \"花盆2\", \"花盆3\"};\n\nint dryThreshold = 30;\nint airValue = 850;\nint waterValue = 400;\n\nvoid setup() {\n  Serial.begin(9600);\n  \n  for (int i = 0; i < NUM_SENSORS; i++) {\n    pinMode(pumpPins[i], OUTPUT);\n    digitalWrite(pumpPins[i], LOW);\n  }\n  \n  Serial.println(\"多點土壤監測系統啟動\");\n}\n\nvoid loop() {\n  Serial.println(\"=== 土壤濕度監測 ===\");\n  \n  for (int i = 0; i < NUM_SENSORS; i++) {\n    int soilValue = analogRead(soilPins[i]);\n    int moisturePercent = map(soilValue, airValue, waterValue, 0, 100);\n    moisturePercent = constrain(moisturePercent, 0, 100);\n    \n    Serial.print(sensorNames[i]);\n    Serial.print(\": \");\n    Serial.print(moisturePercent);\n    Serial.print(\"%\");\n    \n    if (moisturePercent < dryThreshold) {\n      digitalWrite(pumpPins[i], HIGH);\n      Serial.println(\" - 澆水中\");\n    } else {\n      digitalWrite(pumpPins[i], LOW);\n      Serial.println(\" - 正常\");\n    }\n  }\n  \n  Serial.println();\n  delay(5000);\n}\n```\n\n## 資料記錄器\n```cpp\n#define SOIL_PIN A0\n\nstruct SoilData {\n  unsigned long timestamp;\n  int moisturePercent;\n  int rawValue;\n};\n\nSoilData dataLog[288];  // 24小時的記錄 (每5分鐘一次)\nint logIndex = 0;\nboolean logFull = false;\n\nint airValue = 850;\nint waterValue = 400;\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(\"土壤濕度資料記錄器\");\n  Serial.println(\"每5分鐘記錄一次數據\");\n}\n\nvoid loop() {\n  int soilValue = analogRead(SOIL_PIN);\n  int moisturePercent = map(soilValue, airValue, waterValue, 0, 100);\n  moisturePercent = constrain(moisturePercent, 0, 100);\n  \n  // 記錄數據\n  dataLog[logIndex].timestamp = millis();\n  dataLog[logIndex].moisturePercent = moisturePercent;\n  dataLog[logIndex].rawValue = soilValue;\n  \n  logIndex++;\n  if (logIndex >= 288) {\n    logIndex = 0;\n    logFull = true;\n  }\n  \n  Serial.print(\"目前濕度: \");\n  Serial.print(moisturePercent);\n  Serial.println(\"%\");\n  \n  // 檢查序列指令\n  if (Serial.available()) {\n    String command = Serial.readString();\n    command.trim();\n    \n    if (command == \"SHOW\") {\n      showDataLog();\n    } else if (command == \"CLEAR\") {\n      clearDataLog();\n    }\n  }\n  \n  delay(300000);  // 5分鐘 = 300000毫秒\n}\n\nvoid showDataLog() {\n  Serial.println(\"\\n=== 濕度記錄 ===\");\n  \n  int totalEntries = logFull ? 288 : logIndex;\n  int startIndex = logFull ? logIndex : 0;\n  \n  for (int i = 0; i < totalEntries; i++) {\n    int index = (startIndex + i) % 288;\n    \n    Serial.print(\"時間: \");\n    Serial.print(dataLog[index].timestamp / 60000);  // 轉為分鐘\n    Serial.print(\"分, 濕度: \");\n    Serial.print(dataLog[index].moisturePercent);\n    Serial.println(\"%\");\n  }\n  \n  Serial.println(\"=================\\n\");\n}\n\nvoid clearDataLog() {\n  logIndex = 0;\n  logFull = false;\n  Serial.println(\"記錄已清除\");\n}\n```\n\n## 應用場景\n- **自動澆水** - 花園和盆栽自動照護\n- **農業監測** - 大面積農田濕度管理\n- **溫室控制** - 精確的環境控制\n- **研究實驗** - 植物生長條件研究\n- **智慧家居** - 室內植物照護系統\n\n## 技術規格\n- **工作電壓**: 3.3V - 5V\n- **輸出範圍**: 0V - VCC\n- **測量範圍**: 完全乾燥到飽和\n- **反應時間**: 即時\n- **探針材質**: 鍍金或不鏽鋼\n\n## 注意事項\n- 需要定期清潔探針避免腐蝕\n- 不同土壤類型需要重新校準\n- 肥料鹽分會影響讀數準確性\n- 溫度變化會影響測量結果\n- 長期插在土壤中會加速氧化\n- 定期檢查接線是否牢固"
    },
    {
      "id": "arduino-flame-sensor",
      "title": "火焰感測器",
      "description": "紅外線火焰檢測器",
      "code": "#define FLAME_PIN A0\n#define FLAME_DIGITAL_PIN 2\n#define BUZZER_PIN 8\n#define LED_PIN 13\n\nint flameThreshold = 100;\nboolean alarmActive = false;\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(FLAME_DIGITAL_PIN, INPUT);\n  pinMode(BUZZER_PIN, OUTPUT);\n  pinMode(LED_PIN, OUTPUT);\n  \n  Serial.println(\"火焰檢測系統啟動\");\n  Serial.println(\"監測火焰中...\");\n}\n\nvoid loop() {\n  int flameValue = analogRead(FLAME_PIN);\n  int digitalValue = digitalRead(FLAME_DIGITAL_PIN);\n  \n  Serial.print(\"火焰強度: \");\n  Serial.print(flameValue);\n  Serial.print(\", 數位: \");\n  Serial.println(digitalValue);\n  \n  // 火焰檢測\n  if (flameValue > flameThreshold || digitalValue == HIGH) {\n    if (!alarmActive) {\n      alarmActive = true;\n      Serial.println(\"🔥 偵測到火焰！警報啟動！\");\n    }\n    \n    // 警報音效和閃爍\n    digitalWrite(LED_PIN, HIGH);\n    tone(BUZZER_PIN, 2000, 500);\n    delay(500);\n    \n    digitalWrite(LED_PIN, LOW);\n    delay(200);\n    \n  } else {\n    if (alarmActive) {\n      alarmActive = false;\n      Serial.println(\"火焰消失，警報解除\");\n    }\n    \n    digitalWrite(LED_PIN, LOW);\n    noTone(BUZZER_PIN);\n    delay(500);\n  }\n}",
      "language": "arduino",
      "topic": "Arduino 感測器與致動器",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["感測器", "火焰", "安全", "紅外線", "警報", "原子式"]
      },
      "documentation": "# 火焰感測器\n\n## 功能說明\n火焰感測器利用紅外線檢測技術，能夠偵測火焰發出的特定波長紅外線，常用於火災警報和安全監控系統。\n\n## 工作原理\n- **紅外線檢測**: 火焰發出 760nm-1100nm 紅外線\n- **光電二極體**: 對火焰紅外線敏感\n- **波長濾波**: 只對特定波長響應\n- **雙輸出**: 類比強度 + 數位觸發\n\n## 感測器特性\n- **檢測距離**: 通常 60cm - 100cm\n- **檢測角度**: 約 60 度錐形範圍\n- **反應時間**: 毫秒級快速響應\n- **抗干擾**: 對日光和白熾燈較不敏感\n\n## 接線說明\n```\n火焰感測器     Arduino Uno\nVCC         →  5V\nGND         →  GND\nAO (類比)   →  Pin A0\nDO (數位)   →  Pin 2\n```\n\n## 基本火焰檢測\n```cpp\n#define FLAME_ANALOG_PIN A0\n#define FLAME_DIGITAL_PIN 2\n#define LED_PIN 13\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(FLAME_DIGITAL_PIN, INPUT);\n  pinMode(LED_PIN, OUTPUT);\n  \n  Serial.println(\"火焰檢測器啟動\");\n}\n\nvoid loop() {\n  int analogValue = analogRead(FLAME_ANALOG_PIN);\n  int digitalValue = digitalRead(FLAME_DIGITAL_PIN);\n  \n  Serial.print(\"類比值: \");\n  Serial.print(analogValue);\n  Serial.print(\", 數位值: \");\n  Serial.println(digitalValue);\n  \n  if (digitalValue == HIGH) {\n    digitalWrite(LED_PIN, HIGH);\n    Serial.println(\"偵測到火焰！\");\n  } else {\n    digitalWrite(LED_PIN, LOW);\n  }\n  \n  delay(500);\n}\n```\n\n## 火災警報系統\n```cpp\n#define FLAME_PIN A0\n#define BUZZER_PIN 8\n#define LED_RED 9\n#define LED_GREEN 10\n#define RESET_BUTTON 3\n\nint flameThreshold = 512;\nboolean fireDetected = false;\nboolean systemArmed = true;\nboolean alarmSilenced = false;\nunsigned long fireStartTime = 0;\nconst unsigned long confirmationDelay = 2000;  // 2秒確認延遲\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(BUZZER_PIN, OUTPUT);\n  pinMode(LED_RED, OUTPUT);\n  pinMode(LED_GREEN, OUTPUT);\n  pinMode(RESET_BUTTON, INPUT_PULLUP);\n  \n  digitalWrite(LED_GREEN, HIGH);  // 系統正常指示\n  Serial.println(\"火災警報系統啟動\");\n  Serial.println(\"系統已就緒\");\n}\n\nvoid loop() {\n  int flameValue = analogRead(FLAME_PIN);\n  \n  // 檢查重置按鈕\n  if (digitalRead(RESET_BUTTON) == LOW) {\n    resetAlarm();\n    delay(500);  // 防彈跳\n  }\n  \n  if (systemArmed && !fireDetected) {\n    // 正常監測模式\n    if (flameValue > flameThreshold) {\n      if (fireStartTime == 0) {\n        fireStartTime = millis();\n        Serial.println(\"偵測到可疑火焰訊號...\");\n      } else if (millis() - fireStartTime > confirmationDelay) {\n        // 確認火焰存在\n        triggerFireAlarm(flameValue);\n      }\n    } else {\n      fireStartTime = 0;  // 重置檢測\n    }\n    \n  } else if (fireDetected) {\n    // 火災警報模式\n    handleFireAlarm();\n  }\n  \n  delay(100);\n}\n\nvoid triggerFireAlarm(int intensity) {\n  fireDetected = true;\n  alarmSilenced = false;\n  \n  digitalWrite(LED_GREEN, LOW);\n  \n  Serial.println(\"🚨 火災警報！🚨\");\n  Serial.print(\"火焰強度: \");\n  Serial.println(intensity);\n  Serial.println(\"請立即疏散！\");\n}\n\nvoid handleFireAlarm() {\n  static unsigned long lastFlash = 0;\n  static boolean ledState = false;\n  \n  unsigned long currentTime = millis();\n  \n  // 快速閃爍紅燈\n  if (currentTime - lastFlash > 200) {\n    ledState = !ledState;\n    digitalWrite(LED_RED, ledState);\n    lastFlash = currentTime;\n  }\n  \n  // 警報聲 (除非被靜音)\n  if (!alarmSilenced) {\n    static unsigned long lastBeep = 0;\n    \n    if (currentTime - lastBeep > 1000) {\n      for (int i = 0; i < 5; i++) {\n        tone(BUZZER_PIN, 2000, 100);\n        delay(150);\n      }\n      lastBeep = currentTime;\n    }\n  }\n  \n  // 檢查火焰是否仍然存在\n  int currentFlame = analogRead(FLAME_PIN);\n  if (currentFlame < flameThreshold - 100) {  // 遲滯比較\n    Serial.println(\"火焰訊號消失\");\n  }\n}\n\nvoid resetAlarm() {\n  fireDetected = false;\n  alarmSilenced = false;\n  fireStartTime = 0;\n  \n  digitalWrite(LED_RED, LOW);\n  digitalWrite(LED_GREEN, HIGH);\n  noTone(BUZZER_PIN);\n  \n  Serial.println(\"警報系統重置\");\n  Serial.println(\"恢復正常監測\");\n}\n```\n\n## 多區域監控\n```cpp\n#define NUM_ZONES 3\n\nint flamePins[NUM_ZONES] = {A0, A1, A2};\nint ledPins[NUM_ZONES] = {9, 10, 11};\nString zoneNames[NUM_ZONES] = {\"廚房\", \"客廳\", \"臥室\"};\n\nint flameThreshold = 400;\nboolean zoneAlarms[NUM_ZONES] = {false, false, false};\n\n#define BUZZER_PIN 8\n#define MASTER_LED 13\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(BUZZER_PIN, OUTPUT);\n  pinMode(MASTER_LED, OUTPUT);\n  \n  for (int i = 0; i < NUM_ZONES; i++) {\n    pinMode(ledPins[i], OUTPUT);\n    zoneAlarms[i] = false;\n  }\n  \n  Serial.println(\"多區域火災監控系統\");\n  Serial.println(\"監控區域: 廚房, 客廳, 臥室\");\n}\n\nvoid loop() {\n  boolean anyFireDetected = false;\n  \n  Serial.println(\"=== 區域監控狀態 ===\");\n  \n  for (int i = 0; i < NUM_ZONES; i++) {\n    int flameValue = analogRead(flamePins[i]);\n    \n    Serial.print(zoneNames[i]);\n    Serial.print(\": \");\n    Serial.print(flameValue);\n    \n    if (flameValue > flameThreshold) {\n      if (!zoneAlarms[i]) {\n        zoneAlarms[i] = true;\n        Serial.print(\" - 🔥 火災警報！\");\n      } else {\n        Serial.print(\" - 警報中\");\n      }\n      \n      digitalWrite(ledPins[i], HIGH);\n      anyFireDetected = true;\n      \n    } else {\n      if (zoneAlarms[i]) {\n        zoneAlarms[i] = false;\n        Serial.print(\" - 警報解除\");\n      } else {\n        Serial.print(\" - 正常\");\n      }\n      \n      digitalWrite(ledPins[i], LOW);\n    }\n    \n    Serial.println();\n  }\n  \n  // 主警報控制\n  if (anyFireDetected) {\n    digitalWrite(MASTER_LED, (millis() / 200) % 2);  // 閃爍\n    \n    static unsigned long lastAlarm = 0;\n    if (millis() - lastAlarm > 2000) {\n      tone(BUZZER_PIN, 1500, 500);\n      lastAlarm = millis();\n    }\n  } else {\n    digitalWrite(MASTER_LED, LOW);\n    noTone(BUZZER_PIN);\n  }\n  \n  Serial.println();\n  delay(1000);\n}\n```\n\n## 智慧火災預警\n```cpp\n#define FLAME_PIN A0\n#define TEMP_PIN A1  // 溫度感測器\n#define SMOKE_PIN A2 // 煙霧感測器\n\n#define BUZZER_PIN 8\n#define LED_YELLOW 9  // 預警\n#define LED_RED 10    // 火災\n#define LED_GREEN 11  // 正常\n\nint flameThreshold = 300;\nint tempThreshold = 50;   // 攝氏度\nint smokeThreshold = 400;\n\nenum SystemState {\n  NORMAL,\n  WARNING,\n  FIRE_ALARM\n};\n\nSystemState currentState = NORMAL;\nint warningScore = 0;\nconst int maxWarningScore = 100;\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(BUZZER_PIN, OUTPUT);\n  pinMode(LED_YELLOW, OUTPUT);\n  pinMode(LED_RED, OUTPUT);\n  pinMode(LED_GREEN, OUTPUT);\n  \n  setSystemState(NORMAL);\n  Serial.println(\"智慧火災預警系統\");\n}\n\nvoid loop() {\n  int flameValue = analogRead(FLAME_PIN);\n  int tempValue = analogRead(TEMP_PIN);\n  int smokeValue = analogRead(SMOKE_PIN);\n  \n  // 轉換溫度 (假設使用 LM35)\n  float temperature = (tempValue * 5.0 / 1023.0) * 100;\n  \n  // 重置警告分數\n  warningScore = 0;\n  \n  // 評估各項指標\n  if (flameValue > flameThreshold) {\n    warningScore += 60;  // 火焰佔最高權重\n  } else if (flameValue > flameThreshold * 0.7) {\n    warningScore += 20;\n  }\n  \n  if (temperature > tempThreshold) {\n    warningScore += 30;\n  } else if (temperature > tempThreshold * 0.8) {\n    warningScore += 10;\n  }\n  \n  if (smokeValue > smokeThreshold) {\n    warningScore += 40;\n  } else if (smokeValue > smokeThreshold * 0.8) {\n    warningScore += 15;\n  }\n  \n  // 狀態判斷\n  if (warningScore >= 80) {\n    setSystemState(FIRE_ALARM);\n  } else if (warningScore >= 30) {\n    setSystemState(WARNING);\n  } else {\n    setSystemState(NORMAL);\n  }\n  \n  // 顯示狀態\n  Serial.print(\"火焰: \");\n  Serial.print(flameValue);\n  Serial.print(\", 溫度: \");\n  Serial.print(temperature);\n  Serial.print(\"°C, 煙霧: \");\n  Serial.print(smokeValue);\n  Serial.print(\", 風險分數: \");\n  Serial.println(warningScore);\n  \n  delay(1000);\n}\n\nvoid setSystemState(SystemState newState) {\n  if (currentState != newState) {\n    currentState = newState;\n    \n    // 關閉所有指示燈\n    digitalWrite(LED_GREEN, LOW);\n    digitalWrite(LED_YELLOW, LOW);\n    digitalWrite(LED_RED, LOW);\n    noTone(BUZZER_PIN);\n    \n    switch (currentState) {\n      case NORMAL:\n        digitalWrite(LED_GREEN, HIGH);\n        Serial.println(\"狀態: 正常\");\n        break;\n        \n      case WARNING:\n        digitalWrite(LED_YELLOW, HIGH);\n        tone(BUZZER_PIN, 800, 200);\n        Serial.println(\"狀態: 預警\");\n        break;\n        \n      case FIRE_ALARM:\n        digitalWrite(LED_RED, HIGH);\n        Serial.println(\"狀態: 火災警報！\");\n        break;\n    }\n  }\n  \n  // 處理持續狀態\n  if (currentState == FIRE_ALARM) {\n    static unsigned long lastAlarm = 0;\n    if (millis() - lastAlarm > 1500) {\n      tone(BUZZER_PIN, 2000, 1000);\n      lastAlarm = millis();\n    }\n  }\n}\n```\n\n## 應用場景\n- **火災警報** - 住宅和商業建築安全\n- **工業安全** - 化工廠和製造業\n- **廚房監控** - 烹飪安全警報\n- **實驗室** - 化學實驗安全\n- **機器人** - 火災搜救機器人\n\n## 技術規格\n- **檢測波長**: 760nm - 1100nm\n- **檢測距離**: 60cm - 100cm\n- **檢測角度**: 約 60°\n- **工作電壓**: 3.3V - 5V\n- **工作電流**: 約 15mA\n- **反應時間**: <1ms\n\n## 注意事項\n- 陽光直射會影響檢測準確性\n- 需要定期清潔感測器表面\n- 避免誤觸發需要設定適當門檻值\n- 高溫環境會影響感測器性能\n- 建議搭配煙霧和溫度感測器\n- 定期測試系統功能是否正常"
    },
    {
      "id": "arduino-lcd-display",
      "title": "LCD 液晶顯示器",
      "description": "1602/2004 字元型 LCD 顯示控制",
      "code": "#include <LiquidCrystal.h>\n\n// 初始化 LiquidCrystal 函式庫\n// RS, E, D4, D5, D6, D7\nLiquidCrystal lcd(12, 11, 5, 4, 3, 2);\n\nvoid setup() {\n  // 設定 LCD 行列數 (16x2)\n  lcd.begin(16, 2);\n  \n  // 顯示歡迎訊息\n  lcd.print(\"Hello, World!\");\n  \n  // 設定游標到第二行第一列\n  lcd.setCursor(0, 1);\n  lcd.print(\"LCD Ready!\");\n}\n\nvoid loop() {\n  // 顯示運行時間\n  lcd.setCursor(0, 1);\n  lcd.print(\"Time: \");\n  lcd.print(millis() / 1000);\n  lcd.print(\"s   \");  // 清除多餘字元\n  \n  delay(1000);\n}",
      "language": "arduino",
      "topic": "Arduino 顯示與通訊",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["顯示器", "LCD", "1602", "文字顯示", "原子式"]
      },
      "documentation": "# LCD 液晶顯示器 (1602/2004)\n\n## 功能說明\nLCD 液晶顯示器是最常用的字元型顯示器，能顯示英文字母、數字和基本符號，常見規格有 16x2 (1602) 和 20x4 (2004)。\n\n## 工作原理\n- **字元型顯示**: 每個位置顯示一個字元\n- **HD44780 控制器**: 標準 LCD 控制晶片\n- **並行介面**: 使用 4 位元或 8 位元資料線\n- **背光照明**: 通常配有 LED 背光\n\n## 接線說明 (4-bit 模式)\n```\nLCD 1602        Arduino Uno\nVSS (GND)    →  GND\nVDD (VCC)    →  5V\nV0 (對比)    →  電位器中間腳\nRS           →  Pin 12\nE (Enable)   →  Pin 11\nD4           →  Pin 5\nD5           →  Pin 4\nD6           →  Pin 3\nD7           →  Pin 2\nA (背光+)    →  5V\nK (背光-)    →  GND\n```\n\n## 對比度調整\n```\n電位器接線:\n左腳  → 5V\n中腳  → LCD V0\n右腳  → GND\n```\n\n## 基本顯示功能\n```cpp\n#include <LiquidCrystal.h>\n\nLiquidCrystal lcd(12, 11, 5, 4, 3, 2);\n\nvoid setup() {\n  lcd.begin(16, 2);\n  \n  // 清除螢幕\n  lcd.clear();\n  \n  // 顯示文字\n  lcd.print(\"Hello World!\");\n  \n  // 移動游標\n  lcd.setCursor(0, 1);  // 列, 行\n  lcd.print(\"Arduino LCD\");\n}\n\nvoid loop() {\n  // 閃爍游標\n  lcd.blink();\n  delay(1000);\n  lcd.noBlink();\n  delay(1000);\n}\n```\n\n## 技術規格\n- **顯示格式**: 16x2, 20x4 等字元陣列\n- **字元集**: ASCII + 自定義字元\n- **工作電壓**: 5V (背光需要額外電源)\n- **介面**: 4-bit/8-bit 並行\n- **控制器**: HD44780 相容\n- **背光**: 可選 LED 背光\n\n## 注意事項\n- 對比度調整很重要，影響顯示清晰度\n- 4-bit 模式可節省 Arduino 接腳\n- 自定義字元最多只能定義 8 個\n- 長時間顯示固定內容可能造成殘影"
    },
    {
      "id": "arduino-seven-segment",
      "title": "七段顯示器",
      "description": "數字顯示與時鐘應用",
      "code": "// 七段顯示器接腳定義 (共陰極)\n// 段: a b c d e f g dp\nint segments[] = {2, 3, 4, 5, 6, 7, 8, 9};\n\n// 數字 0-9 的七段編碼 (共陰極)\nbyte numbers[10] = {\n  B11111100,  // 0\n  B01100000,  // 1\n  B11011010,  // 2\n  B11110010,  // 3\n  B01100110,  // 4\n  B10110110,  // 5\n  B10111110,  // 6\n  B11100000,  // 7\n  B11111110,  // 8\n  B11110110   // 9\n};\n\nvoid setup() {\n  // 設定所有段為輸出\n  for (int i = 0; i < 8; i++) {\n    pinMode(segments[i], OUTPUT);\n  }\n  \n  Serial.begin(9600);\n  Serial.println(\"七段顯示器測試\");\n}\n\nvoid loop() {\n  // 顯示數字 0-9\n  for (int i = 0; i <= 9; i++) {\n    displayNumber(i);\n    Serial.print(\"顯示數字: \");\n    Serial.println(i);\n    delay(1000);\n  }\n  \n  // 清除顯示\n  clearDisplay();\n  delay(500);\n}\n\nvoid displayNumber(int num) {\n  if (num >= 0 && num <= 9) {\n    byte pattern = numbers[num];\n    \n    for (int i = 0; i < 8; i++) {\n      digitalWrite(segments[i], bitRead(pattern, 7-i));\n    }\n  }\n}\n\nvoid clearDisplay() {\n  for (int i = 0; i < 8; i++) {\n    digitalWrite(segments[i], LOW);\n  }\n}",
      "language": "arduino",
      "topic": "Arduino 顯示與通訊",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["顯示器", "七段", "數字", "時鐘", "原子式"]
      },
      "documentation": "# 七段顯示器\n\n## 功能說明\n七段顯示器是最常見的數字顯示器，由七個LED段組成，可以顯示數字0-9和部分字母，常用於時鐘、計數器和數值顯示。\n\n## 工作原理\n- **七個LED段**: a, b, c, d, e, f, g 組成數字形狀\n- **小數點**: dp 段用於顯示小數點\n- **共陰極/共陽極**: 兩種接線方式\n- **段編碼**: 每個數字對應特定的段組合\n\n## 顯示器類型\n### 共陰極 (Common Cathode)\n- **共同接地**: 所有LED的陰極連接在一起接GND\n- **高電位點亮**: 段接腳給HIGH點亮對應段\n- **驅動簡單**: 直接用Arduino輸出驅動\n\n### 共陽極 (Common Anode)\n- **共同接電源**: 所有LED的陽極連接在一起接VCC\n- **低電位點亮**: 段接腳給LOW點亮對應段\n- **需要反向邏輯**: 編碼需要反向\n\n## 接線說明 (共陰極)\n```\n七段顯示器    Arduino Uno\na 段       →  Pin 2\nb 段       →  Pin 3\nc 段       →  Pin 4\nd 段       →  Pin 5\ne 段       →  Pin 6\nf 段       →  Pin 7\ng 段       →  Pin 8\ndp 段      →  Pin 9\n共陰極     →  GND\n```\n\n## 段位置圖\n```\n   aaa\n  f   b\n  f   b\n   ggg\n  e   c\n  e   c\n   ddd  dp\n```\n\n## 基本數字顯示\n```cpp\nint segments[] = {2, 3, 4, 5, 6, 7, 8, 9}; // a-g, dp\n\n// 數字編碼 (共陰極)\nbyte digits[10] = {\n  B11111100,  // 0 - abcdef\n  B01100000,  // 1 - bc\n  B11011010,  // 2 - abdeg\n  B11110010,  // 3 - abcdg\n  B01100110,  // 4 - bcfg\n  B10110110,  // 5 - acdfg\n  B10111110,  // 6 - acdefg\n  B11100000,  // 7 - abc\n  B11111110,  // 8 - abcdefg\n  B11110110   // 9 - abcdfg\n};\n\nvoid setup() {\n  for (int i = 0; i < 8; i++) {\n    pinMode(segments[i], OUTPUT);\n  }\n}\n\nvoid loop() {\n  for (int i = 0; i <= 9; i++) {\n    showDigit(i);\n    delay(1000);\n  }\n}\n\nvoid showDigit(int digit) {\n  byte pattern = digits[digit];\n  for (int i = 0; i < 8; i++) {\n    digitalWrite(segments[i], bitRead(pattern, 7-i));\n  }\n}\n```\n\n## 應用場景\n- **數位時鐘** - 時間和鬧鐘顯示\n- **計數器** - 人數統計、生產計數\n- **溫度計** - 環境溫度監測\n- **頻率計** - 信號頻率測量\n- **計時器** - 倒數計時功能\n- **電壓表** - 數位電壓顯示\n\n## 技術規格\n- **顯示數字**: 0-9 和部分字母\n- **工作電壓**: 通常 3.3V-5V\n- **電流消耗**: 每段約 10-20mA\n- **亮度**: 可調節 (PWM 或限流電阻)\n- **多位顯示**: 需要動態掃描\n\n## 注意事項\n- 共陰極和共陽極的編碼不同\n- 多位顯示需要快速掃描避免閃爍\n- 電流限制很重要，避免燒毀LED\n- 動態掃描頻率要足夠高 (>50Hz)\n- 長時間使用建議加散熱措施\n- 接線時注意段位對應關係"
    },
    {
      "id": "arduino-led-matrix",
      "title": "LED 點矩陣顯示器",
      "description": "8x8 點陣圖形與動畫顯示",
      "code": "#include <LedControl.h>\n\n// MAX7219 控制 8x8 LED 矩陣\n// pin 12 接 DIN (Data)\n// pin 11 接 CLK (Clock)\n// pin 10 接 CS (Load)\nLedControl lc = LedControl(12, 11, 10, 1);\n\n// 笑臉圖案\nbyte smiley[8] = {\n  B00111100,\n  B01000010,\n  B10100101,\n  B10000001,\n  B10100101,\n  B10011001,\n  B01000010,\n  B00111100\n};\n\n// 心形圖案\nbyte heart[8] = {\n  B00000000,\n  B01100110,\n  B11111111,\n  B11111111,\n  B01111110,\n  B00111100,\n  B00011000,\n  B00000000\n};\n\nvoid setup() {\n  Serial.begin(9600);\n  \n  // 初始化 MAX7219\n  lc.shutdown(0, false);  // 啟動顯示\n  lc.setIntensity(0, 8);  // 設定亮度 (0-15)\n  lc.clearDisplay(0);     // 清除顯示\n  \n  Serial.println(\"LED 矩陣顯示器啟動\");\n}\n\nvoid loop() {\n  // 顯示笑臉\n  Serial.println(\"顯示笑臉\");\n  displayPattern(smiley);\n  delay(2000);\n  \n  // 顯示心形\n  Serial.println(\"顯示心形\");\n  displayPattern(heart);\n  delay(2000);\n  \n  // 滾動文字效果\n  Serial.println(\"滾動動畫\");\n  scrollAnimation();\n  \n  // 清除顯示\n  lc.clearDisplay(0);\n  delay(1000);\n}\n\nvoid displayPattern(byte pattern[]) {\n  for (int row = 0; row < 8; row++) {\n    lc.setRow(0, row, pattern[row]);\n  }\n}\n\nvoid scrollAnimation() {\n  // 簡單的左右滾動動畫\n  for (int shift = 0; shift < 8; shift++) {\n    lc.clearDisplay(0);\n    \n    for (int row = 0; row < 8; row++) {\n      byte shiftedPattern = smiley[row] >> shift;\n      lc.setRow(0, row, shiftedPattern);\n    }\n    \n    delay(200);\n  }\n}",
      "language": "arduino",
      "topic": "Arduino 顯示與通訊",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["顯示器", "LED矩陣", "圖形", "動畫", "MAX7219", "原子式"]
      },
      "documentation": "# LED 點矩陣顯示器 (8x8)\n\n## 功能說明\nLED 點矩陣顯示器由多個 LED 組成的方形陣列，可以顯示文字、圖形和動畫效果，常用於廣告牌、時鐘顯示和視覺效果。\n\n## 工作原理\n- **LED 陣列**: 8x8 或更大的 LED 矩陣\n- **行列掃描**: 快速掃描每行每列來顯示圖案\n- **控制器**: MAX7219/MAX7221 等專用驅動晶片\n- **位元圖**: 每個 LED 對應一個位元\n\n## 控制方式\n### 直接控制 (16 接腳)\n- **8 行接腳**: 控制橫向的 LED 行\n- **8 列接腳**: 控制縱向的 LED 列\n- **複雜接線**: 需要 16 個 Arduino 接腳\n- **掃描控制**: 軟體實現動態掃描\n\n### MAX7219 控制 (推薦)\n- **SPI 介面**: 只需要 3 個接腳 (DIN, CLK, CS)\n- **內建驅動**: 自動處理掃描和電流控制\n- **級聯支援**: 可以串接多個模組\n- **簡化程式**: 使用 LedControl 函式庫\n\n## 接線說明 (MAX7219)\n```\nMAX7219 模組    Arduino Uno\nVCC          →  5V\nGND          →  GND\nDIN (Data)   →  Pin 12\nCS (Load)    →  Pin 10\nCLK (Clock)  →  Pin 11\n```\n\n## 基本圖案顯示\n```cpp\n#include <LedControl.h>\n\nLedControl lc = LedControl(12, 11, 10, 1);\n\n// 數字 '0' 的點陣\nbyte zero[8] = {\n  B00111100,\n  B01100110,\n  B11000011,\n  B11000011,\n  B11000011,\n  B11000011,\n  B01100110,\n  B00111100\n};\n\nvoid setup() {\n  lc.shutdown(0, false);\n  lc.setIntensity(0, 8);\n  lc.clearDisplay(0);\n}\n\nvoid loop() {\n  displayPattern(zero);\n}\n\nvoid displayPattern(byte pattern[]) {\n  for (int i = 0; i < 8; i++) {\n    lc.setRow(0, i, pattern[i]);\n  }\n}\n```\n\n## 滾動文字顯示\n```cpp\n#include <LedControl.h>\n\nLedControl lc = LedControl(12, 11, 10, 1);\n\n// 字母圖案庫\nbyte letters[][8] = {\n  // A\n  {B00111100, B01100110, B11000011, B11000011, \n   B11111111, B11000011, B11000011, B00000000},\n  // B  \n  {B11111100, B11000110, B11000110, B11111100,\n   B11000110, B11000110, B11111100, B00000000},\n  // C\n  {B00111110, B01100000, B11000000, B11000000,\n   B11000000, B01100000, B00111110, B00000000}\n};\n\nString message = \"ABC\";\nint messageLength = message.length();\nint scrollPosition = 0;\n\nvoid setup() {\n  lc.shutdown(0, false);\n  lc.setIntensity(0, 5);\n  lc.clearDisplay(0);\n}\n\nvoid loop() {\n  displayScrollingText();\n  delay(200);\n  \n  scrollPosition++;\n  if (scrollPosition >= messageLength * 9) {\n    scrollPosition = 0;\n  }\n}\n\nvoid displayScrollingText() {\n  lc.clearDisplay(0);\n  \n  int charIndex = scrollPosition / 9;\n  int pixelOffset = scrollPosition % 9;\n  \n  if (charIndex < messageLength) {\n    char currentChar = message.charAt(charIndex);\n    int letterIndex = currentChar - 'A';\n    \n    if (letterIndex >= 0 && letterIndex < 3) {\n      for (int row = 0; row < 8; row++) {\n        byte pattern = letters[letterIndex][row];\n        pattern = pattern >> pixelOffset;\n        lc.setRow(0, row, pattern);\n      }\n    }\n  }\n}\n```\n\n## 動畫效果\n```cpp\n#include <LedControl.h>\n\nLedControl lc = LedControl(12, 11, 10, 1);\n\nvoid setup() {\n  lc.shutdown(0, false);\n  lc.setIntensity(0, 8);\n  lc.clearDisplay(0);\n}\n\nvoid loop() {\n  rainAnimation();\n  delay(2000);\n  \n  waveAnimation();\n  delay(2000);\n  \n  spiralAnimation();\n  delay(2000);\n}\n\nvoid rainAnimation() {\n  // 雨滴動畫\n  for (int frame = 0; frame < 16; frame++) {\n    lc.clearDisplay(0);\n    \n    for (int col = 0; col < 8; col++) {\n      int dropPos = (frame + col * 2) % 10;\n      if (dropPos < 8) {\n        lc.setLed(0, dropPos, col, true);\n      }\n    }\n    \n    delay(150);\n  }\n}\n\nvoid waveAnimation() {\n  // 波浪動畫\n  for (int frame = 0; frame < 32; frame++) {\n    lc.clearDisplay(0);\n    \n    for (int col = 0; col < 8; col++) {\n      int wave = 3 + 2 * sin((frame + col) * 0.5);\n      lc.setLed(0, wave, col, true);\n    }\n    \n    delay(100);\n  }\n}\n\nvoid spiralAnimation() {\n  // 螺旋動畫\n  int spiral[][2] = {\n    {3,3}, {3,4}, {4,4}, {4,3}, {4,2}, {3,2}, {2,2}, {2,3},\n    {2,4}, {2,5}, {3,5}, {4,5}, {5,5}, {5,4}, {5,3}, {5,2}\n  };\n  \n  for (int i = 0; i < 16; i++) {\n    lc.clearDisplay(0);\n    \n    for (int j = 0; j <= i; j++) {\n      lc.setLed(0, spiral[j][0], spiral[j][1], true);\n    }\n    \n    delay(200);\n  }\n  \n  delay(1000);\n}\n```\n\n## 遊戲應用 - 貪食蛇\n```cpp\n#include <LedControl.h>\n\nLedControl lc = LedControl(12, 11, 10, 1);\n\n// 遊戲狀態\nstruct Point {\n  int x, y;\n};\n\nPoint snake[64];  // 蛇身\nint snakeLength = 3;\nPoint food;\nint direction = 0; // 0=右, 1=下, 2=左, 3=上\nboolean gameRunning = true;\n\nvoid setup() {\n  Serial.begin(9600);\n  lc.shutdown(0, false);\n  lc.setIntensity(0, 8);\n  lc.clearDisplay(0);\n  \n  initGame();\n}\n\nvoid loop() {\n  if (gameRunning) {\n    updateGame();\n    drawGame();\n    \n    // 檢查序列輸入控制方向\n    if (Serial.available()) {\n      char input = Serial.read();\n      switch (input) {\n        case 'w': direction = 3; break; // 上\n        case 's': direction = 1; break; // 下\n        case 'a': direction = 2; break; // 左\n        case 'd': direction = 0; break; // 右\n      }\n    }\n    \n    delay(500);\n  } else {\n    gameOverAnimation();\n  }\n}\n\nvoid initGame() {\n  // 初始化蛇\n  snake[0] = {4, 4};\n  snake[1] = {3, 4};\n  snake[2] = {2, 4};\n  snakeLength = 3;\n  \n  // 生成食物\n  generateFood();\n  \n  gameRunning = true;\n  Serial.println(\"貪食蛇遊戲開始！使用 w/a/s/d 控制方向\");\n}\n\nvoid updateGame() {\n  // 計算新的頭部位置\n  Point newHead = snake[0];\n  \n  switch (direction) {\n    case 0: newHead.x++; break; // 右\n    case 1: newHead.y++; break; // 下\n    case 2: newHead.x--; break; // 左\n    case 3: newHead.y--; break; // 上\n  }\n  \n  // 檢查邊界碰撞\n  if (newHead.x < 0 || newHead.x >= 8 || \n      newHead.y < 0 || newHead.y >= 8) {\n    gameRunning = false;\n    return;\n  }\n  \n  // 檢查自己碰撞\n  for (int i = 0; i < snakeLength; i++) {\n    if (snake[i].x == newHead.x && snake[i].y == newHead.y) {\n      gameRunning = false;\n      return;\n    }\n  }\n  \n  // 移動蛇身\n  for (int i = snakeLength - 1; i > 0; i--) {\n    snake[i] = snake[i - 1];\n  }\n  snake[0] = newHead;\n  \n  // 檢查是否吃到食物\n  if (snake[0].x == food.x && snake[0].y == food.y) {\n    snakeLength++;\n    generateFood();\n    Serial.println(\"吃到食物！長度: \" + String(snakeLength));\n  }\n}\n\nvoid drawGame() {\n  lc.clearDisplay(0);\n  \n  // 繪製蛇\n  for (int i = 0; i < snakeLength; i++) {\n    lc.setLed(0, snake[i].y, snake[i].x, true);\n  }\n  \n  // 繪製食物 (閃爍)\n  static boolean foodBlink = false;\n  foodBlink = !foodBlink;\n  if (foodBlink) {\n    lc.setLed(0, food.y, food.x, true);\n  }\n}\n\nvoid generateFood() {\n  do {\n    food.x = random(8);\n    food.y = random(8);\n    \n    // 確保食物不在蛇身上\n    boolean onSnake = false;\n    for (int i = 0; i < snakeLength; i++) {\n      if (snake[i].x == food.x && snake[i].y == food.y) {\n        onSnake = true;\n        break;\n      }\n    }\n    \n    if (!onSnake) break;\n  } while (true);\n}\n\nvoid gameOverAnimation() {\n  // 遊戲結束動畫\n  for (int i = 0; i < 5; i++) {\n    lc.clearDisplay(0);\n    delay(200);\n    \n    // 顯示 X\n    for (int j = 0; j < 8; j++) {\n      lc.setLed(0, j, j, true);\n      lc.setLed(0, j, 7-j, true);\n    }\n    delay(200);\n  }\n  \n  Serial.println(\"遊戲結束！最終長度: \" + String(snakeLength));\n  Serial.println(\"重新啟動遊戲...\");\n  \n  delay(2000);\n  initGame();\n}\n```\n\n## 應用場景\n- **廣告顯示** - 滾動文字和圖案\n- **時鐘顯示** - 數位時間顯示\n- **遊戲機** - 簡單的像素遊戲\n- **狀態指示** - 系統狀態可視化\n- **藝術裝置** - 互動式視覺效果\n- **教育工具** - 程式設計學習\n\n## 技術規格\n- **顯示尺寸**: 通常 8x8, 16x16, 32x32\n- **工作電壓**: 5V (MAX7219 模組)\n- **電流消耗**: 每個 LED 約 20mA\n- **掃描頻率**: 800Hz (MAX7219)\n- **亮度等級**: 16 級可調\n- **級聯數量**: 最多 8 個模組\n\n## 注意事項\n- MAX7219 簡化接線和程式設計\n- 注意電源供應能力，多個 LED 同時點亮時電流較大\n- 合理設定亮度避免過熱\n- 動畫更新頻率影響視覺效果\n- 位元圖設計時注意座標系統\n- 長期使用建議加散熱措施"
    },
    {
      "id": "arduino-i2c-communication",
      "title": "I2C 通訊基礎",
      "description": "雙線式序列通訊協議",
      "code": "#include <Wire.h>\n\n// I2C LCD 顯示器位址 (常見位址)\n#define LCD_ADDRESS 0x27\n// I2C 感測器位址範例\n#define SENSOR_ADDRESS 0x48\n\nvoid setup() {\n  Serial.begin(9600);\n  Wire.begin(); // 初始化 I2C 主設備\n  \n  Serial.println(\"I2C 通訊測試\");\n  Serial.println(\"掃描 I2C 設備...\");\n  \n  // 掃描所有可能的 I2C 位址\n  scanI2CDevices();\n}\n\nvoid loop() {\n  // 示範讀取感測器數據\n  readSensorData();\n  \n  // 示範發送命令到設備\n  sendCommandToDevice();\n  \n  delay(2000);\n}\n\nvoid scanI2CDevices() {\n  byte error, address;\n  int deviceCount = 0;\n  \n  Serial.println(\"正在掃描 I2C 設備...\");\n  \n  for (address = 1; address < 127; address++) {\n    Wire.beginTransmission(address);\n    error = Wire.endTransmission();\n    \n    if (error == 0) {\n      Serial.print(\"發現 I2C 設備，位址: 0x\");\n      if (address < 16) Serial.print(\"0\");\n      Serial.println(address, HEX);\n      deviceCount++;\n    }\n  }\n  \n  if (deviceCount == 0) {\n    Serial.println(\"未發現 I2C 設備\");\n  } else {\n    Serial.print(\"總共發現 \");\n    Serial.print(deviceCount);\n    Serial.println(\" 個設備\");\n  }\n  Serial.println();\n}\n\nvoid readSensorData() {\n  // 向感測器請求 2 個位元組的數據\n  Wire.requestFrom(SENSOR_ADDRESS, 2);\n  \n  if (Wire.available() >= 2) {\n    byte highByte = Wire.read();\n    byte lowByte = Wire.read();\n    \n    int sensorValue = (highByte << 8) | lowByte;\n    \n    Serial.print(\"感測器數據: \");\n    Serial.println(sensorValue);\n  } else {\n    Serial.println(\"無法讀取感測器數據\");\n  }\n}\n\nvoid sendCommandToDevice() {\n  // 向設備發送命令\n  Wire.beginTransmission(LCD_ADDRESS);\n  Wire.write(0x01); // 示範命令\n  Wire.write(0x02); // 示範數據\n  byte error = Wire.endTransmission();\n  \n  if (error == 0) {\n    Serial.println(\"命令發送成功\");\n  } else {\n    Serial.print(\"發送失敗，錯誤代碼: \");\n    Serial.println(error);\n  }\n}",
      "language": "arduino",
      "topic": "Arduino 顯示與通訊",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["通訊", "I2C", "TWI", "序列", "感測器", "原子式"]
      },
      "documentation": "# I2C 通訊基礎\n\n## 功能說明\nI2C (Inter-Integrated Circuit) 是一種雙線式序列通訊協議，使用 SDA (數據線) 和 SCL (時鐘線) 連接多個設備，常用於感測器、顯示器和記憶體模組。\n\n## 工作原理\n- **雙線通訊**: SDA (數據) + SCL (時鐘)\n- **主從架構**: 一個主設備控制多個從設備\n- **位址定址**: 每個從設備有唯一的 7 位元位址\n- **同步通訊**: 時鐘線控制數據傳輸時序\n\n## 協議特點\n### 主要優勢\n- **節省接腳**: 只需要 2 條線連接多個設備\n- **高整合度**: 可連接 127 個設備\n- **標準化**: 廣泛支援的工業標準\n- **錯誤檢測**: 內建確認機制\n\n### 技術限制\n- **速度限制**: 標準模式 100kHz，快速模式 400kHz\n- **距離限制**: 短距離通訊 (通常 < 1 公尺)\n- **電源依賴**: 需要上拉電阻\n- **位址衝突**: 設備位址不能重複\n\n## 接線說明\n```\nArduino Uno    I2C 設備\nA4 (SDA)    →  SDA\nA5 (SCL)    →  SCL\n5V          →  VCC\nGND         →  GND\n\n上拉電阻:\nSDA 線 - 4.7kΩ 電阻連接到 5V\nSCL 線 - 4.7kΩ 電阻連接到 5V\n```\n\n## 基本設備掃描\n```cpp\n#include <Wire.h>\n\nvoid setup() {\n  Serial.begin(9600);\n  Wire.begin();\n  Serial.println(\"I2C 設備掃描器\");\n}\n\nvoid loop() {\n  byte error, address;\n  int deviceCount = 0;\n  \n  Serial.println(\"掃描中...\");\n  \n  for (address = 1; address < 127; address++) {\n    Wire.beginTransmission(address);\n    error = Wire.endTransmission();\n    \n    if (error == 0) {\n      Serial.print(\"發現設備: 0x\");\n      if (address < 16) Serial.print(\"0\");\n      Serial.println(address, HEX);\n      deviceCount++;\n    }\n  }\n  \n  Serial.print(\"總計: \");\n  Serial.print(deviceCount);\n  Serial.println(\" 個設備\\n\");\n  \n  delay(3000);\n}\n```\n\n## 常見設備位址\n- **PCF8574 (I2C LCD)**: 0x27, 0x3F\n- **DS1307 (RTC)**: 0x68\n- **BME280 (溫濕度)**: 0x76, 0x77\n- **MPU6050 (陀螺儀)**: 0x68, 0x69\n- **ADS1115 (ADC)**: 0x48-0x4B\n- **EEPROM**: 0x50-0x57\n\n## 主設備範例 (讀寫操作)\n```cpp\n#include <Wire.h>\n\n#define DEVICE_ADDRESS 0x48\n\nvoid setup() {\n  Serial.begin(9600);\n  Wire.begin(); // 初始化為主設備\n  Serial.println(\"I2C 主設備\");\n}\n\nvoid loop() {\n  // 寫入數據到設備\n  writeToDevice(0x01, 0xAB);\n  delay(100);\n  \n  // 從設備讀取數據\n  byte data = readFromDevice(0x01);\n  Serial.print(\"讀取到: 0x\");\n  Serial.println(data, HEX);\n  \n  delay(1000);\n}\n\nvoid writeToDevice(byte registerAddress, byte data) {\n  Wire.beginTransmission(DEVICE_ADDRESS);\n  Wire.write(registerAddress);\n  Wire.write(data);\n  byte error = Wire.endTransmission();\n  \n  if (error == 0) {\n    Serial.println(\"寫入成功\");\n  } else {\n    Serial.print(\"寫入失敗: \");\n    Serial.println(error);\n  }\n}\n\nbyte readFromDevice(byte registerAddress) {\n  // 指定要讀取的暫存器\n  Wire.beginTransmission(DEVICE_ADDRESS);\n  Wire.write(registerAddress);\n  Wire.endTransmission(false); // 重複開始\n  \n  // 請求 1 個位元組\n  Wire.requestFrom(DEVICE_ADDRESS, 1);\n  \n  if (Wire.available()) {\n    return Wire.read();\n  } else {\n    Serial.println(\"讀取失敗\");\n    return 0;\n  }\n}\n```\n\n## 從設備範例\n```cpp\n#include <Wire.h>\n\n#define SLAVE_ADDRESS 0x08\n\nbyte registers[16]; // 模擬暫存器\nbyte currentRegister = 0;\n\nvoid setup() {\n  Serial.begin(9600);\n  Wire.begin(SLAVE_ADDRESS); // 初始化為從設備\n  Wire.onReceive(receiveEvent);\n  Wire.onRequest(requestEvent);\n  \n  // 初始化暫存器數據\n  for (int i = 0; i < 16; i++) {\n    registers[i] = i * 10;\n  }\n  \n  Serial.println(\"I2C 從設備啟動\");\n}\n\nvoid loop() {\n  // 主迴圈可以執行其他任務\n  delay(100);\n}\n\nvoid receiveEvent(int numBytes) {\n  Serial.print(\"收到 \");\n  Serial.print(numBytes);\n  Serial.println(\" 個位元組:\");\n  \n  if (numBytes > 0) {\n    currentRegister = Wire.read();\n    Serial.print(\"暫存器位址: \");\n    Serial.println(currentRegister);\n  }\n  \n  while (Wire.available()) {\n    byte data = Wire.read();\n    if (currentRegister < 16) {\n      registers[currentRegister] = data;\n      Serial.print(\"寫入暫存器[\");\n      Serial.print(currentRegister);\n      Serial.print(\"] = \");\n      Serial.println(data);\n      currentRegister++;\n    }\n  }\n}\n\nvoid requestEvent() {\n  Serial.print(\"發送暫存器[\");\n  Serial.print(currentRegister);\n  Serial.print(\"] = \");\n  Serial.println(registers[currentRegister]);\n  \n  Wire.write(registers[currentRegister]);\n}\n```\n\n## 多設備連接範例\n```cpp\n#include <Wire.h>\n\n// 多個設備位址\n#define TEMP_SENSOR 0x48\n#define RTC_MODULE 0x68\n#define LCD_DISPLAY 0x27\n\nvoid setup() {\n  Serial.begin(9600);\n  Wire.begin();\n  \n  Serial.println(\"多設備 I2C 系統\");\n  \n  // 初始化各設備\n  initTemperatureSensor();\n  initRTC();\n  initLCD();\n}\n\nvoid loop() {\n  // 讀取溫度\n  float temperature = readTemperature();\n  Serial.print(\"溫度: \");\n  Serial.println(temperature);\n  \n  // 讀取時間\n  readTime();\n  \n  // 更新顯示\n  updateLCD(temperature);\n  \n  delay(5000);\n}\n\nvoid initTemperatureSensor() {\n  // 配置溫度感測器\n  Wire.beginTransmission(TEMP_SENSOR);\n  Wire.write(0x01); // 配置暫存器\n  Wire.write(0x60); // 設定參數\n  Wire.endTransmission();\n  \n  Serial.println(\"溫度感測器初始化完成\");\n}\n\nfloat readTemperature() {\n  Wire.beginTransmission(TEMP_SENSOR);\n  Wire.write(0x00); // 溫度暫存器\n  Wire.endTransmission();\n  \n  Wire.requestFrom(TEMP_SENSOR, 2);\n  \n  if (Wire.available() >= 2) {\n    int raw = (Wire.read() << 8) | Wire.read();\n    return raw * 0.0625; // 轉換為攝氏度\n  }\n  \n  return -999; // 錯誤值\n}\n\nvoid initRTC() {\n  // RTC 初始化代碼\n  Serial.println(\"RTC 初始化完成\");\n}\n\nvoid readTime() {\n  // 讀取 RTC 時間的代碼\n  Serial.println(\"時間: 12:34:56\");\n}\n\nvoid initLCD() {\n  // LCD 初始化代碼\n  Serial.println(\"LCD 初始化完成\");\n}\n\nvoid updateLCD(float temp) {\n  // 更新 LCD 顯示的代碼\n  Serial.print(\"LCD 顯示溫度: \");\n  Serial.println(temp);\n}\n```\n\n## 錯誤處理\n```cpp\n#include <Wire.h>\n\nvoid setup() {\n  Serial.begin(9600);\n  Wire.begin();\n}\n\nvoid loop() {\n  byte result = safeI2CWrite(0x48, 0x01, 0xAB);\n  \n  switch (result) {\n    case 0:\n      Serial.println(\"傳輸成功\");\n      break;\n    case 1:\n      Serial.println(\"錯誤: 數據太長\");\n      break;\n    case 2:\n      Serial.println(\"錯誤: 位址 NACK\");\n      break;\n    case 3:\n      Serial.println(\"錯誤: 數據 NACK\");\n      break;\n    case 4:\n      Serial.println(\"錯誤: 其他錯誤\");\n      break;\n    default:\n      Serial.println(\"錯誤: 未知錯誤\");\n      break;\n  }\n  \n  delay(2000);\n}\n\nbyte safeI2CWrite(byte address, byte reg, byte data) {\n  Wire.beginTransmission(address);\n  Wire.write(reg);\n  Wire.write(data);\n  return Wire.endTransmission();\n}\n\nbyte safeI2CRead(byte address, byte reg) {\n  Wire.beginTransmission(address);\n  Wire.write(reg);\n  byte error = Wire.endTransmission(false);\n  \n  if (error != 0) {\n    Serial.print(\"讀取前錯誤: \");\n    Serial.println(error);\n    return 0;\n  }\n  \n  Wire.requestFrom(address, 1);\n  \n  if (Wire.available()) {\n    return Wire.read();\n  } else {\n    Serial.println(\"無數據可讀取\");\n    return 0;\n  }\n}\n```\n\n## 應用場景\n- **感測器網路** - 多個感測器數據收集\n- **顯示系統** - LCD、OLED 顯示控制\n- **記憶體存取** - EEPROM 數據儲存\n- **時鐘系統** - RTC 時間同步\n- **ADC 擴展** - 額外類比輸入\n- **GPIO 擴展** - I/O 接腳擴充\n\n## 技術規格\n- **電壓**: 通常 3.3V 或 5V\n- **速度**: 標準 100kHz，快速 400kHz\n- **設備數量**: 最多 127 個\n- **傳輸距離**: 短距離 (< 1 公尺)\n- **位址空間**: 7 位元 (0x08-0x77)\n\n## 注意事項\n- 必須使用上拉電阻 (通常 4.7kΩ)\n- 避免位址衝突\n- 長線傳輸需要考慮電容效應\n- 不同電壓設備需要電平轉換\n- 共享匯流排注意時序衝突\n- 錯誤處理很重要"
    },
    {
      "id": "arduino-serial-communication",
      "title": "UART 序列通訊",
      "description": "非同步序列資料傳輸",
      "code": "// UART 序列通訊範例\n// 使用 Serial (硬體序列埠) 和 SoftwareSerial (軟體序列埠)\n\n#include <SoftwareSerial.h>\n\n// 軟體序列埠接腳定義\nSoftwareSerial mySerial(2, 3); // RX, TX\n\nString inputBuffer = \"\";\nboolean stringComplete = false;\n\nvoid setup() {\n  // 初始化硬體序列埠 (與電腦通訊)\n  Serial.begin(9600);\n  Serial.println(\"Arduino UART 通訊測試\");\n  Serial.println(\"輸入指令:\");\n  Serial.println(\"LED_ON - 開啟 LED\");\n  Serial.println(\"LED_OFF - 關閉 LED\");\n  Serial.println(\"STATUS - 查詢狀態\");\n  \n  // 初始化軟體序列埠 (與其他設備通訊)\n  mySerial.begin(9600);\n  mySerial.println(\"軟體序列埠已啟動\");\n  \n  // LED 控制接腳\n  pinMode(13, OUTPUT);\n  \n  // 預留輸入緩衝區\n  inputBuffer.reserve(200);\n}\n\nvoid loop() {\n  // 處理序列輸入\n  if (stringComplete) {\n    processCommand(inputBuffer);\n    inputBuffer = \"\";\n    stringComplete = false;\n  }\n  \n  // 軟體序列埠數據轉發\n  if (mySerial.available()) {\n    String data = mySerial.readString();\n    Serial.print(\"軟體序列埠收到: \");\n    Serial.println(data);\n  }\n  \n  // 定期發送狀態\n  static unsigned long lastStatusTime = 0;\n  if (millis() - lastStatusTime > 10000) {\n    sendStatus();\n    lastStatusTime = millis();\n  }\n}\n\nvoid serialEvent() {\n  while (Serial.available()) {\n    char inChar = (char)Serial.read();\n    \n    if (inChar == '\\n') {\n      stringComplete = true;\n    } else {\n      inputBuffer += inChar;\n    }\n  }\n}\n\nvoid processCommand(String command) {\n  command.trim();\n  command.toUpperCase();\n  \n  Serial.print(\"收到指令: \");\n  Serial.println(command);\n  \n  if (command == \"LED_ON\") {\n    digitalWrite(13, HIGH);\n    Serial.println(\"LED 已開啟\");\n    mySerial.println(\"LED_STATUS:ON\");\n    \n  } else if (command == \"LED_OFF\") {\n    digitalWrite(13, LOW);\n    Serial.println(\"LED 已關閉\");\n    mySerial.println(\"LED_STATUS:OFF\");\n    \n  } else if (command == \"STATUS\") {\n    sendStatus();\n    \n  } else {\n    Serial.println(\"未知指令\");\n    Serial.println(\"可用指令: LED_ON, LED_OFF, STATUS\");\n  }\n}\n\nvoid sendStatus() {\n  boolean ledState = digitalRead(13);\n  \n  Serial.println(\"=== 系統狀態 ===\");\n  Serial.print(\"LED 狀態: \");\n  Serial.println(ledState ? \"開啟\" : \"關閉\");\n  Serial.print(\"運行時間: \");\n  Serial.print(millis() / 1000);\n  Serial.println(\" 秒\");\n  Serial.print(\"可用記憶體: \");\n  Serial.print(freeMemory());\n  Serial.println(\" bytes\");\n  Serial.println(\"================\");\n  \n  // 同時發送到軟體序列埠\n  mySerial.print(\"STATUS:LED=\");\n  mySerial.print(ledState ? \"ON\" : \"OFF\");\n  mySerial.print(\",UPTIME=\");\n  mySerial.println(millis() / 1000);\n}\n\nint freeMemory() {\n  extern int __heap_start, *__brkval;\n  int v;\n  return (int) &v - (__brkval == 0 ? (int) &__heap_start : (int) __brkval);\n}",
      "language": "arduino",
      "topic": "Arduino 顯示與通訊",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["通訊", "Serial", "UART", "指令", "非同步", "原子式"]
      },
      "documentation": "# UART 序列通訊\n\n## 功能說明\nUART (Universal Asynchronous Receiver-Transmitter) 是一種非同步序列通訊協議，使用 TX (傳輸) 和 RX (接收) 線進行點對點通訊，常用於與電腦、其他微控制器或序列設備通訊。\n\n## 工作原理\n- **非同步傳輸**: 不需要共享時鐘信號\n- **序列傳輸**: 數據逐位元依序傳送\n- **雙向通訊**: 可同時發送和接收\n- **協議簡單**: 只需要 TX、RX 和 GND 線\n\n## 通訊參數\n### 鮑率 (Baud Rate)\n- **定義**: 每秒傳輸的位元數\n- **常用值**: 9600, 19200, 38400, 57600, 115200\n- **匹配要求**: 收發雙方必須設定相同鮑率\n\n### 數據格式\n- **起始位**: 1 個位元 (邏輯 0)\n- **數據位**: 通常 8 個位元\n- **同位位**: 可選 (奇同位、偶同位或無)\n- **停止位**: 1 或 2 個位元 (邏輯 1)\n\n## Arduino 序列埠\n### 硬體序列埠\n- **Serial**: Pin 0 (RX), Pin 1 (TX)\n- **硬體支援**: 由 UART 硬體處理\n- **效能好**: 不佔用 CPU 資源\n- **與電腦通訊**: 通常用於 USB 連接\n\n### 軟體序列埠\n- **SoftwareSerial**: 任意數位接腳\n- **軟體模擬**: 由程式模擬 UART 協議\n- **多埠支援**: 可建立多個序列埠\n- **效能限制**: 較低鮑率和 CPU 負擔\n\n## 基本序列通訊\n```cpp\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(\"Arduino 序列通訊測試\");\n}\n\nvoid loop() {\n  // 發送數據\n  Serial.println(\"Hello World!\");\n  \n  // 讀取數據\n  if (Serial.available()) {\n    String input = Serial.readString();\n    Serial.print(\"收到: \");\n    Serial.println(input);\n  }\n  \n  delay(1000);\n}\n```\n\n## 軟體序列埠\n```cpp\n#include <SoftwareSerial.h>\n\n// 建立軟體序列埠 (RX=2, TX=3)\nSoftwareSerial bluetooth(2, 3);\n\nvoid setup() {\n  Serial.begin(9600);\n  bluetooth.begin(9600);\n  \n  Serial.println(\"雙序列埠通訊\");\n}\n\nvoid loop() {\n  // 電腦到藍牙模組\n  if (Serial.available()) {\n    String data = Serial.readString();\n    bluetooth.print(data);\n    Serial.print(\"發送到藍牙: \");\n    Serial.println(data);\n  }\n  \n  // 藍牙模組到電腦\n  if (bluetooth.available()) {\n    String data = bluetooth.readString();\n    Serial.print(\"藍牙收到: \");\n    Serial.println(data);\n  }\n}\n```\n\n## 指令解析系統\n```cpp\nString commandBuffer = \"\";\nboolean commandReady = false;\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(\"指令解析系統\");\n  Serial.println(\"可用指令:\");\n  Serial.println(\"SET_LED <pin> <value>  - 設定 LED\");\n  Serial.println(\"READ_PIN <pin>        - 讀取接腳\");\n  Serial.println(\"HELP                  - 顯示說明\");\n  \n  commandBuffer.reserve(200);\n}\n\nvoid loop() {\n  if (commandReady) {\n    executeCommand(commandBuffer);\n    commandBuffer = \"\";\n    commandReady = false;\n  }\n}\n\nvoid serialEvent() {\n  while (Serial.available()) {\n    char c = (char)Serial.read();\n    \n    if (c == '\\n' || c == '\\r') {\n      if (commandBuffer.length() > 0) {\n        commandReady = true;\n      }\n    } else {\n      commandBuffer += c;\n    }\n  }\n}\n\nvoid executeCommand(String cmd) {\n  cmd.trim();\n  cmd.toUpperCase();\n  \n  Serial.print(\"> \");\n  Serial.println(cmd);\n  \n  if (cmd.startsWith(\"SET_LED\")) {\n    // 解析: SET_LED 13 1\n    int firstSpace = cmd.indexOf(' ');\n    int secondSpace = cmd.indexOf(' ', firstSpace + 1);\n    \n    if (firstSpace > 0 && secondSpace > 0) {\n      int pin = cmd.substring(firstSpace + 1, secondSpace).toInt();\n      int value = cmd.substring(secondSpace + 1).toInt();\n      \n      pinMode(pin, OUTPUT);\n      digitalWrite(pin, value);\n      \n      Serial.print(\"設定 Pin \");\n      Serial.print(pin);\n      Serial.print(\" = \");\n      Serial.println(value);\n    } else {\n      Serial.println(\"錯誤: SET_LED <pin> <value>\");\n    }\n    \n  } else if (cmd.startsWith(\"READ_PIN\")) {\n    // 解析: READ_PIN 13\n    int space = cmd.indexOf(' ');\n    \n    if (space > 0) {\n      int pin = cmd.substring(space + 1).toInt();\n      int value = digitalRead(pin);\n      \n      Serial.print(\"Pin \");\n      Serial.print(pin);\n      Serial.print(\" = \");\n      Serial.println(value);\n    } else {\n      Serial.println(\"錯誤: READ_PIN <pin>\");\n    }\n    \n  } else if (cmd == \"HELP\") {\n    Serial.println(\"可用指令:\");\n    Serial.println(\"SET_LED <pin> <value>  - 設定 LED (pin: 接腳號, value: 0/1)\");\n    Serial.println(\"READ_PIN <pin>        - 讀取接腳狀態\");\n    Serial.println(\"HELP                  - 顯示此說明\");\n    \n  } else {\n    Serial.println(\"未知指令，輸入 HELP 查看說明\");\n  }\n}\n```\n\n## 數據記錄系統\n```cpp\nstruct SensorReading {\n  unsigned long timestamp;\n  float temperature;\n  float humidity;\n  int lightLevel;\n};\n\nvoid setup() {\n  Serial.begin(9600);\n  \n  // 發送 CSV 標題\n  Serial.println(\"timestamp,temperature,humidity,light\");\n}\n\nvoid loop() {\n  SensorReading reading;\n  \n  reading.timestamp = millis();\n  reading.temperature = analogRead(A0) * 0.48828125; // 假設溫度換算\n  reading.humidity = analogRead(A1) * 0.09765625;    // 假設濕度換算\n  reading.lightLevel = analogRead(A2);\n  \n  // 輸出 CSV 格式\n  Serial.print(reading.timestamp);\n  Serial.print(\",\");\n  Serial.print(reading.temperature, 2);\n  Serial.print(\",\");\n  Serial.print(reading.humidity, 2);\n  Serial.print(\",\");\n  Serial.println(reading.lightLevel);\n  \n  delay(5000); // 每 5 秒記錄一次\n}\n```\n\n## 二進制數據傳輸\n```cpp\nvoid setup() {\n  Serial.begin(115200); // 較高鮑率適合二進制數據\n}\n\nvoid loop() {\n  // 發送二進制數據包\n  sendBinaryPacket();\n  \n  // 接收並解析二進制數據\n  if (Serial.available() >= 8) { // 等待完整數據包\n    receiveBinaryPacket();\n  }\n  \n  delay(1000);\n}\n\nvoid sendBinaryPacket() {\n  // 數據包格式: [START][LENGTH][DATA...][CHECKSUM]\n  byte packet[8];\n  \n  packet[0] = 0xAA;           // 起始標記\n  packet[1] = 0x06;           // 數據長度\n  packet[2] = 0x01;           // 命令\n  packet[3] = highByte(analogRead(A0)); // 數據高位\n  packet[4] = lowByte(analogRead(A0));  // 數據低位\n  packet[5] = highByte(millis());       // 時間戳高位\n  packet[6] = lowByte(millis());        // 時間戳低位\n  \n  // 計算檢查和\n  byte checksum = 0;\n  for (int i = 1; i < 7; i++) {\n    checksum ^= packet[i];\n  }\n  packet[7] = checksum;\n  \n  // 發送數據包\n  Serial.write(packet, 8);\n}\n\nvoid receiveBinaryPacket() {\n  byte packet[8];\n  \n  // 讀取數據包\n  Serial.readBytes(packet, 8);\n  \n  // 驗證起始標記\n  if (packet[0] != 0xAA) {\n    Serial.println(\"錯誤: 無效起始標記\");\n    return;\n  }\n  \n  // 驗證檢查和\n  byte checksum = 0;\n  for (int i = 1; i < 7; i++) {\n    checksum ^= packet[i];\n  }\n  \n  if (checksum != packet[7]) {\n    Serial.println(\"錯誤: 檢查和不符\");\n    return;\n  }\n  \n  // 解析數據\n  int dataValue = (packet[3] << 8) | packet[4];\n  int timestamp = (packet[5] << 8) | packet[6];\n  \n  Serial.print(\"收到數據: \");\n  Serial.print(dataValue);\n  Serial.print(\", 時間: \");\n  Serial.println(timestamp);\n}\n```\n\n## 應用場景\n- **電腦通訊** - 數據上傳和遠端控制\n- **設備間通訊** - Arduino 之間的數據交換\n- **感測器網路** - 無線模組串列通訊\n- **調試除錯** - 程式狀態監控\n- **數據記錄** - 感測器數據收集\n- **指令控制** - 遠端命令執行\n\n## 技術規格\n- **電壓**: 通常 3.3V 或 5V 邏輯電平\n- **鮑率**: 300 bps 到 115200 bps 或更高\n- **傳輸距離**: 短距離 (幾公尺內)\n- **連接方式**: 點對點連接\n- **接腳需求**: TX, RX, GND (最少 3 線)\n\n## 注意事項\n- 收發雙方鮑率必須一致\n- 注意電壓準位匹配 (3.3V vs 5V)\n- 長距離傳輸考慮使用 RS-232 或 RS-485\n- 軟體序列埠不能同時收發\n- 高鮑率時注意時序精確度\n- 數據完整性檢查很重要"
    },
    {
      "id": "arduino-sd-card",
      "title": "SD 卡讀寫模組",
      "description": "檔案系統數據儲存",
      "code": "#include <SPI.h>\n#include <SD.h>\n\n// SD 卡模組接腳\nconst int chipSelect = 10;\n\nvoid setup() {\n  Serial.begin(9600);\n  \n  Serial.println(\"SD 卡模組測試\");\n  \n  // 初始化 SD 卡\n  if (!SD.begin(chipSelect)) {\n    Serial.println(\"SD 卡初始化失敗！\");\n    Serial.println(\"請檢查:\");\n    Serial.println(\"1. SD 卡是否插入\");\n    Serial.println(\"2. 接線是否正確\");\n    Serial.println(\"3. SD 卡格式 (FAT16/FAT32)\");\n    return;\n  }\n  \n  Serial.println(\"SD 卡初始化成功\");\n  \n  // 顯示 SD 卡資訊\n  displaySDInfo();\n  \n  // 建立測試檔案\n  createTestFile();\n  \n  // 讀取檔案內容\n  readTestFile();\n  \n  // 列出所有檔案\n  listFiles();\n}\n\nvoid loop() {\n  // 感測器數據記錄範例\n  static unsigned long lastLog = 0;\n  if (millis() - lastLog > 10000) { // 每 10 秒記錄一次\n    logSensorData();\n    lastLog = millis();\n  }\n  \n  // 檢查序列指令\n  if (Serial.available()) {\n    String command = Serial.readString();\n    command.trim();\n    processCommand(command);\n  }\n}\n\nvoid displaySDInfo() {\n  Sd2Card card;\n  SdVolume volume;\n  \n  if (card.init(SPI_HALF_SPEED, chipSelect)) {\n    Serial.println(\"=== SD 卡資訊 ===\");\n    \n    Serial.print(\"卡片類型: \");\n    switch (card.type()) {\n      case SD_CARD_TYPE_SD1:\n        Serial.println(\"SD1\");\n        break;\n      case SD_CARD_TYPE_SD2:\n        Serial.println(\"SD2\");\n        break;\n      case SD_CARD_TYPE_SDHC:\n        Serial.println(\"SDHC\");\n        break;\n      default:\n        Serial.println(\"未知\");\n    }\n    \n    if (volume.init(card)) {\n      Serial.print(\"檔案系統: FAT\");\n      Serial.println(volume.fatType(), DEC);\n      \n      uint32_t volumesize = volume.blocksPerCluster();\n      volumesize *= volume.clusterCount();\n      volumesize /= 2; // 轉換為 KB\n      \n      Serial.print(\"容量: \");\n      Serial.print(volumesize / 1024);\n      Serial.println(\" MB\");\n    }\n    \n    Serial.println(\"=================\");\n  }\n}\n\nvoid createTestFile() {\n  Serial.println(\"建立測試檔案...\");\n  \n  File dataFile = SD.open(\"test.txt\", FILE_WRITE);\n  \n  if (dataFile) {\n    dataFile.println(\"Arduino SD 卡測試\");\n    dataFile.println(\"時間戳: \" + String(millis()));\n    dataFile.println(\"系統啟動完成\");\n    dataFile.close();\n    \n    Serial.println(\"test.txt 建立成功\");\n  } else {\n    Serial.println(\"無法建立 test.txt\");\n  }\n}\n\nvoid readTestFile() {\n  Serial.println(\"讀取測試檔案...\");\n  \n  File dataFile = SD.open(\"test.txt\");\n  \n  if (dataFile) {\n    Serial.println(\"test.txt 內容:\");\n    \n    while (dataFile.available()) {\n      Serial.write(dataFile.read());\n    }\n    \n    dataFile.close();\n  } else {\n    Serial.println(\"無法開啟 test.txt\");\n  }\n  \n  Serial.println();\n}\n\nvoid listFiles() {\n  Serial.println(\"SD 卡檔案列表:\");\n  \n  File root = SD.open(\"/\");\n  \n  while (true) {\n    File entry = root.openNextFile();\n    \n    if (!entry) {\n      break; // 沒有更多檔案\n    }\n    \n    Serial.print(entry.name());\n    \n    if (entry.isDirectory()) {\n      Serial.println(\"/\");\n    } else {\n      Serial.print(\"\\t\\t\");\n      Serial.print(entry.size(), DEC);\n      Serial.println(\" bytes\");\n    }\n    \n    entry.close();\n  }\n  \n  root.close();\n  Serial.println();\n}\n\nvoid logSensorData() {\n  // 讀取感測器數據\n  int temperature = analogRead(A0);\n  int humidity = analogRead(A1);\n  int light = analogRead(A2);\n  \n  // 建立數據字串\n  String dataString = \"\";\n  dataString += String(millis());\n  dataString += \",\";\n  dataString += String(temperature);\n  dataString += \",\";\n  dataString += String(humidity);\n  dataString += \",\";\n  dataString += String(light);\n  \n  // 寫入 CSV 檔案\n  File dataFile = SD.open(\"sensors.csv\", FILE_WRITE);\n  \n  if (dataFile) {\n    dataFile.println(dataString);\n    dataFile.close();\n    \n    Serial.print(\"記錄數據: \");\n    Serial.println(dataString);\n  } else {\n    Serial.println(\"無法寫入 sensors.csv\");\n  }\n}\n\nvoid processCommand(String cmd) {\n  cmd.toUpperCase();\n  \n  if (cmd == \"LIST\") {\n    listFiles();\n    \n  } else if (cmd == \"INFO\") {\n    displaySDInfo();\n    \n  } else if (cmd.startsWith(\"READ \")) {\n    String filename = cmd.substring(5);\n    readFile(filename);\n    \n  } else if (cmd.startsWith(\"DELETE \")) {\n    String filename = cmd.substring(7);\n    deleteFile(filename);\n    \n  } else if (cmd == \"LOG\") {\n    logSensorData();\n    \n  } else {\n    Serial.println(\"可用指令:\");\n    Serial.println(\"LIST - 列出檔案\");\n    Serial.println(\"INFO - 顯示 SD 卡資訊\");\n    Serial.println(\"READ <filename> - 讀取檔案\");\n    Serial.println(\"DELETE <filename> - 刪除檔案\");\n    Serial.println(\"LOG - 手動記錄感測器數據\");\n  }\n}\n\nvoid readFile(String filename) {\n  File dataFile = SD.open(filename);\n  \n  if (dataFile) {\n    Serial.println(\"檔案內容: \" + filename);\n    Serial.println(\"==================\");\n    \n    while (dataFile.available()) {\n      Serial.write(dataFile.read());\n    }\n    \n    dataFile.close();\n    Serial.println(\"\\n==================\");\n  } else {\n    Serial.println(\"無法開啟檔案: \" + filename);\n  }\n}\n\nvoid deleteFile(String filename) {\n  if (SD.remove(filename)) {\n    Serial.println(\"檔案已刪除: \" + filename);\n  } else {\n    Serial.println(\"無法刪除檔案: \" + filename);\n  }\n}",
      "language": "arduino",
      "topic": "Arduino 顯示與通訊",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["儲存", "SD卡", "檔案", "數據記錄", "SPI", "原子式"]
      },
      "documentation": "# SD 卡讀寫模組\n\n## 功能說明\nSD 卡模組提供大容量數據儲存功能，支援檔案系統操作，常用於感測器數據記錄、配置檔案儲存和程式更新，是物聯網設備的重要組件。\n\n## 工作原理\n- **SPI 通訊**: 透過 SPI 協議與 Arduino 通訊\n- **檔案系統**: 支援 FAT16/FAT32 檔案系統\n- **非揮發性**: 斷電後數據仍然保存\n- **熱插拔**: 支援運行時插拔 (需軟體配合)\n\n## 模組特性\n### 硬體規格\n- **支援卡片**: SD, SDHC, SDXC\n- **容量範圍**: 幾 MB 到幾十 GB\n- **工作電壓**: 3.3V 或 5V\n- **通訊介面**: SPI (4 線)\n- **傳輸速度**: 取決於 SPI 速度設定\n\n### 檔案系統\n- **FAT16**: 適合小容量 SD 卡\n- **FAT32**: 適合大容量 SD 卡\n- **長檔名**: 支援長檔案名稱\n- **目錄結構**: 支援多層目錄\n\n## 接線說明\n```\nSD 卡模組      Arduino Uno\nVCC         →  5V 或 3.3V\nGND         →  GND\nMISO        →  Pin 12 (MISO)\nMOSI        →  Pin 11 (MOSI)\nSCK         →  Pin 13 (SCK)\nCS          →  Pin 10 (可自訂)\n```\n\n## 基本檔案操作\n```cpp\n#include <SPI.h>\n#include <SD.h>\n\nconst int chipSelect = 10;\n\nvoid setup() {\n  Serial.begin(9600);\n  \n  if (!SD.begin(chipSelect)) {\n    Serial.println(\"SD 卡初始化失敗\");\n    return;\n  }\n  \n  Serial.println(\"SD 卡就緒\");\n  \n  // 寫入檔案\n  File myFile = SD.open(\"test.txt\", FILE_WRITE);\n  if (myFile) {\n    myFile.println(\"Hello, SD Card!\");\n    myFile.close();\n    Serial.println(\"寫入完成\");\n  }\n  \n  // 讀取檔案\n  myFile = SD.open(\"test.txt\");\n  if (myFile) {\n    while (myFile.available()) {\n      Serial.write(myFile.read());\n    }\n    myFile.close();\n  }\n}\n\nvoid loop() {\n  // 主程式\n}\n```\n\n## 感測器數據記錄\n```cpp\n#include <SPI.h>\n#include <SD.h>\n\nconst int chipSelect = 10;\n\nvoid setup() {\n  Serial.begin(9600);\n  \n  if (!SD.begin(chipSelect)) {\n    Serial.println(\"SD 卡初始化失敗\");\n    return;\n  }\n  \n  // 建立 CSV 標題\n  File dataFile = SD.open(\"data.csv\", FILE_WRITE);\n  if (dataFile) {\n    dataFile.println(\"timestamp,temperature,humidity,light\");\n    dataFile.close();\n  }\n}\n\nvoid loop() {\n  // 讀取感測器\n  float temp = analogRead(A0) * 0.48828125;\n  float humidity = analogRead(A1) * 0.09765625;\n  int light = analogRead(A2);\n  \n  // 記錄數據\n  File dataFile = SD.open(\"data.csv\", FILE_WRITE);\n  if (dataFile) {\n    dataFile.print(millis());\n    dataFile.print(\",\");\n    dataFile.print(temp);\n    dataFile.print(\",\");\n    dataFile.print(humidity);\n    dataFile.print(\",\");\n    dataFile.println(light);\n    dataFile.close();\n    \n    Serial.println(\"數據已記錄\");\n  }\n  \n  delay(60000); // 每分鐘記錄一次\n}\n```\n\n## 配置檔案管理\n```cpp\n#include <SPI.h>\n#include <SD.h>\n\nstruct Config {\n  String deviceName;\n  int sampleInterval;\n  float tempOffset;\n  boolean enableLogging;\n};\n\nConfig deviceConfig;\n\nvoid setup() {\n  Serial.begin(9600);\n  SD.begin(10);\n  \n  loadConfig();\n  \n  Serial.println(\"當前配置:\");\n  printConfig();\n}\n\nvoid loop() {\n  if (Serial.available()) {\n    String command = Serial.readString();\n    command.trim();\n    \n    if (command == \"save\") {\n      saveConfig();\n    } else if (command == \"load\") {\n      loadConfig();\n    } else if (command == \"show\") {\n      printConfig();\n    }\n  }\n}\n\nvoid loadConfig() {\n  // 設定預設值\n  deviceConfig.deviceName = \"Arduino_001\";\n  deviceConfig.sampleInterval = 5000;\n  deviceConfig.tempOffset = 0.0;\n  deviceConfig.enableLogging = true;\n  \n  File configFile = SD.open(\"config.txt\");\n  if (configFile) {\n    while (configFile.available()) {\n      String line = configFile.readStringUntil('\\n');\n      line.trim();\n      \n      if (line.startsWith(\"name=\")) {\n        deviceConfig.deviceName = line.substring(5);\n      } else if (line.startsWith(\"interval=\")) {\n        deviceConfig.sampleInterval = line.substring(9).toInt();\n      } else if (line.startsWith(\"offset=\")) {\n        deviceConfig.tempOffset = line.substring(7).toFloat();\n      } else if (line.startsWith(\"logging=\")) {\n        deviceConfig.enableLogging = line.substring(8) == \"true\";\n      }\n    }\n    configFile.close();\n    Serial.println(\"配置檔案載入完成\");\n  } else {\n    Serial.println(\"使用預設配置\");\n  }\n}\n\nvoid saveConfig() {\n  File configFile = SD.open(\"config.txt\", FILE_WRITE);\n  if (configFile) {\n    configFile.println(\"name=\" + deviceConfig.deviceName);\n    configFile.println(\"interval=\" + String(deviceConfig.sampleInterval));\n    configFile.println(\"offset=\" + String(deviceConfig.tempOffset));\n    configFile.println(\"logging=\" + String(deviceConfig.enableLogging ? \"true\" : \"false\"));\n    configFile.close();\n    Serial.println(\"配置已儲存\");\n  }\n}\n\nvoid printConfig() {\n  Serial.println(\"設備名稱: \" + deviceConfig.deviceName);\n  Serial.println(\"採樣間隔: \" + String(deviceConfig.sampleInterval) + \"ms\");\n  Serial.println(\"溫度偏移: \" + String(deviceConfig.tempOffset));\n  Serial.println(\"記錄功能: \" + String(deviceConfig.enableLogging ? \"啟用\" : \"停用\"));\n}\n```\n\n## 應用場景\n- **數據記錄器** - 長期感測器數據儲存\n- **配置管理** - 設備參數和設定檔\n- **韌體更新** - 程式碼和更新檔案\n- **事件記錄** - 系統事件和錯誤日誌\n- **音樂播放** - 音頻檔案儲存播放\n- **圖片儲存** - 相機模組照片儲存\n\n## 技術規格\n- **容量**: 從 MB 到 GB 級別\n- **速度**: SPI 時鐘速度決定\n- **壽命**: 有限的寫入次數 (約 10,000 次)\n- **功耗**: 活動時約 100mA，待機約 1mA\n- **工作溫度**: -40°C 到 +85°C\n\n## 注意事項\n- SD 卡有寫入次數限制，避免頻繁寫入\n- 大檔案操作可能導致記憶體不足\n- 確保檔案操作後正確關閉檔案\n- 電源不穩定可能損壞檔案系統\n- 格式化建議使用 FAT32\n- 檔案名稱遵循 8.3 格式較穩定"
    },
    {
      "id": "arduino-rtc-ds1307",
      "title": "RTC 實時時鐘 DS1307",
      "description": "精確時間記錄與管理",
      "code": "#include <Wire.h>\n#include <RTClib.h>\n\nRTC_DS1307 rtc;\n\n// 日期時間格式\nchar daysOfTheWeek[7][12] = {\n  \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \n  \"Thursday\", \"Friday\", \"Saturday\"\n};\n\nvoid setup() {\n  Serial.begin(9600);\n  \n  Serial.println(\"DS1307 RTC 實時時鐘測試\");\n  \n  // 初始化 RTC\n  if (!rtc.begin()) {\n    Serial.println(\"找不到 RTC 模組！\");\n    Serial.println(\"請檢查接線:\");\n    Serial.println(\"VCC -> 5V, GND -> GND\");\n    Serial.println(\"SDA -> A4, SCL -> A5\");\n    while (1);\n  }\n  \n  // 檢查 RTC 是否運行\n  if (!rtc.isrunning()) {\n    Serial.println(\"RTC 未運行，設定為編譯時間\");\n    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));\n  }\n  \n  Serial.println(\"RTC 模組就緒\");\n  \n  // 顯示當前時間\n  displayCurrentTime();\n  \n  // 設定鬧鐘示範\n  setupAlarmDemo();\n}\n\nvoid loop() {\n  // 每秒顯示時間\n  static unsigned long lastDisplay = 0;\n  if (millis() - lastDisplay >= 1000) {\n    displayCurrentTime();\n    lastDisplay = millis();\n  }\n  \n  // 檢查鬧鐘\n  checkAlarm();\n  \n  // 處理序列指令\n  if (Serial.available()) {\n    String command = Serial.readString();\n    command.trim();\n    processTimeCommand(command);\n  }\n}\n\nvoid displayCurrentTime() {\n  DateTime now = rtc.now();\n  \n  Serial.print(\"時間: \");\n  Serial.print(now.year(), DEC);\n  Serial.print('/');\n  if (now.month() < 10) Serial.print('0');\n  Serial.print(now.month(), DEC);\n  Serial.print('/');\n  if (now.day() < 10) Serial.print('0');\n  Serial.print(now.day(), DEC);\n  \n  Serial.print(\" (\");\n  Serial.print(daysOfTheWeek[now.dayOfTheWeek()]);\n  Serial.print(\") \");\n  \n  if (now.hour() < 10) Serial.print('0');\n  Serial.print(now.hour(), DEC);\n  Serial.print(':');\n  if (now.minute() < 10) Serial.print('0');\n  Serial.print(now.minute(), DEC);\n  Serial.print(':');\n  if (now.second() < 10) Serial.print('0');\n  Serial.print(now.second(), DEC);\n  \n  Serial.print(\" 運行時間: \");\n  Serial.print(millis() / 1000);\n  Serial.println(\"s\");\n}\n\n// 鬧鐘相關變數\nDateTime alarmTime;\nboolean alarmSet = false;\nboolean alarmTriggered = false;\n\nvoid setupAlarmDemo() {\n  DateTime now = rtc.now();\n  // 設定 30 秒後的鬧鐘\n  alarmTime = DateTime(now.unixtime() + 30);\n  alarmSet = true;\n  alarmTriggered = false;\n  \n  Serial.println(\"鬧鐘已設定為 30 秒後\");\n}\n\nvoid checkAlarm() {\n  if (alarmSet && !alarmTriggered) {\n    DateTime now = rtc.now();\n    \n    if (now.unixtime() >= alarmTime.unixtime()) {\n      triggerAlarm();\n    }\n  }\n}\n\nvoid triggerAlarm() {\n  alarmTriggered = true;\n  \n  Serial.println(\"\\n*** 鬧鐘響起！***\");\n  Serial.println(\"時間到了！\");\n  \n  // 蜂鳴器響鈴 (假設連接到 Pin 8)\n  for (int i = 0; i < 5; i++) {\n    tone(8, 1000, 200);\n    delay(300);\n  }\n  \n  Serial.println(\"鬧鐘結束\\n\");\n}\n\nvoid processTimeCommand(String cmd) {\n  cmd.toUpperCase();\n  \n  if (cmd == \"TIME\") {\n    displayDetailedTime();\n    \n  } else if (cmd == \"DATE\") {\n    displayDetailedDate();\n    \n  } else if (cmd.startsWith(\"SET_TIME \")) {\n    // 格式: SET_TIME HH:MM:SS\n    String timeStr = cmd.substring(9);\n    setTime(timeStr);\n    \n  } else if (cmd.startsWith(\"SET_DATE \")) {\n    // 格式: SET_DATE YYYY/MM/DD\n    String dateStr = cmd.substring(9);\n    setDate(dateStr);\n    \n  } else if (cmd.startsWith(\"ALARM \")) {\n    // 格式: ALARM +SS (設定 SS 秒後鬧鐘)\n    int seconds = cmd.substring(6).toInt();\n    setAlarm(seconds);\n    \n  } else if (cmd == \"TEMP\") {\n    displayTemperature();\n    \n  } else {\n    Serial.println(\"可用指令:\");\n    Serial.println(\"TIME - 顯示時間\");\n    Serial.println(\"DATE - 顯示日期\");\n    Serial.println(\"SET_TIME HH:MM:SS - 設定時間\");\n    Serial.println(\"SET_DATE YYYY/MM/DD - 設定日期\");\n    Serial.println(\"ALARM +SS - 設定 SS 秒後鬧鐘\");\n    Serial.println(\"TEMP - 顯示溫度 (如果支援)\");\n  }\n}\n\nvoid displayDetailedTime() {\n  DateTime now = rtc.now();\n  \n  Serial.println(\"=== 詳細時間資訊 ===\");\n  Serial.print(\"時間: \");\n  Serial.print(now.hour());\n  Serial.print(\":\");\n  Serial.print(now.minute());\n  Serial.print(\":\");\n  Serial.println(now.second());\n  \n  Serial.print(\"Unix 時間戳: \");\n  Serial.println(now.unixtime());\n  \n  Serial.print(\"自午夜秒數: \");\n  Serial.println(now.secondstime());\n  \n  Serial.println(\"==================\");\n}\n\nvoid displayDetailedDate() {\n  DateTime now = rtc.now();\n  \n  Serial.println(\"=== 詳細日期資訊 ===\");\n  Serial.print(\"日期: \");\n  Serial.print(now.year());\n  Serial.print(\"/\");\n  Serial.print(now.month());\n  Serial.print(\"/\");\n  Serial.println(now.day());\n  \n  Serial.print(\"星期: \");\n  Serial.println(daysOfTheWeek[now.dayOfTheWeek()]);\n  \n  Serial.print(\"一年中第幾天: \");\n  Serial.println(dayOfYear(now));\n  \n  Serial.println(\"==================\");\n}\n\nvoid setTime(String timeStr) {\n  // 解析 HH:MM:SS 格式\n  int hour = timeStr.substring(0, 2).toInt();\n  int minute = timeStr.substring(3, 5).toInt();\n  int second = timeStr.substring(6, 8).toInt();\n  \n  DateTime now = rtc.now();\n  DateTime newTime = DateTime(now.year(), now.month(), now.day(), \n                             hour, minute, second);\n  \n  rtc.adjust(newTime);\n  \n  Serial.println(\"時間已設定為: \" + timeStr);\n}\n\nvoid setDate(String dateStr) {\n  // 解析 YYYY/MM/DD 格式\n  int year = dateStr.substring(0, 4).toInt();\n  int month = dateStr.substring(5, 7).toInt();\n  int day = dateStr.substring(8, 10).toInt();\n  \n  DateTime now = rtc.now();\n  DateTime newDate = DateTime(year, month, day, \n                             now.hour(), now.minute(), now.second());\n  \n  rtc.adjust(newDate);\n  \n  Serial.println(\"日期已設定為: \" + dateStr);\n}\n\nvoid setAlarm(int seconds) {\n  DateTime now = rtc.now();\n  alarmTime = DateTime(now.unixtime() + seconds);\n  alarmSet = true;\n  alarmTriggered = false;\n  \n  Serial.print(\"鬧鐘已設定為 \");\n  Serial.print(seconds);\n  Serial.println(\" 秒後\");\n}\n\nvoid displayTemperature() {\n  // DS1307 本身不支援溫度，這裡是示範\n  // 如果使用 DS3231 則有內建溫度感測器\n  Serial.println(\"DS1307 不支援溫度讀取\");\n  Serial.println(\"建議使用 DS3231 或外接溫度感測器\");\n}\n\nint dayOfYear(DateTime date) {\n  int days = 0;\n  int daysInMonth[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n  \n  // 檢查閏年\n  if (isLeapYear(date.year())) {\n    daysInMonth[1] = 29;\n  }\n  \n  // 計算前面月份的天數\n  for (int i = 0; i < date.month() - 1; i++) {\n    days += daysInMonth[i];\n  }\n  \n  // 加上當月天數\n  days += date.day();\n  \n  return days;\n}\n\nboolean isLeapYear(int year) {\n  return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n}",
      "language": "arduino",
      "topic": "Arduino 顯示與通訊",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["時鐘", "RTC", "時間", "日期", "鬧鐘", "I2C", "原子式"]
      },
      "documentation": "# RTC 實時時鐘 DS1307\n\n## 功能說明\nDS1307 是一款低功耗的實時時鐘 (RTC) 晶片，具有電池備份功能，即使在主電源關閉時也能保持時間運行，常用於需要精確時間記錄的應用。\n\n## 工作原理\n- **石英振盪器**: 32.768kHz 石英提供時間基準\n- **電池備份**: CR2032 電池在斷電時維持時間\n- **I2C 通訊**: 透過 I2C 協議與微控制器通訊\n- **自動進位**: 自動處理月份、年份和閏年\n\n## 模組特性\n### 時間功能\n- **時間格式**: 12/24 小時制\n- **日期範圍**: 2000-2099 年\n- **精度**: ±2ppm (約每月 ±5 秒)\n- **自動處理**: 閏年、月末日期\n\n### 硬體特性\n- **工作電壓**: 4.5V - 5.5V\n- **備份電壓**: 2.0V - 3.5V\n- **功耗**: 運行時 1.5mA，備份時 300nA\n- **I2C 位址**: 0x68 (固定)\n- **備份電池**: CR2032 或類似\n\n## 接線說明\n```\nDS1307 模組    Arduino Uno\nVCC         →  5V\nGND         →  GND\nSDA         →  A4 (SDA)\nSCL         →  A5 (SCL)\nSQW         →  Pin 2 (可選，中斷)\nBattery     →  CR2032 電池\n```\n\n## 基本時間讀取\n```cpp\n#include <Wire.h>\n#include <RTClib.h>\n\nRTC_DS1307 rtc;\n\nvoid setup() {\n  Serial.begin(9600);\n  \n  if (!rtc.begin()) {\n    Serial.println(\"RTC 模組未找到\");\n    while (1);\n  }\n  \n  if (!rtc.isrunning()) {\n    Serial.println(\"RTC 未運行，設定時間\");\n    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));\n  }\n}\n\nvoid loop() {\n  DateTime now = rtc.now();\n  \n  Serial.print(now.year(), DEC);\n  Serial.print('/');\n  Serial.print(now.month(), DEC);\n  Serial.print('/');\n  Serial.print(now.day(), DEC);\n  Serial.print(' ');\n  Serial.print(now.hour(), DEC);\n  Serial.print(':');\n  Serial.print(now.minute(), DEC);\n  Serial.print(':');\n  Serial.print(now.second(), DEC);\n  Serial.println();\n  \n  delay(1000);\n}\n```\n\n## 時間設定和格式化\n```cpp\n#include <Wire.h>\n#include <RTClib.h>\n\nRTC_DS1307 rtc;\n\nvoid setup() {\n  Serial.begin(9600);\n  rtc.begin();\n  \n  // 手動設定時間\n  // rtc.adjust(DateTime(2024, 1, 15, 14, 30, 0));\n  \n  Serial.println(\"時間設定範例\");\n}\n\nvoid loop() {\n  DateTime now = rtc.now();\n  \n  // 格式化輸出\n  char dateBuffer[20];\n  char timeBuffer[20];\n  \n  sprintf(dateBuffer, \"%04d/%02d/%02d\", \n          now.year(), now.month(), now.day());\n  \n  sprintf(timeBuffer, \"%02d:%02d:%02d\", \n          now.hour(), now.minute(), now.second());\n  \n  Serial.print(\"日期: \");\n  Serial.println(dateBuffer);\n  Serial.print(\"時間: \");\n  Serial.println(timeBuffer);\n  \n  // Unix 時間戳\n  Serial.print(\"Unix 時間戳: \");\n  Serial.println(now.unixtime());\n  \n  delay(5000);\n}\n```\n\n## 數據記錄應用\n```cpp\n#include <Wire.h>\n#include <RTClib.h>\n#include <SPI.h>\n#include <SD.h>\n\nRTC_DS1307 rtc;\nconst int chipSelect = 10;\n\nvoid setup() {\n  Serial.begin(9600);\n  \n  // 初始化 RTC\n  if (!rtc.begin()) {\n    Serial.println(\"RTC 初始化失敗\");\n    while (1);\n  }\n  \n  // 初始化 SD 卡\n  if (!SD.begin(chipSelect)) {\n    Serial.println(\"SD 卡初始化失敗\");\n    while (1);\n  }\n  \n  Serial.println(\"時間戳數據記錄器啟動\");\n}\n\nvoid loop() {\n  // 讀取感測器數據\n  int temperature = analogRead(A0);\n  int humidity = analogRead(A1);\n  \n  // 記錄帶時間戳的數據\n  logDataWithTimestamp(temperature, humidity);\n  \n  delay(60000); // 每分鐘記錄一次\n}\n\nvoid logDataWithTimestamp(int temp, int humid) {\n  DateTime now = rtc.now();\n  \n  File dataFile = SD.open(\"sensors.log\", FILE_WRITE);\n  \n  if (dataFile) {\n    // 寫入時間戳\n    dataFile.print(now.year());\n    dataFile.print(\"-\");\n    dataFile.print(now.month());\n    dataFile.print(\"-\");\n    dataFile.print(now.day());\n    dataFile.print(\" \");\n    dataFile.print(now.hour());\n    dataFile.print(\":\");\n    dataFile.print(now.minute());\n    dataFile.print(\":\");\n    dataFile.print(now.second());\n    \n    // 寫入數據\n    dataFile.print(\",\");\n    dataFile.print(temp);\n    dataFile.print(\",\");\n    dataFile.println(humid);\n    \n    dataFile.close();\n    \n    Serial.println(\"數據已記錄: \" + \n                   String(temp) + \",\" + String(humid));\n  }\n}\n```\n\n## 鬧鐘和定時器\n```cpp\n#include <Wire.h>\n#include <RTClib.h>\n\nRTC_DS1307 rtc;\n\nstruct Alarm {\n  int hour;\n  int minute;\n  boolean enabled;\n  boolean triggered;\n};\n\nAlarm alarms[3]; // 最多 3 個鬧鐘\n\nvoid setup() {\n  Serial.begin(9600);\n  rtc.begin();\n  \n  // 設定測試鬧鐘\n  setAlarm(0, 14, 30, true);  // 14:30\n  setAlarm(1, 18, 0, true);   // 18:00\n  setAlarm(2, 22, 30, false); // 22:30 (停用)\n  \n  pinMode(8, OUTPUT); // 蜂鳴器\n  \n  Serial.println(\"鬧鐘系統啟動\");\n}\n\nvoid loop() {\n  DateTime now = rtc.now();\n  \n  // 檢查所有鬧鐘\n  for (int i = 0; i < 3; i++) {\n    checkAlarm(i, now);\n  }\n  \n  // 顯示當前時間\n  static unsigned long lastDisplay = 0;\n  if (millis() - lastDisplay > 1000) {\n    displayTime(now);\n    lastDisplay = millis();\n  }\n  \n  delay(100);\n}\n\nvoid setAlarm(int index, int hour, int minute, boolean enabled) {\n  if (index >= 0 && index < 3) {\n    alarms[index].hour = hour;\n    alarms[index].minute = minute;\n    alarms[index].enabled = enabled;\n    alarms[index].triggered = false;\n    \n    Serial.print(\"鬧鐘 \");\n    Serial.print(index + 1);\n    Serial.print(\" 設定為 \");\n    Serial.print(hour);\n    Serial.print(\":\");\n    Serial.print(minute);\n    Serial.println(enabled ? \" (啟用)\" : \" (停用)\");\n  }\n}\n\nvoid checkAlarm(int index, DateTime now) {\n  if (!alarms[index].enabled || alarms[index].triggered) {\n    return;\n  }\n  \n  if (now.hour() == alarms[index].hour && \n      now.minute() == alarms[index].minute &&\n      now.second() == 0) {\n    \n    triggerAlarm(index);\n  }\n  \n  // 重置觸發狀態 (每天重置)\n  if (now.hour() == 0 && now.minute() == 0 && now.second() == 0) {\n    alarms[index].triggered = false;\n  }\n}\n\nvoid triggerAlarm(int index) {\n  alarms[index].triggered = true;\n  \n  Serial.print(\"鬧鐘 \");\n  Serial.print(index + 1);\n  Serial.println(\" 響起！\");\n  \n  // 響鈴 10 秒\n  for (int i = 0; i < 20; i++) {\n    tone(8, 1000, 250);\n    delay(500);\n  }\n  \n  Serial.println(\"鬧鐘結束\");\n}\n\nvoid displayTime(DateTime now) {\n  Serial.print(\"時間: \");\n  if (now.hour() < 10) Serial.print(\"0\");\n  Serial.print(now.hour());\n  Serial.print(\":\");\n  if (now.minute() < 10) Serial.print(\"0\");\n  Serial.print(now.minute());\n  Serial.print(\":\");\n  if (now.second() < 10) Serial.print(\"0\");\n  Serial.print(now.second());\n  \n  // 顯示下一個鬧鐘\n  int nextAlarm = getNextAlarm(now);\n  if (nextAlarm >= 0) {\n    Serial.print(\" [下個鬧鐘: \");\n    Serial.print(alarms[nextAlarm].hour);\n    Serial.print(\":\");\n    if (alarms[nextAlarm].minute < 10) Serial.print(\"0\");\n    Serial.print(alarms[nextAlarm].minute);\n    Serial.print(\"]\");\n  }\n  \n  Serial.println();\n}\n\nint getNextAlarm(DateTime now) {\n  int currentMinutes = now.hour() * 60 + now.minute();\n  int nextAlarmMinutes = 24 * 60; // 明天的 0:00\n  int nextAlarmIndex = -1;\n  \n  for (int i = 0; i < 3; i++) {\n    if (alarms[i].enabled && !alarms[i].triggered) {\n      int alarmMinutes = alarms[i].hour * 60 + alarms[i].minute;\n      \n      if (alarmMinutes > currentMinutes && alarmMinutes < nextAlarmMinutes) {\n        nextAlarmMinutes = alarmMinutes;\n        nextAlarmIndex = i;\n      }\n    }\n  }\n  \n  return nextAlarmIndex;\n}\n```\n\n## 應用場景\n- **數據記錄器** - 帶時間戳的感測器數據\n- **定時控制** - 按時間執行特定動作\n- **事件記錄** - 系統事件時間記錄\n- **計時器** - 精確計時應用\n- **鬧鐘系統** - 定時提醒功能\n- **時鐘顯示** - 數位時鐘製作\n\n## 技術規格\n- **時間精度**: ±2ppm (25°C)\n- **工作溫度**: -40°C 到 +85°C\n- **備份電流**: 300nA (典型值)\n- **I2C 速度**: 100kHz (標準模式)\n- **電池壽命**: CR2032 約 8-10 年\n- **記憶體**: 56 字節 NVRAM\n\n## 注意事項\n- 初次使用需要設定正確時間\n- 電池電壓低時時間可能不準確\n- 溫度變化會影響時間精度\n- 長期未使用可能需要重新校準\n- 備份電池請選用品質良好的產品\n- I2C 上拉電阻通常已內建於模組"
    },
    {
      "id": "arduino-seven-segment",
      "title": "七段顯示器",
      "description": "4位數 7段顯示器數字顯示",
      "code": "#define LATCH_PIN 8\n#define CLOCK_PIN 12\n#define DATA_PIN 11\n\n// 七段顯示器編碼 (共陰極)\nbyte segments[10] = {\n  0b00111111, // 0\n  0b00000110, // 1\n  0b01011011, // 2\n  0b01001111, // 3\n  0b01100110, // 4\n  0b01101101, // 5\n  0b01111101, // 6\n  0b00000111, // 7\n  0b01111111, // 8\n  0b01101111  // 9\n};\n\nvoid setup() {\n  pinMode(LATCH_PIN, OUTPUT);\n  pinMode(CLOCK_PIN, OUTPUT);\n  pinMode(DATA_PIN, OUTPUT);\n  \n  Serial.begin(9600);\n}\n\nvoid loop() {\n  // 顯示 0-9999 計數\n  for (int number = 0; number <= 9999; number++) {\n    displayNumber(number);\n    delay(200);\n  }\n}\n\nvoid displayNumber(int number) {\n  // 分解數字為個別位數\n  int thousands = number / 1000;\n  int hundreds = (number / 100) % 10;\n  int tens = (number / 10) % 10;\n  int units = number % 10;\n  \n  // 顯示數字\n  digitalWrite(LATCH_PIN, LOW);\n  shiftOut(DATA_PIN, CLOCK_PIN, MSBFIRST, segments[units]);\n  shiftOut(DATA_PIN, CLOCK_PIN, MSBFIRST, segments[tens]);\n  shiftOut(DATA_PIN, CLOCK_PIN, MSBFIRST, segments[hundreds]);\n  shiftOut(DATA_PIN, CLOCK_PIN, MSBFIRST, segments[thousands]);\n  digitalWrite(LATCH_PIN, HIGH);\n}",
      "language": "arduino",
      "topic": "Arduino 顯示與通訊",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["顯示器", "七段", "數字顯示", "移位暫存器", "原子式"]
      },
      "documentation": "# 七段顯示器 (4位數)\n\n## 功能說明\n七段顯示器是最常用的數字顯示器，由7個LED段組成，可以顯示0-9數字和部分字母。4位數版本可以顯示0000-9999的數字。\n\n## 工作原理\n- **7個LED段**: a, b, c, d, e, f, g 組成數字形狀\n- **共陰極/共陽極**: 決定驅動方式\n- **移位暫存器**: 使用 74HC595 減少引腳使用\n- **多工顯示**: 快速切換各位數顯示\n\n## 接線說明\n```\n74HC595 (x4)    Arduino Uno\nST_CP (Latch) → Pin 8\nSH_CP (Clock) → Pin 12\nDS (Data)     → Pin 11\nVCC           → 5V\nGND           → GND\n```\n\n## 技術規格\n- **顯示位數**: 4位數 (0000-9999)\n- **顯示類型**: 共陰極或共陽極\n- **工作電壓**: 3.3V - 5V\n- **顯示亮度**: 可調整限流電阻\n- **刷新率**: 通常 > 50Hz\n\n## 注意事項\n- 需要限流電阻保護LED\n- 共陰極和共陽極編碼不同\n- 長時間顯示需要考慮功耗\n- 多位數顯示需要快速掃描避免閃爍"
    },
    {
      "id": "arduino-matrix-display",
      "title": "LED 點矩陣顯示器",
      "description": "8x8 LED 矩陣文字圖案顯示",
      "code": "#include <LedControl.h>\n\n#define DIN_PIN 12\n#define CS_PIN 11\n#define CLK_PIN 10\n\nLedControl lc = LedControl(DIN_PIN, CLK_PIN, CS_PIN, 1);\n\n// 字母 A 的圖案\nbyte letterA[8] = {\n  0b00011000,\n  0b00100100,\n  0b01000010,\n  0b01000010,\n  0b01111110,\n  0b01000010,\n  0b01000010,\n  0b00000000\n};\n\n// 笑臉圖案\nbyte smiley[8] = {\n  0b00111100,\n  0b01000010,\n  0b10100101,\n  0b10000001,\n  0b10100101,\n  0b10011001,\n  0b01000010,\n  0b00111100\n};\n\nvoid setup() {\n  // 初始化 MAX7219\n  lc.shutdown(0, false);\n  lc.setIntensity(0, 8);\n  lc.clearDisplay(0);\n  \n  Serial.begin(9600);\n  Serial.println(\"LED 矩陣啟動\");\n}\n\nvoid loop() {\n  // 顯示字母 A\n  displayPattern(letterA);\n  delay(2000);\n  \n  // 顯示笑臉\n  displayPattern(smiley);\n  delay(2000);\n  \n  // 捲動文字\n  scrollText(\"Hello\");\n  delay(1000);\n}\n\nvoid displayPattern(byte pattern[8]) {\n  for (int row = 0; row < 8; row++) {\n    lc.setRow(0, row, pattern[row]);\n  }\n}\n\nvoid scrollText(String text) {\n  // 簡單的水平捲動效果\n  for (int i = 0; i < text.length() * 8; i++) {\n    lc.clearDisplay(0);\n    \n    // 這裡可以實現更複雜的字型映射\n    if (i < 8) {\n      displayPattern(letterA);\n    }\n    \n    delay(100);\n  }\n}",
      "language": "arduino",
      "topic": "Arduino 顯示與通訊",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["顯示器", "LED矩陣", "圖案顯示", "MAX7219", "原子式"]
      },
      "documentation": "# LED 點矩陣顯示器 (8x8)\n\n## 功能說明\nLED 點矩陣顯示器由 64 個 LED 組成 8x8 陣列，可以顯示文字、數字、圖案和簡單動畫。通常使用 MAX7219 控制器簡化控制。\n\n## 工作原理\n- **LED 陣列**: 8x8 = 64 個 LED\n- **行列掃描**: 逐行或逐列點亮 LED\n- **MAX7219 控制器**: 簡化驅動電路\n- **SPI 通訊**: 串列週邊介面\n\n## 接線說明\n```\nMAX7219 模組    Arduino Uno\nVCC          →  5V\nGND          →  GND\nDIN          →  Pin 12\nCS           →  Pin 11\nCLK          →  Pin 10\n```\n\n## 必要函式庫\n需要安裝 LedControl 函式庫\n\n## 技術規格\n- **矩陣大小**: 8x8 LED\n- **控制器**: MAX7219/MAX7221\n- **工作電壓**: 4V - 5.5V\n- **最大電流**: 330mA\n- **亮度等級**: 16 級可調\n- **通訊介面**: SPI\n\n## 注意事項\n- 需要適當的限流電阻\n- 多個模組可以級聯\n- 亮度過高會增加功耗\n- 避免長時間顯示固定圖案"
    },
    {
      "id": "arduino-i2c-communication",
      "title": "I2C 通訊協議",
      "description": "I2C 主從設備通訊基礎",
      "code": "#include <Wire.h>\n\n// I2C 從設備地址\n#define SLAVE_ADDRESS 0x08\n\nvoid setup() {\n  Serial.begin(9600);\n  Wire.begin(); // 初始化為主設備\n  \n  Serial.println(\"I2C 主設備啟動\");\n}\n\nvoid loop() {\n  // 向從設備發送數據\n  sendDataToSlave(\"Hello\");\n  delay(1000);\n  \n  // 從從設備請求數據\n  requestDataFromSlave();\n  delay(1000);\n  \n  // 掃描 I2C 設備\n  scanI2CDevices();\n  delay(5000);\n}\n\nvoid sendDataToSlave(String data) {\n  Wire.beginTransmission(SLAVE_ADDRESS);\n  Wire.write(data.c_str());\n  byte error = Wire.endTransmission();\n  \n  if (error == 0) {\n    Serial.println(\"數據發送成功: \" + data);\n  } else {\n    Serial.println(\"發送失敗，錯誤代碼: \" + String(error));\n  }\n}\n\nvoid requestDataFromSlave() {\n  Wire.requestFrom(SLAVE_ADDRESS, 6); // 請求 6 字節\n  \n  String receivedData = \"\";\n  while (Wire.available()) {\n    char c = Wire.read();\n    receivedData += c;\n  }\n  \n  if (receivedData.length() > 0) {\n    Serial.println(\"接收到數據: \" + receivedData);\n  }\n}\n\nvoid scanI2CDevices() {\n  Serial.println(\"掃描 I2C 設備...\");\n  \n  int deviceCount = 0;\n  for (byte address = 1; address < 127; address++) {\n    Wire.beginTransmission(address);\n    byte error = Wire.endTransmission();\n    \n    if (error == 0) {\n      Serial.print(\"找到設備於地址 0x\");\n      if (address < 16) Serial.print(\"0\");\n      Serial.println(address, HEX);\n      deviceCount++;\n    }\n  }\n  \n  if (deviceCount == 0) {\n    Serial.println(\"未找到 I2C 設備\");\n  } else {\n    Serial.println(\"掃描完成，找到 \" + String(deviceCount) + \" 個設備\");\n  }\n}",
      "language": "arduino",
      "topic": "Arduino 顯示與通訊",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["通訊", "I2C", "主從通訊", "協議", "原子式"]
      },
      "documentation": "# I2C 通訊協議\n\n## 功能說明\nI2C (Inter-Integrated Circuit) 是一種串列通訊協議，使用兩條線 (SDA 和 SCL) 就能連接多個設備，支援主從架構。\n\n## 工作原理\n- **雙線通訊**: SDA (數據線) 和 SCL (時鐘線)\n- **主從架構**: 一個主設備，多個從設備\n- **地址識別**: 7位或10位設備地址\n- **開漏輸出**: 需要上拉電阻\n\n## 接線說明\n```\nArduino Uno I2C 引腳:\nSDA → Pin A4\nSCL → Pin A5\n上拉電阻 4.7kΩ 連接到 5V\n```\n\n## 通訊特性\n- **速度**: 標準模式 100kHz，快速模式 400kHz\n- **設備數量**: 理論上 127 個設備\n- **傳輸距離**: 短距離 (< 1m)\n- **電壓等級**: 通常 3.3V 或 5V\n\n## 技術規格\n- **數據長度**: 8 位元\n- **確認機制**: ACK/NACK\n- **錯誤檢測**: 地址和數據確認\n- **線路狀態**: 空閒時為高電平\n\n## 注意事項\n- 必須使用上拉電阻 (通常 4.7kΩ)\n- 避免地址衝突\n- 線路長度影響最大速度\n- 電容負載限制設備數量"
    },
    {
      "id": "arduino-spi-communication",
      "title": "SPI 通訊協議",
      "description": "SPI 主從設備高速通訊",
      "code": "#include <SPI.h>\n\n#define SS_PIN 10\n\nvoid setup() {\n  Serial.begin(9600);\n  \n  // 設定 SS 引腳為輸出\n  pinMode(SS_PIN, OUTPUT);\n  digitalWrite(SS_PIN, HIGH);\n  \n  // 初始化 SPI\n  SPI.begin();\n  SPI.setDataMode(SPI_MODE0);\n  SPI.setClockDivider(SPI_CLOCK_DIV16);\n  SPI.setBitOrder(MSBFIRST);\n  \n  Serial.println(\"SPI 主設備啟動\");\n}\n\nvoid loop() {\n  // 發送數據到從設備\n  byte response = sendSPIData(0x55); // 發送測試字節\n  \n  Serial.print(\"發送: 0x\");\n  Serial.print(0x55, HEX);\n  Serial.print(\", 接收: 0x\");\n  Serial.println(response, HEX);\n  \n  delay(1000);\n  \n  // 讀取從設備狀態\n  byte status = readSPIStatus();\n  Serial.print(\"從設備狀態: 0x\");\n  Serial.println(status, HEX);\n  \n  delay(2000);\n}\n\nbyte sendSPIData(byte data) {\n  // 選擇從設備 (拉低 SS)\n  digitalWrite(SS_PIN, LOW);\n  \n  // 發送數據並接收回應\n  byte response = SPI.transfer(data);\n  \n  // 取消選擇從設備 (拉高 SS)\n  digitalWrite(SS_PIN, HIGH);\n  \n  return response;\n}\n\nbyte readSPIStatus() {\n  digitalWrite(SS_PIN, LOW);\n  \n  // 發送狀態讀取命令\n  SPI.transfer(0x9F); // 假設的狀態讀取命令\n  byte status = SPI.transfer(0x00); // 讀取狀態\n  \n  digitalWrite(SS_PIN, HIGH);\n  \n  return status;\n}\n\nvoid sendMultipleBytes() {\n  byte dataArray[] = {0x01, 0x02, 0x03, 0x04};\n  byte responseArray[4];\n  \n  digitalWrite(SS_PIN, LOW);\n  \n  for (int i = 0; i < 4; i++) {\n    responseArray[i] = SPI.transfer(dataArray[i]);\n  }\n  \n  digitalWrite(SS_PIN, HIGH);\n  \n  // 顯示結果\n  Serial.println(\"多字節傳輸:\");\n  for (int i = 0; i < 4; i++) {\n    Serial.print(\"發送[\" + String(i) + \"]: 0x\");\n    Serial.print(dataArray[i], HEX);\n    Serial.print(\", 接收[\" + String(i) + \"]: 0x\");\n    Serial.println(responseArray[i], HEX);\n  }\n}",
      "language": "arduino",
      "topic": "Arduino 顯示與通訊",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["通訊", "SPI", "高速通訊", "主從通訊", "原子式"]
      },
      "documentation": "# SPI 通訊協議\n\n## 功能說明\nSPI (Serial Peripheral Interface) 是一種高速、全雙工的串列通訊協議，使用四條線進行通訊，速度比 I2C 快。\n\n## 工作原理\n- **四線通訊**: MOSI、MISO、SCK、SS\n- **主從架構**: 主設備控制時鐘\n- **全雙工**: 同時發送和接收\n- **片選控制**: SS 引腳選擇設備\n\n## 接線說明\n```\nArduino Uno SPI 引腳:\nMOSI (主出從入) → Pin 11\nMISO (主入從出) → Pin 12\nSCK (時鐘)     → Pin 13\nSS (片選)      → Pin 10 (可自定義)\n```\n\n## 通訊特性\n- **速度**: 可達數 MHz\n- **數據長度**: 通常 8 或 16 位元\n- **傳輸距離**: 短距離 (< 3m)\n- **設備數量**: 受 SS 引腳數量限制\n\n## SPI 模式\n- **模式 0**: CPOL=0, CPHA=0\n- **模式 1**: CPOL=0, CPHA=1  \n- **模式 2**: CPOL=1, CPHA=0\n- **模式 3**: CPOL=1, CPHA=1\n\n## 技術規格\n- **最大速度**: 取決於設備和線路長度\n- **電壓等級**: 通常 3.3V 或 5V\n- **拓撲結構**: 星型連接\n- **同步通訊**: 主設備提供時鐘\n\n## 注意事項\n- 每個從設備需要獨立的 SS 引腳\n- 線路長度影響最大速度\n- 需要共同的接地\n- 不支援多主設備架構"
    },
    {
      "id": "arduino-bluetooth-hc05",
      "title": "藍牙模組 HC-05",
      "description": "HC-05 藍牙無線通訊控制",
      "code": "#include <SoftwareSerial.h>\n\n// 藍牙模組連接\nSoftwareSerial bluetooth(2, 3); // RX, TX\n\nString receivedData = \"\";\nboolean dataComplete = false;\n\nvoid setup() {\n  Serial.begin(9600);\n  bluetooth.begin(9600);\n  \n  Serial.println(\"Arduino 藍牙通訊啟動\");\n  Serial.println(\"輸入訊息發送到手機\");\n}\n\nvoid loop() {\n  // 從序列埠讀取並發送到藍牙\n  if (Serial.available()) {\n    String message = Serial.readString();\n    message.trim();\n    \n    bluetooth.println(message);\n    Serial.println(\"發送: \" + message);\n  }\n  \n  // 從藍牙接收數據\n  while (bluetooth.available()) {\n    char inChar = (char)bluetooth.read();\n    \n    if (inChar == '\\n') {\n      dataComplete = true;\n    } else {\n      receivedData += inChar;\n    }\n  }\n  \n  // 處理接收到的完整數據\n  if (dataComplete) {\n    Serial.println(\"接收: \" + receivedData);\n    \n    // 處理命令\n    processBluetoothCommand(receivedData);\n    \n    // 清除資料\n    receivedData = \"\";\n    dataComplete = false;\n  }\n}\n\nvoid processBluetoothCommand(String command) {\n  command.toLowerCase();\n  command.trim();\n  \n  if (command == \"led on\") {\n    digitalWrite(13, HIGH);\n    bluetooth.println(\"LED 已開啟\");\n    Serial.println(\"LED 已開啟\");\n    \n  } else if (command == \"led off\") {\n    digitalWrite(13, LOW);\n    bluetooth.println(\"LED 已關閉\");\n    Serial.println(\"LED 已關閉\");\n    \n  } else if (command == \"status\") {\n    String status = \"系統狀態:\\n\";\n    status += \"LED: \" + String(digitalRead(13) ? \"開啟\" : \"關閉\") + \"\\n\";\n    status += \"運行時間: \" + String(millis() / 1000) + \"秒\";\n    \n    bluetooth.println(status);\n    Serial.println(status);\n    \n  } else if (command.startsWith(\"analog\")) {\n    int pin = command.substring(6).toInt();\n    if (pin >= 0 && pin <= 5) {\n      int value = analogRead(pin);\n      String response = \"A\" + String(pin) + \": \" + String(value);\n      bluetooth.println(response);\n      Serial.println(response);\n    }\n    \n  } else {\n    bluetooth.println(\"未知命令: \" + command);\n    bluetooth.println(\"可用命令: LED ON, LED OFF, STATUS, ANALOG0-5\");\n  }\n}",
      "language": "arduino",
      "topic": "Arduino 顯示與通訊",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["通訊", "藍牙", "無線", "HC-05", "遠程控制", "原子式"]
      },
      "documentation": "# 藍牙模組 HC-05\n\n## 功能說明\nHC-05 是一款經典的藍牙 2.0 模組，支援 SPP (Serial Port Profile) 協議，可以與手機、電腦等設備進行無線串列通訊。\n\n## 工作原理\n- **藍牙 2.0**: 經典藍牙協議\n- **SPP 模式**: 串列埠協議模擬\n- **主從模式**: 可設定為主設備或從設備\n- **AT 命令**: 透過 AT 命令配置\n\n## 接線說明\n```\nHC-05 模組     Arduino Uno\nVCC         →  5V (或 3.3V)\nGND         →  GND\nTXD         →  Pin 2 (軟體序列埠 RX)\nRXD         →  Pin 3 (軟體序列埠 TX)\nEN/KEY      →  Pin 4 (可選，AT模式)\n```\n\n## 模組特性\n- **通訊距離**: 約 10 公尺\n- **傳輸速度**: 9600 bps (預設)\n- **工作電壓**: 3.3V - 5V\n- **工作電流**: 約 30mA\n- **配對密碼**: 預設 1234 或 0000\n\n## 技術規格\n- **藍牙版本**: 2.0 + EDR\n- **頻率範圍**: 2.4GHz ISM 頻段\n- **調變方式**: GFSK\n- **天線**: 內建 PCB 天線\n- **溫度範圍**: -20°C 到 +75°C\n\n## 注意事項\n- 配對前需要設定 AT 模式\n- RXD 引腳建議使用分壓電路 (5V→3.3V)\n- 避免與其他 2.4GHz 設備干擾\n- 連接狀態可透過狀態 LED 確認"
    },
    {
      "id": "arduino-uart-serial",
      "title": "UART 串列通訊",
      "description": "UART 硬體序列埠通訊基礎",
      "code": "void setup() {\n  // 初始化硬體序列埠\n  Serial.begin(9600);\n  \n  // 設定狀態 LED\n  pinMode(13, OUTPUT);\n  \n  Serial.println(\"UART 串列通訊啟動\");\n  Serial.println(\"請輸入命令:\");\n  Serial.println(\"- LED ON/OFF\");\n  Serial.println(\"- READ A0-A5\");\n  Serial.println(\"- STATUS\");\n}\n\nvoid loop() {\n  // 檢查是否有串列資料可讀取\n  if (Serial.available() > 0) {\n    String command = Serial.readStringUntil('\\n');\n    command.trim();\n    command.toUpperCase();\n    \n    processSerialCommand(command);\n  }\n  \n  // 定期發送心跳信號\n  static unsigned long lastHeartbeat = 0;\n  if (millis() - lastHeartbeat > 10000) { // 每10秒\n    Serial.println(\"[心跳] 系統運行正常 - \" + String(millis()/1000) + \"s\");\n    lastHeartbeat = millis();\n  }\n}\n\nvoid processSerialCommand(String cmd) {\n  Serial.println(\"收到命令: \" + cmd);\n  \n  if (cmd == \"LED ON\") {\n    digitalWrite(13, HIGH);\n    Serial.println(\"[OK] LED 已開啟\");\n    \n  } else if (cmd == \"LED OFF\") {\n    digitalWrite(13, LOW);\n    Serial.println(\"[OK] LED 已關閉\");\n    \n  } else if (cmd == \"STATUS\") {\n    printSystemStatus();\n    \n  } else if (cmd.startsWith(\"READ A\")) {\n    int pin = cmd.charAt(6) - '0';\n    if (pin >= 0 && pin <= 5) {\n      int value = analogRead(A0 + pin);\n      Serial.println(\"[DATA] A\" + String(pin) + \": \" + String(value));\n    } else {\n      Serial.println(\"[ERROR] 無效的類比腳位: A\" + String(pin));\n    }\n    \n  } else if (cmd == \"HELP\") {\n    printHelp();\n    \n  } else {\n    Serial.println(\"[ERROR] 未知命令: \" + cmd);\n    Serial.println(\"輸入 HELP 查看可用命令\");\n  }\n}\n\nvoid printSystemStatus() {\n  Serial.println(\"=== 系統狀態 ===\");\n  Serial.println(\"運行時間: \" + String(millis()/1000) + \" 秒\");\n  Serial.println(\"LED 狀態: \" + String(digitalRead(13) ? \"開啟\" : \"關閉\"));\n  Serial.println(\"自由記憶體: \" + String(getFreeMemory()) + \" bytes\");\n  \n  Serial.println(\"\\n=== 類比輸入 ===\");\n  for (int i = 0; i < 6; i++) {\n    Serial.println(\"A\" + String(i) + \": \" + String(analogRead(A0 + i)));\n  }\n  \n  Serial.println(\"================\");\n}\n\nvoid printHelp() {\n  Serial.println(\"=== 可用命令 ===\");\n  Serial.println(\"LED ON      - 開啟 LED\");\n  Serial.println(\"LED OFF     - 關閉 LED\");\n  Serial.println(\"READ A0-A5  - 讀取類比輸入\");\n  Serial.println(\"STATUS      - 顯示系統狀態\");\n  Serial.println(\"HELP        - 顯示此說明\");\n  Serial.println(\"================\");\n}\n\n// 簡單的記憶體檢查函數\nint getFreeMemory() {\n  extern int __heap_start, *__brkval;\n  int v;\n  return (int)&v - (__brkval == 0 ? (int)&__heap_start : (int)__brkval);\n}\n\n// 格式化數據發送\nvoid sendFormattedData(String type, String data) {\n  Serial.println(\"[\" + type + \"] \" + data);\n}\n\n// 發送 JSON 格式數據\nvoid sendJSONData() {\n  Serial.println(\"{\");\n  Serial.println(\"  \\\"timestamp\\\": \" + String(millis()) + \",\");\n  Serial.println(\"  \\\"led_status\\\": \" + String(digitalRead(13)) + \",\");\n  Serial.print(\"  \\\"analog_inputs\\\": [\");\n  \n  for (int i = 0; i < 6; i++) {\n    Serial.print(analogRead(A0 + i));\n    if (i < 5) Serial.print(\", \");\n  }\n  \n  Serial.println(\"],\");\n  Serial.println(\"  \\\"free_memory\\\": \" + String(getFreeMemory()));\n  Serial.println(\"}\");\n}",
      "language": "arduino",
      "topic": "Arduino 顯示與通訊",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["通訊", "UART", "序列埠", "命令解析", "原子式"]
      },
      "documentation": "# UART 串列通訊\n\n## 功能說明\nUART (Universal Asynchronous Receiver-Transmitter) 是一種異步串列通訊協議，Arduino 內建硬體 UART 支援，常用於與電腦或其他微控制器通訊。\n\n## 工作原理\n- **異步通訊**: 不需要共同時鐘信號\n- **全雙工**: 同時發送和接收\n- **資料格式**: 起始位 + 資料位 + 停止位\n- **錯誤檢測**: 可選奇偶校驗位\n\n## Arduino UART 引腳\n```\nArduino Uno:\nTX (傳送) → Pin 1\nRX (接收) → Pin 0\n\n注意: Pin 0, 1 同時用於 USB 通訊\n```\n\n## 通訊特性\n- **傳輸速度**: 常用 9600, 38400, 115200 bps\n- **資料位**: 通常 8 位元\n- **停止位**: 1 或 2 位元\n- **奇偶校驗**: 無、奇數、偶數\n\n## 傳輸格式\n```\n起始位(0) + 8資料位 + 停止位(1)\n例如: 0 11010101 1\n```\n\n## 常用鮑率\n- **9600**: 低速穩定，適合簡單應用\n- **38400**: 中速，平衡速度與穩定性\n- **115200**: 高速，適合大量資料傳輸\n\n## 技術規格\n- **電壓等級**: TTL (0V/5V) 或 RS232 (±12V)\n- **最大距離**: TTL 約 1m，RS232 約 15m\n- **同步方式**: 異步 (無時鐘線)\n- **錯誤處理**: 軟體層面實現\n\n## 注意事項\n- USB 連接時 Pin 0,1 被佔用\n- 需要共同接地 (GND)\n- 雙方必須使用相同鮑率\n- 長距離通訊考慮使用 RS232 轉換器"
    },
    {
      "id": "arduino-sd-card",
      "title": "SD 卡讀寫",
      "description": "SD 卡檔案系統讀寫操作",
      "code": "#include <SD.h>\n#include <SPI.h>\n\nconst int chipSelect = 10;\nFile dataFile;\n\nvoid setup() {\n  Serial.begin(9600);\n  \n  Serial.println(\"SD 卡初始化...\");\n  \n  if (!SD.begin(chipSelect)) {\n    Serial.println(\"SD 卡初始化失敗！\");\n    Serial.println(\"檢查:\");\n    Serial.println(\"- SD 卡是否正確插入\");\n    Serial.println(\"- 接線是否正確\");\n    Serial.println(\"- SD 卡是否格式化為 FAT16/FAT32\");\n    while (1);\n  }\n  \n  Serial.println(\"SD 卡初始化成功！\");\n  \n  // 顯示 SD 卡資訊\n  printSDInfo();\n  \n  // 測試寫入檔案\n  writeTestFile();\n  \n  // 測試讀取檔案\n  readTestFile();\n}\n\nvoid loop() {\n  // 每 5 秒記錄一次數據\n  logSensorData();\n  delay(5000);\n}\n\nvoid printSDInfo() {\n  Serial.println(\"\\n=== SD 卡資訊 ===\");\n  \n  Sd2Card card;\n  SdVolume volume;\n  \n  if (!card.init(SPI_HALF_SPEED, chipSelect)) {\n    Serial.println(\"無法讀取 SD 卡資訊\");\n    return;\n  }\n  \n  Serial.print(\"SD 卡類型: \");\n  switch (card.type()) {\n    case SD_CARD_TYPE_SD1:\n      Serial.println(\"SD1\");\n      break;\n    case SD_CARD_TYPE_SD2:\n      Serial.println(\"SD2\");\n      break;\n    case SD_CARD_TYPE_SDHC:\n      Serial.println(\"SDHC\");\n      break;\n    default:\n      Serial.println(\"未知\");\n  }\n  \n  if (!volume.init(card)) {\n    Serial.println(\"無法讀取 FAT 檔案系統\");\n    return;\n  }\n  \n  Serial.print(\"檔案系統類型: FAT\");\n  Serial.println(volume.fatType(), DEC);\n  \n  uint32_t volumesize = volume.blocksPerCluster();\n  volumesize *= volume.clusterCount();\n  volumesize /= 2; // 轉換為 KB\n  \n  Serial.print(\"總容量: \");\n  Serial.print(volumesize / 1024);\n  Serial.println(\" MB\");\n  \n  Serial.println(\"================\");\n}\n\nvoid writeTestFile() {\n  Serial.println(\"\\n寫入測試檔案...\");\n  \n  dataFile = SD.open(\"test.txt\", FILE_WRITE);\n  \n  if (dataFile) {\n    dataFile.println(\"Arduino SD 卡測試\");\n    dataFile.println(\"時間戳: \" + String(millis()));\n    dataFile.println(\"系統啟動成功\");\n    dataFile.close();\n    \n    Serial.println(\"測試檔案寫入成功\");\n  } else {\n    Serial.println(\"無法開啟測試檔案進行寫入\");\n  }\n}\n\nvoid readTestFile() {\n  Serial.println(\"\\n讀取測試檔案...\");\n  \n  dataFile = SD.open(\"test.txt\");\n  \n  if (dataFile) {\n    Serial.println(\"檔案內容:\");\n    \n    while (dataFile.available()) {\n      Serial.write(dataFile.read());\n    }\n    \n    dataFile.close();\n    Serial.println(\"\\n檔案讀取完成\");\n  } else {\n    Serial.println(\"無法開啟測試檔案進行讀取\");\n  }\n}\n\nvoid logSensorData() {\n  // 讀取感測器數據\n  int temperature = analogRead(A0);\n  int humidity = analogRead(A1);\n  int light = analogRead(A2);\n  \n  unsigned long timestamp = millis();\n  \n  // 寫入 CSV 格式的數據檔案\n  dataFile = SD.open(\"sensors.csv\", FILE_WRITE);\n  \n  if (dataFile) {\n    // 如果檔案是新建的，先寫入標題行\n    if (dataFile.size() == 0) {\n      dataFile.println(\"Timestamp,Temperature,Humidity,Light\");\n    }\n    \n    // 寫入數據\n    dataFile.print(timestamp);\n    dataFile.print(\",\");\n    dataFile.print(temperature);\n    dataFile.print(\",\");\n    dataFile.print(humidity);\n    dataFile.print(\",\");\n    dataFile.println(light);\n    \n    dataFile.close();\n    \n    Serial.println(\"數據已記錄: \" + String(timestamp) + \n                   \", T:\" + String(temperature) +\n                   \", H:\" + String(humidity) +\n                   \", L:\" + String(light));\n  } else {\n    Serial.println(\"無法開啟數據檔案進行寫入\");\n  }\n}\n\nvoid listFiles() {\n  Serial.println(\"\\n=== SD 卡檔案列表 ===\");\n  \n  File root = SD.open(\"/\");\n  \n  while (true) {\n    File entry = root.openNextFile();\n    \n    if (!entry) {\n      break; // 沒有更多檔案\n    }\n    \n    Serial.print(entry.name());\n    if (entry.isDirectory()) {\n      Serial.println(\"/\");\n    } else {\n      Serial.print(\"\\t\\t\");\n      Serial.print(entry.size(), DEC);\n      Serial.println(\" bytes\");\n    }\n    \n    entry.close();\n  }\n  \n  root.close();\n  Serial.println(\"===================\");\n}\n\nvoid deleteFile(String filename) {\n  if (SD.exists(filename)) {\n    SD.remove(filename);\n    Serial.println(\"檔案已刪除: \" + filename);\n  } else {\n    Serial.println(\"檔案不存在: \" + filename);\n  }\n}",
      "language": "arduino",
      "topic": "Arduino 顯示與通訊",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["儲存", "SD卡", "檔案系統", "資料記錄", "SPI", "原子式"]
      },
      "documentation": "# SD 卡讀寫\n\n## 功能說明\nSD 卡是常用的可移除儲存媒體，Arduino 可透過 SPI 介面讀寫 SD 卡，實現大容量資料儲存和檔案系統操作。\n\n## 工作原理\n- **SPI 通訊**: 透過 SPI 協議與 SD 卡通訊\n- **FAT 檔案系統**: 支援 FAT16/FAT32 格式\n- **檔案操作**: 建立、讀取、寫入、刪除檔案\n- **目錄管理**: 支援目錄結構\n\n## 接線說明\n```\nSD 卡模組     Arduino Uno\nVCC        →  5V (或 3.3V)\nGND        →  GND\nMOSI       →  Pin 11\nMISO       →  Pin 12\nSCK        →  Pin 13\nCS         →  Pin 10 (可自定義)\n```\n\n## 檔案系統支援\n- **格式**: FAT16、FAT32\n- **檔案名**: 8.3 格式 (如 DATA.TXT)\n- **目錄**: 支援多層目錄結構\n- **檔案大小**: 最大 4GB (FAT32)\n\n## 應用場景\n- **資料記錄**: 感測器數據長期記錄\n- **設定檔**: 系統參數儲存\n- **音頻播放**: 音頻檔案播放\n- **圖片顯示**: 圖像檔案讀取\n- **韌體更新**: 程式更新檔案\n\n## 技術規格\n- **容量**: 通常 512MB - 32GB\n- **速度**: 取決於卡片等級 (Class 2-10)\n- **電壓**: 3.3V (模組通常支援 5V)\n- **介面**: SPI (最大約 25MHz)\n- **檔案數**: 理論上無限制\n\n## 注意事項\n- SD 卡必須格式化為 FAT16 或 FAT32\n- 檔案名稱建議使用英文\n- 避免在寫入過程中斷電\n- 定期檢查 SD 卡健康狀況\n- 使用優質 SD 卡提高可靠性"
    },
    {
      "id": "esp32-wifi-basic",
      "title": "WiFi 基礎連接",
      "description": "ESP32 WiFi 網路連接基礎設定",
      "code": "#include <WiFi.h>\n\n// WiFi 憑證\nconst char* ssid = \"你的WiFi名稱\";\nconst char* password = \"你的WiFi密碼\";\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(1000);\n  \n  Serial.println();\n  Serial.println(\"ESP32 WiFi 連接測試\");\n  \n  // 開始 WiFi 連接\n  WiFi.begin(ssid, password);\n  Serial.print(\"正在連接到 WiFi\");\n  \n  // 等待連接\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  \n  // 連接成功\n  Serial.println();\n  Serial.println(\"WiFi 連接成功！\");\n  Serial.print(\"IP 地址: \");\n  Serial.println(WiFi.localIP());\n  Serial.print(\"MAC 地址: \");\n  Serial.println(WiFi.macAddress());\n  Serial.print(\"信號強度: \");\n  Serial.print(WiFi.RSSI());\n  Serial.println(\" dBm\");\n}\n\nvoid loop() {\n  // 檢查 WiFi 連接狀態\n  if (WiFi.status() == WL_CONNECTED) {\n    Serial.println(\"WiFi 已連接\");\n  } else {\n    Serial.println(\"WiFi 連接中斷，重新連接...\");\n    WiFi.begin(ssid, password);\n  }\n  \n  delay(10000); // 每 10 秒檢查一次\n}",
      "language": "esp32",
      "topic": "ESP32 物聯網基礎",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "beginner",
        "tags": ["WiFi", "網路連接", "基礎設定", "ESP32", "原子式"]
      },
      "documentation": "# ESP32 WiFi 基礎連接\n\n## 功能說明\nESP32 內建 WiFi 功能，可以連接到無線網路，是物聯網應用的基礎。本模板展示如何建立基本的 WiFi 連接。\n\n## 工作原理\n- **STA 模式**: ESP32 作為 Station 連接到路由器\n- **自動重連**: 檢測斷線並自動重新連接\n- **狀態監控**: 即時監控連接狀態\n- **網路資訊**: 顯示 IP、MAC 地址等資訊\n\n## 基本設定\n```cpp\n// 修改你的 WiFi 憑證\nconst char* ssid = \"你的WiFi名稱\";\nconst char* password = \"你的WiFi密碼\";\n```\n\n## WiFi 狀態代碼\n- **WL_CONNECTED (3)**: 已連接\n- **WL_NO_SSID_AVAIL (1)**: 找不到 SSID\n- **WL_CONNECT_FAILED (4)**: 連接失敗\n- **WL_CONNECTION_LOST (5)**: 連接丟失\n- **WL_DISCONNECTED (6)**: 已斷開連接\n\n## 連接資訊\n- **IP 地址**: WiFi.localIP()\n- **MAC 地址**: WiFi.macAddress()\n- **信號強度**: WiFi.RSSI() (dBm)\n- **網關**: WiFi.gatewayIP()\n- **子網掩碼**: WiFi.subnetMask()\n- **DNS**: WiFi.dnsIP()\n\n## 技術規格\n- **WiFi 標準**: 802.11 b/g/n\n- **頻率**: 2.4 GHz\n- **加密**: WEP/WPA/WPA2\n- **傳輸距離**: 室內約 50m\n- **最大速度**: 150 Mbps\n\n## 注意事項\n- 確保 WiFi 名稱和密碼正確\n- ESP32 僅支援 2.4GHz WiFi\n- 信號強度影響連接穩定性\n- 建議使用 WPA2 加密\n- 避免使用特殊字元的 SSID"
    },
    {
      "id": "esp32-web-server",
      "title": "簡易網頁伺服器",
      "description": "ESP32 架設基礎 HTTP 網頁伺服器",
      "code": "#include <WiFi.h>\n#include <WebServer.h>\n\n// WiFi 憑證\nconst char* ssid = \"你的WiFi名稱\";\nconst char* password = \"你的WiFi密碼\";\n\n// 建立網頁伺服器物件\nWebServer server(80);\n\n// LED 控制腳位\nconst int ledPin = 2;\nboolean ledState = false;\n\nvoid setup() {\n  Serial.begin(115200);\n  \n  // 設定 LED 腳位\n  pinMode(ledPin, OUTPUT);\n  digitalWrite(ledPin, LOW);\n  \n  // 連接 WiFi\n  WiFi.begin(ssid, password);\n  Serial.print(\"連接到 WiFi\");\n  \n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  \n  Serial.println();\n  Serial.println(\"WiFi 連接成功\");\n  Serial.print(\"網頁伺服器地址: http://\");\n  Serial.println(WiFi.localIP());\n  \n  // 設定路由\n  server.on(\"/\", handleRoot);\n  server.on(\"/led/on\", handleLedOn);\n  server.on(\"/led/off\", handleLedOff);\n  server.on(\"/status\", handleStatus);\n  server.onNotFound(handleNotFound);\n  \n  // 啟動伺服器\n  server.begin();\n  Serial.println(\"HTTP 伺服器已啟動\");\n}\n\nvoid loop() {\n  server.handleClient();\n}\n\nvoid handleRoot() {\n  String html = \"<html><head><title>ESP32 控制面板</title></head>\";\n  html += \"<body><h1>ESP32 LED 控制</h1>\";\n  html += \"<p>LED 狀態: \" + String(ledState ? \"開啟\" : \"關閉\") + \"</p>\";\n  html += \"<p><a href='/led/on'><button>開啟 LED</button></a></p>\";\n  html += \"<p><a href='/led/off'><button>關閉 LED</button></a></p>\";\n  html += \"<p><a href='/status'><button>系統狀態</button></a></p>\";\n  html += \"</body></html>\";\n  \n  server.send(200, \"text/html\", html);\n}\n\nvoid handleLedOn() {\n  digitalWrite(ledPin, HIGH);\n  ledState = true;\n  \n  String html = \"<html><body>\";\n  html += \"<h2>LED 已開啟</h2>\";\n  html += \"<p><a href='/'>返回主頁</a></p>\";\n  html += \"</body></html>\";\n  \n  server.send(200, \"text/html\", html);\n  Serial.println(\"LED 開啟\");\n}\n\nvoid handleLedOff() {\n  digitalWrite(ledPin, LOW);\n  ledState = false;\n  \n  String html = \"<html><body>\";\n  html += \"<h2>LED 已關閉</h2>\";\n  html += \"<p><a href='/'>返回主頁</a></p>\";\n  html += \"</body></html>\";\n  \n  server.send(200, \"text/html\", html);\n  Serial.println(\"LED 關閉\");\n}\n\nvoid handleStatus() {\n  String html = \"<html><body>\";\n  html += \"<h2>系統狀態</h2>\";\n  html += \"<p>WiFi SSID: \" + WiFi.SSID() + \"</p>\";\n  html += \"<p>IP 地址: \" + WiFi.localIP().toString() + \"</p>\";\n  html += \"<p>信號強度: \" + String(WiFi.RSSI()) + \" dBm</p>\";\n  html += \"<p>運行時間: \" + String(millis() / 1000) + \" 秒</p>\";\n  html += \"<p>可用記憶體: \" + String(ESP.getFreeHeap()) + \" bytes</p>\";\n  html += \"<p><a href='/'>返回主頁</a></p>\";\n  html += \"</body></html>\";\n  \n  server.send(200, \"text/html\", html);\n}\n\nvoid handleNotFound() {\n  String html = \"<html><body>\";\n  html += \"<h2>404 - 頁面未找到</h2>\";\n  html += \"<p>請求的頁面不存在</p>\";\n  html += \"<p><a href='/'>返回主頁</a></p>\";\n  html += \"</body></html>\";\n  \n  server.send(404, \"text/html\", html);\n}",
      "language": "esp32",
      "topic": "ESP32 物聯網基礎",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["網頁伺服器", "HTTP", "網頁控制", "LED控制", "原子式"]
      },
      "documentation": "# ESP32 簡易網頁伺服器\n\n## 功能說明\nESP32 可以架設 HTTP 網頁伺服器，透過瀏覽器控制硬體設備。本模板展示如何建立簡單的網頁控制介面。\n\n## 工作原理\n- **HTTP 伺服器**: 監聽 80 埠接收 HTTP 請求\n- **路由處理**: 根據 URL 執行不同功能\n- **HTML 回應**: 產生動態 HTML 頁面\n- **即時控制**: 透過網頁即時控制 LED\n\n## 路由說明\n- **/** - 主頁面，顯示控制介面\n- **/led/on** - 開啟 LED\n- **/led/off** - 關閉 LED\n- **/status** - 系統狀態頁面\n\n## 使用方式\n1. 上傳程式到 ESP32\n2. 開啟序列埠監視器查看 IP 地址\n3. 在瀏覽器輸入 IP 地址\n4. 透過網頁按鈕控制 LED\n\n## HTTP 狀態碼\n- **200 OK**: 請求成功\n- **404 Not Found**: 頁面未找到\n- **500 Internal Server Error**: 伺服器錯誤\n\n## 安全考量\n- 此為基礎範例，未包含身份驗證\n- 建議在生產環境加入密碼保護\n- 考慮使用 HTTPS 加密連接\n- 限制存取的 IP 範圍\n\n## 擴展功能\n- 加入感測器數據顯示\n- 實現 AJAX 動態更新\n- 添加使用者認證\n- 支援更多控制元件\n- 美化 CSS 樣式\n\n## 技術規格\n- **HTTP 版本**: 1.1\n- **預設埠**: 80\n- **同時連接**: 4-8 個客戶端\n- **回應時間**: 通常 < 100ms\n- **HTML 大小**: 建議 < 8KB\n\n## 注意事項\n- ESP32 和控制設備需在同一網路\n- 避免 HTML 內容過大\n- 注意記憶體使用量\n- 定期檢查 WiFi 連接狀態"
    },
    {
      "id": "esp32-http-client",
      "title": "HTTP 客戶端請求",
      "description": "ESP32 發送 HTTP GET/POST 請求",
      "code": "#include <WiFi.h>\n#include <HTTPClient.h>\n#include <ArduinoJson.h>\n\n// WiFi 憑證\nconst char* ssid = \"你的WiFi名稱\";\nconst char* password = \"你的WiFi密碼\";\n\n// API 設定\nconst char* serverURL = \"http://httpbin.org\";  // 測試伺服器\n\nvoid setup() {\n  Serial.begin(115200);\n  \n  // 連接 WiFi\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  \n  Serial.println();\n  Serial.println(\"WiFi 連接成功\");\n  Serial.print(\"IP 地址: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid loop() {\n  if (WiFi.status() == WL_CONNECTED) {\n    // 測試 GET 請求\n    performGETRequest();\n    delay(5000);\n    \n    // 測試 POST 請求\n    performPOSTRequest();\n    delay(5000);\n    \n    // 發送感測器數據\n    sendSensorData();\n    delay(10000);\n  } else {\n    Serial.println(\"WiFi 斷線\");\n    delay(1000);\n  }\n}\n\nvoid performGETRequest() {\n  HTTPClient http;\n  \n  // 發送 GET 請求\n  http.begin(String(serverURL) + \"/get?sensor=temperature&value=25.6\");\n  http.addHeader(\"User-Agent\", \"ESP32-Client\");\n  \n  int httpResponseCode = http.GET();\n  \n  if (httpResponseCode > 0) {\n    String response = http.getString();\n    Serial.println(\"=== GET 請求回應 ===\");\n    Serial.print(\"狀態碼: \");\n    Serial.println(httpResponseCode);\n    Serial.println(\"回應內容:\");\n    Serial.println(response);\n    Serial.println(\"=====================\");\n  } else {\n    Serial.print(\"GET 請求錯誤: \");\n    Serial.println(httpResponseCode);\n  }\n  \n  http.end();\n}\n\nvoid performPOSTRequest() {\n  HTTPClient http;\n  \n  // 準備 JSON 數據\n  DynamicJsonDocument doc(1024);\n  doc[\"device\"] = \"ESP32\";\n  doc[\"temperature\"] = 25.6;\n  doc[\"humidity\"] = 65.3;\n  doc[\"timestamp\"] = millis();\n  \n  String jsonString;\n  serializeJson(doc, jsonString);\n  \n  // 發送 POST 請求\n  http.begin(String(serverURL) + \"/post\");\n  http.addHeader(\"Content-Type\", \"application/json\");\n  http.addHeader(\"User-Agent\", \"ESP32-Client\");\n  \n  int httpResponseCode = http.POST(jsonString);\n  \n  if (httpResponseCode > 0) {\n    String response = http.getString();\n    Serial.println(\"=== POST 請求回應 ===\");\n    Serial.print(\"狀態碼: \");\n    Serial.println(httpResponseCode);\n    Serial.print(\"發送的數據: \");\n    Serial.println(jsonString);\n    Serial.println(\"回應內容:\");\n    Serial.println(response);\n    Serial.println(\"======================\");\n  } else {\n    Serial.print(\"POST 請求錯誤: \");\n    Serial.println(httpResponseCode);\n  }\n  \n  http.end();\n}\n\nvoid sendSensorData() {\n  // 模擬感測器讀取\n  float temperature = 20.0 + random(0, 100) / 10.0;  // 20.0-30.0°C\n  float humidity = 40.0 + random(0, 400) / 10.0;     // 40.0-80.0%\n  int lightLevel = random(0, 1024);                  // 0-1023\n  \n  HTTPClient http;\n  \n  // 建立查詢字串\n  String url = String(serverURL) + \"/get\";\n  url += \"?temperature=\" + String(temperature, 2);\n  url += \"&humidity=\" + String(humidity, 2);\n  url += \"&light=\" + String(lightLevel);\n  url += \"&device=ESP32\";\n  \n  http.begin(url);\n  int httpResponseCode = http.GET();\n  \n  Serial.println(\"=== 感測器數據傳送 ===\");\n  Serial.println(\"溫度: \" + String(temperature, 2) + \"°C\");\n  Serial.println(\"濕度: \" + String(humidity, 2) + \"%\");\n  Serial.println(\"光線: \" + String(lightLevel));\n  \n  if (httpResponseCode == 200) {\n    Serial.println(\"數據傳送成功\");\n  } else {\n    Serial.print(\"傳送失敗，錯誤碼: \");\n    Serial.println(httpResponseCode);\n  }\n  \n  http.end();\n  Serial.println(\"=========================\");\n}\n\n// 檢查網路連接並重連\nvoid checkWiFiConnection() {\n  if (WiFi.status() != WL_CONNECTED) {\n    Serial.println(\"WiFi 連接中斷，嘗試重連...\");\n    WiFi.begin(ssid, password);\n    \n    int attempts = 0;\n    while (WiFi.status() != WL_CONNECTED && attempts < 20) {\n      delay(500);\n      Serial.print(\".\");\n      attempts++;\n    }\n    \n    if (WiFi.status() == WL_CONNECTED) {\n      Serial.println(\"\\nWiFi 重連成功\");\n    } else {\n      Serial.println(\"\\nWiFi 重連失敗\");\n    }\n  }\n}",
      "language": "esp32",
      "topic": "ESP32 物聯網基礎",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["HTTP客戶端", "API請求", "GET", "POST", "JSON", "原子式"]
      },
      "documentation": "# ESP32 HTTP 客戶端請求\n\n## 功能說明\nESP32 可以作為 HTTP 客戶端向網路伺服器發送請求，這是物聯網設備與雲端服務通訊的基礎功能。\n\n## 工作原理\n- **HTTP 客戶端**: 主動發送 HTTP 請求\n- **GET 請求**: 從伺服器獲取資料\n- **POST 請求**: 向伺服器發送資料\n- **JSON 格式**: 結構化資料交換\n\n## 必要函式庫\n```cpp\n#include <WiFi.h>        // WiFi 連接\n#include <HTTPClient.h>  // HTTP 客戶端\n#include <ArduinoJson.h> // JSON 處理\n```\n\n## HTTP 方法\n- **GET**: 請求資料，參數在 URL 中\n- **POST**: 提交資料，參數在請求主體中\n- **PUT**: 更新資料\n- **DELETE**: 刪除資料\n\n## 常用狀態碼\n- **200 OK**: 請求成功\n- **400 Bad Request**: 請求格式錯誤\n- **401 Unauthorized**: 未授權\n- **404 Not Found**: 資源未找到\n- **500 Internal Server Error**: 伺服器錯誤\n\n## JSON 資料處理\n```cpp\n// 建立 JSON\nDynamicJsonDocument doc(1024);\ndoc[\"key\"] = \"value\";\nString jsonString;\nserializeJson(doc, jsonString);\n\n// 解析 JSON\nDynamicJsonDocument responseDoc(1024);\ndeserializeJson(responseDoc, response);\nString value = responseDoc[\"key\"];\n```\n\n## 安全考量\n- 使用 HTTPS 加密敏感資料\n- 驗證伺服器憑證\n- 避免在程式碼中硬編碼密鑰\n- 實施適當的錯誤處理\n\n## 應用場景\n- **感測器數據上傳**: 定期發送感測器數據\n- **遠程控制**: 從雲端接收控制命令\n- **韌體更新**: OTA 更新檢查\n- **第三方 API**: 天氣、時間等外部服務\n- **資料同步**: 與資料庫或雲端平台同步\n\n## 效能優化\n- 重用 HTTPClient 物件\n- 設定適當的超時時間\n- 使用 Keep-Alive 連接\n- 壓縮大型請求\n- 批量處理多個請求\n\n## 注意事項\n- 檢查網路連接狀態\n- 處理請求超時\n- 限制請求頻率避免被封鎖\n- 監控記憶體使用量\n- 記錄錯誤便於除錯"
    },
    {
      "id": "esp32-mqtt-basic",
      "title": "MQTT 基礎通訊",
      "description": "ESP32 MQTT 發布訂閱消息通訊",
      "code": "#include <WiFi.h>\n#include <PubSubClient.h>\n#include <ArduinoJson.h>\n\n// WiFi 憑證\nconst char* ssid = \"你的WiFi名稱\";\nconst char* password = \"你的WiFi密碼\";\n\n// MQTT 設定\nconst char* mqtt_server = \"broker.emqx.io\";  // 公用 MQTT broker\nconst int mqtt_port = 1883;\nconst char* mqtt_user = \"\";      // 如果需要認證\nconst char* mqtt_pass = \"\";\nconst char* client_id = \"ESP32Client\";\n\n// MQTT 主題\nconst char* topic_sensor = \"esp32/sensors\";\nconst char* topic_control = \"esp32/control\";\nconst char* topic_status = \"esp32/status\";\n\nWiFiClient espClient;\nPubSubClient client(espClient);\n\nlong lastMsg = 0;\nint value = 0;\n\nvoid setup() {\n  Serial.begin(115200);\n  \n  // 設定 LED\n  pinMode(2, OUTPUT);\n  \n  // 連接 WiFi\n  setup_wifi();\n  \n  // 設定 MQTT\n  client.setServer(mqtt_server, mqtt_port);\n  client.setCallback(callback);\n}\n\nvoid setup_wifi() {\n  delay(10);\n  Serial.println();\n  Serial.print(\"連接到 WiFi: \");\n  Serial.println(ssid);\n  \n  WiFi.begin(ssid, password);\n  \n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  \n  Serial.println();\n  Serial.println(\"WiFi 連接成功\");\n  Serial.print(\"IP 地址: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid callback(char* topic, byte* message, unsigned int length) {\n  Serial.print(\"收到訊息於主題: \");\n  Serial.print(topic);\n  Serial.print(\". 訊息: \");\n  \n  String messageTemp;\n  for (int i = 0; i < length; i++) {\n    Serial.print((char)message[i]);\n    messageTemp += (char)message[i];\n  }\n  Serial.println();\n  \n  // 處理控制訊息\n  if (String(topic) == topic_control) {\n    // 解析 JSON 訊息\n    DynamicJsonDocument doc(1024);\n    deserializeJson(doc, messageTemp);\n    \n    if (doc[\"led\"] == \"on\") {\n      digitalWrite(2, HIGH);\n      Serial.println(\"LED 開啟\");\n      publishStatus(\"LED 已開啟\");\n    } else if (doc[\"led\"] == \"off\") {\n      digitalWrite(2, LOW);\n      Serial.println(\"LED 關閉\");\n      publishStatus(\"LED 已關閉\");\n    }\n  }\n}\n\nvoid reconnect() {\n  // 重新連接到 MQTT broker\n  while (!client.connected()) {\n    Serial.print(\"嘗試連接 MQTT...\");\n    \n    // 嘗試連接\n    if (client.connect(client_id, mqtt_user, mqtt_pass)) {\n      Serial.println(\"連接成功\");\n      \n      // 訂閱主題\n      client.subscribe(topic_control);\n      Serial.print(\"訂閱主題: \");\n      Serial.println(topic_control);\n      \n      // 發布上線訊息\n      publishStatus(\"ESP32 已上線\");\n      \n    } else {\n      Serial.print(\"連接失敗，錯誤碼=\");\n      Serial.print(client.state());\n      Serial.println(\" 5秒後重試\");\n      delay(5000);\n    }\n  }\n}\n\nvoid loop() {\n  if (!client.connected()) {\n    reconnect();\n  }\n  client.loop();\n  \n  // 每10秒發布感測器數據\n  long now = millis();\n  if (now - lastMsg > 10000) {\n    lastMsg = now;\n    \n    // 模擬感測器數據\n    float temperature = 20.0 + random(0, 100) / 10.0;\n    float humidity = 40.0 + random(0, 400) / 10.0;\n    int lightLevel = random(0, 1024);\n    \n    // 發布感測器數據\n    publishSensorData(temperature, humidity, lightLevel);\n  }\n}\n\nvoid publishSensorData(float temp, float hum, int light) {\n  // 建立 JSON 數據\n  DynamicJsonDocument doc(1024);\n  doc[\"device\"] = \"ESP32\";\n  doc[\"timestamp\"] = millis();\n  doc[\"temperature\"] = temp;\n  doc[\"humidity\"] = hum;\n  doc[\"light\"] = light;\n  doc[\"wifi_rssi\"] = WiFi.RSSI();\n  \n  String jsonString;\n  serializeJson(doc, jsonString);\n  \n  // 發布到 MQTT\n  if (client.publish(topic_sensor, jsonString.c_str())) {\n    Serial.println(\"感測器數據已發布: \" + jsonString);\n  } else {\n    Serial.println(\"感測器數據發布失敗\");\n  }\n}\n\nvoid publishStatus(String status) {\n  DynamicJsonDocument doc(512);\n  doc[\"device\"] = \"ESP32\";\n  doc[\"timestamp\"] = millis();\n  doc[\"status\"] = status;\n  doc[\"uptime\"] = millis() / 1000;\n  doc[\"free_heap\"] = ESP.getFreeHeap();\n  \n  String jsonString;\n  serializeJson(doc, jsonString);\n  \n  if (client.publish(topic_status, jsonString.c_str())) {\n    Serial.println(\"狀態已發布: \" + status);\n  }\n}\n\n// 發布 Last Will 遺囑訊息（離線通知）\nvoid setupLastWill() {\n  DynamicJsonDocument doc(512);\n  doc[\"device\"] = \"ESP32\";\n  doc[\"status\"] = \"離線\";\n  doc[\"timestamp\"] = millis();\n  \n  String jsonString;\n  serializeJson(doc, jsonString);\n  \n  // 設定遺囑訊息\n  client.connect(client_id, mqtt_user, mqtt_pass, \n                 topic_status, 1, true, jsonString.c_str());\n}",
      "language": "esp32",
      "topic": "ESP32 物聯網基礎",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["MQTT", "發布訂閱", "物聯網通訊", "即時消息", "原子式"]
      },
      "documentation": "# ESP32 MQTT 基礎通訊\n\n## 功能說明\nMQTT (Message Queuing Telemetry Transport) 是一種輕量級的發布/訂閱消息協議，特別適合物聯網設備之間的通訊。\n\n## 工作原理\n- **發布/訂閱模式**: 設備可以發布訊息或訂閱特定主題\n- **MQTT Broker**: 中介伺服器負責轉發訊息\n- **主題 (Topic)**: 用於分類和路由訊息\n- **QoS**: 訊息傳遞品質保證\n\n## 必要函式庫\n```cpp\n#include <WiFi.h>        // WiFi 連接\n#include <PubSubClient.h> // MQTT 客戶端\n#include <ArduinoJson.h> // JSON 數據處理\n```\n\n## MQTT QoS 等級\n- **QoS 0**: 最多傳遞一次 (Fire and Forget)\n- **QoS 1**: 至少傳遞一次 (At Least Once)\n- **QoS 2**: 確實傳遞一次 (Exactly Once)\n\n## 主題命名規範\n- 使用 `/` 分隔階層\n- 避免以 `/` 開頭\n- 使用有意義的名稱\n- 例如: `device/sensor/temperature`\n\n## 常用 MQTT Broker\n- **broker.emqx.io**: 公用測試 broker\n- **test.mosquitto.org**: Eclipse 測試 broker\n- **AWS IoT Core**: Amazon 雲端服務\n- **Azure IoT Hub**: Microsoft 雲端服務\n- **Google Cloud IoT**: Google 雲端服務\n\n## 訊息格式\n建議使用 JSON 格式結構化資料：\n```json\n{\n  \"device\": \"ESP32\",\n  \"timestamp\": 1234567890,\n  \"temperature\": 25.6,\n  \"humidity\": 65.3\n}\n```\n\n## 安全考量\n- 使用 TLS/SSL 加密 (MQTTS)\n- 實施用戶名和密碼認證\n- 限制主題存取權限\n- 定期更新憑證\n- 監控異常流量\n\n## 應用場景\n- **感測器網路**: 大量感測器資料收集\n- **遠程監控**: 即時設備狀態監控\n- **智慧家居**: 設備間協調通訊\n- **工業 IoT**: 製造設備資料交換\n- **車聯網**: 車輛狀態和位置回報\n\n## 最佳實踐\n- 保持連接活躍 (Keep Alive)\n- 實施自動重連機制\n- 使用遺囑訊息偵測離線\n- 限制訊息大小和頻率\n- 實施適當的錯誤處理\n\n## 注意事項\n- MQTT 基於 TCP，需要穩定網路\n- Broker 連接數可能有限制\n- 大量訊息會消耗頻寬\n- 考慮訊息緩衝和重試機制"
    },
    {
      "id": "esp32-ntp-time",
      "title": "NTP 時間同步",
      "description": "ESP32 透過 NTP 獲取網路時間",
      "code": "#include <WiFi.h>\n#include <time.h>\n\n// WiFi 憑證\nconst char* ssid = \"你的WiFi名稱\";\nconst char* password = \"你的WiFi密碼\";\n\n// NTP 設定\nconst char* ntpServer = \"pool.ntp.org\";\nconst long gmtOffset_sec = 8 * 3600;     // GMT+8 (台灣時區)\nconst int daylightOffset_sec = 0;        // 夏令時間偏移\n\nvoid setup() {\n  Serial.begin(115200);\n  \n  // 連接 WiFi\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  \n  Serial.println();\n  Serial.println(\"WiFi 連接成功\");\n  Serial.print(\"IP 地址: \");\n  Serial.println(WiFi.localIP());\n  \n  // 初始化 NTP 時間同步\n  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);\n  \n  Serial.println(\"正在同步時間...\");\n  \n  // 等待時間同步完成\n  struct tm timeinfo;\n  if (!getLocalTime(&timeinfo)) {\n    Serial.println(\"時間同步失敗\");\n  } else {\n    Serial.println(\"時間同步成功\");\n    printLocalTime();\n  }\n}\n\nvoid loop() {\n  // 每30秒顯示一次時間\n  printLocalTime();\n  \n  // 顯示時間戳格式\n  printTimestamp();\n  \n  // 顯示 ISO 8601 格式\n  printISO8601();\n  \n  delay(30000);\n}\n\nvoid printLocalTime() {\n  struct tm timeinfo;\n  if (!getLocalTime(&timeinfo)) {\n    Serial.println(\"獲取本地時間失敗\");\n    return;\n  }\n  \n  Serial.println(\"=== 目前時間 ===\");\n  Serial.print(\"完整格式: \");\n  Serial.println(&timeinfo, \"%A, %B %d %Y %H:%M:%S\");\n  \n  Serial.print(\"日期: \");\n  Serial.println(&timeinfo, \"%Y-%m-%d\");\n  \n  Serial.print(\"時間: \");\n  Serial.println(&timeinfo, \"%H:%M:%S\");\n  \n  Serial.print(\"星期: \");\n  Serial.println(&timeinfo, \"%A\");\n  \n  Serial.print(\"月份: \");\n  Serial.println(&timeinfo, \"%B\");\n  \n  Serial.println(\"=================\");\n}\n\nvoid printTimestamp() {\n  time_t now;\n  time(&now);\n  \n  Serial.print(\"Unix 時間戳: \");\n  Serial.println(now);\n  \n  Serial.print(\"毫秒時間戳: \");\n  Serial.println(now * 1000);\n}\n\nvoid printISO8601() {\n  struct tm timeinfo;\n  if (!getLocalTime(&timeinfo)) {\n    return;\n  }\n  \n  char timeString[30];\n  strftime(timeString, sizeof(timeString), \"%Y-%m-%dT%H:%M:%S+08:00\", &timeinfo);\n  \n  Serial.print(\"ISO 8601 格式: \");\n  Serial.println(timeString);\n}\n\n// 獲取格式化日期字串\nString getDateString() {\n  struct tm timeinfo;\n  if (!getLocalTime(&timeinfo)) {\n    return \"時間獲取失敗\";\n  }\n  \n  char dateString[20];\n  strftime(dateString, sizeof(dateString), \"%Y-%m-%d\", &timeinfo);\n  \n  return String(dateString);\n}\n\n// 獲取格式化時間字串\nString getTimeString() {\n  struct tm timeinfo;\n  if (!getLocalTime(&timeinfo)) {\n    return \"時間獲取失敗\";\n  }\n  \n  char timeString[10];\n  strftime(timeString, sizeof(timeString), \"%H:%M:%S\", &timeinfo);\n  \n  return String(timeString);\n}\n\n// 檢查是否為工作日\nbool isWeekday() {\n  struct tm timeinfo;\n  if (!getLocalTime(&timeinfo)) {\n    return false;\n  }\n  \n  int weekday = timeinfo.tm_wday; // 0=星期日, 1=星期一, ..., 6=星期六\n  return (weekday >= 1 && weekday <= 5);\n}\n\n// 計算時間差\nvoid timeDifference() {\n  static time_t startTime = 0;\n  \n  if (startTime == 0) {\n    time(&startTime);\n    Serial.println(\"開始計時...\");\n    return;\n  }\n  \n  time_t currentTime;\n  time(&currentTime);\n  \n  double seconds = difftime(currentTime, startTime);\n  \n  Serial.print(\"經過時間: \");\n  Serial.print(seconds);\n  Serial.println(\" 秒\");\n}\n\n// 時間觸發事件範例\nvoid timeTriggeredEvents() {\n  struct tm timeinfo;\n  if (!getLocalTime(&timeinfo)) {\n    return;\n  }\n  \n  // 每小時的整點執行\n  if (timeinfo.tm_min == 0 && timeinfo.tm_sec == 0) {\n    Serial.println(\"整點觸發事件\");\n  }\n  \n  // 每天早上 8 點執行\n  if (timeinfo.tm_hour == 8 && timeinfo.tm_min == 0 && timeinfo.tm_sec == 0) {\n    Serial.println(\"早上 8 點觸發事件\");\n  }\n  \n  // 每週一早上執行\n  if (timeinfo.tm_wday == 1 && timeinfo.tm_hour == 9 && timeinfo.tm_min == 0) {\n    Serial.println(\"週一早上觸發事件\");\n  }\n}",
      "language": "esp32",
      "topic": "ESP32 物聯網基礎",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["NTP", "時間同步", "RTC", "時間戳", "原子式"]
      },
      "documentation": "# ESP32 NTP 時間同步\n\n## 功能說明\nNTP (Network Time Protocol) 允許 ESP32 透過網路自動同步時間，確保設備時鐘準確，這對物聯網應用的時間戳記錄非常重要。\n\n## 工作原理\n- **NTP 協議**: 透過網路獲取精確時間\n- **時區設定**: 根據地理位置調整時間\n- **自動同步**: 定期與 NTP 伺服器同步\n- **本地時間**: 轉換為當地時區時間\n\n## 時區設定\n```cpp\n// 台灣時區 (GMT+8)\nconst long gmtOffset_sec = 8 * 3600;\n\n// 其他常見時區\n// 美國東岸: -5 * 3600\n// 英國: 0\n// 日本: 9 * 3600\n// 澳洲雪梨: 10 * 3600\n```\n\n## NTP 伺服器\n- **pool.ntp.org**: 全球 NTP 池\n- **time.nist.gov**: 美國國家標準局\n- **time.google.com**: Google NTP 服務\n- **ntp.ubuntu.com**: Ubuntu NTP 服務\n\n## 時間格式\n- **Unix 時間戳**: 自 1970-01-01 00:00:00 UTC 的秒數\n- **ISO 8601**: 國際標準時間格式 (YYYY-MM-DDTHH:MM:SS)\n- **本地化格式**: 根據地區習慣的時間顯示\n\n## 應用場景\n- **資料記錄**: 感測器數據時間戳\n- **定時任務**: 基於時間的自動化\n- **日誌系統**: 事件發生時間記錄\n- **排程控制**: 時間觸發的設備控制\n- **同步作業**: 多設備時間協調\n\n## 時間精度\n- **NTP 精度**: 通常在 10-50 毫秒內\n- **本地時鐘**: ESP32 內建 RTC 精度有限\n- **同步間隔**: 建議每小時或每天同步一次\n- **網路延遲**: 影響同步精度\n\n## 最佳實踐\n- 在 WiFi 連接後立即同步時間\n- 定期重新同步以補償時鐘漂移\n- 處理同步失敗的情況\n- 選擇就近的 NTP 伺服器\n- 考慮夏令時間的影響\n\n## 注意事項\n- 需要穩定的網路連接\n- 初次同步可能需要幾秒鐘\n- 斷電後需要重新同步\n- 時區設定要正確\n- 考慮閏秒的影響"
    },
    {
      "id": "esp32-ota-update",
      "title": "OTA 無線更新",
      "description": "ESP32 透過 WiFi 進行韌體無線更新",
      "code": "#include <WiFi.h>\n#include <ESPmDNS.h>\n#include <WiFiUdp.h>\n#include <ArduinoOTA.h>\n\n// WiFi 憑證\nconst char* ssid = \"你的WiFi名稱\";\nconst char* password = \"你的WiFi密碼\";\n\n// OTA 設定\nconst char* ota_hostname = \"ESP32-OTA\";\nconst char* ota_password = \"123456\";  // OTA 更新密碼\n\nvoid setup() {\n  Serial.begin(115200);\n  Serial.println(\"ESP32 OTA 更新示範\");\n  \n  // 設定狀態 LED\n  pinMode(2, OUTPUT);\n  digitalWrite(2, LOW);\n  \n  // 連接 WiFi\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  \n  while (WiFi.waitForConnectResult() != WL_CONNECTED) {\n    Serial.println(\"WiFi 連接失敗，重新啟動...\");\n    delay(5000);\n    ESP.restart();\n  }\n  \n  Serial.println(\"WiFi 連接成功\");\n  Serial.print(\"IP 地址: \");\n  Serial.println(WiFi.localIP());\n  \n  // 設定 OTA\n  setupOTA();\n  \n  Serial.println(\"OTA 更新服務已啟動\");\n  Serial.println(\"可以開始上傳新韌體\");\n}\n\nvoid setupOTA() {\n  // 設定 OTA 主機名稱\n  ArduinoOTA.setHostname(ota_hostname);\n  \n  // 設定 OTA 密碼\n  ArduinoOTA.setPassword(ota_password);\n  \n  // OTA 開始時的回調\n  ArduinoOTA.onStart([]() {\n    String type;\n    if (ArduinoOTA.getCommand() == U_FLASH) {\n      type = \"sketch\";\n    } else { // U_SPIFFS\n      type = \"filesystem\";\n    }\n    \n    Serial.println(\"開始 OTA 更新: \" + type);\n    \n    // 關閉所有不必要的服務\n    // 例如：webServer.close();\n  });\n  \n  // OTA 結束時的回調\n  ArduinoOTA.onEnd([]() {\n    Serial.println(\"\\nOTA 更新完成\");\n    digitalWrite(2, HIGH); // 點亮 LED 表示成功\n  });\n  \n  // OTA 進度回調\n  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {\n    unsigned int percent = (progress / (total / 100));\n    Serial.printf(\"更新進度: %u%%\\r\", percent);\n    \n    // LED 閃爍顯示進度\n    if (percent % 10 == 0) {\n      digitalWrite(2, !digitalRead(2));\n    }\n  });\n  \n  // OTA 錯誤回調\n  ArduinoOTA.onError([](ota_error_t error) {\n    Serial.printf(\"OTA 更新錯誤[%u]: \", error);\n    \n    if (error == OTA_AUTH_ERROR) {\n      Serial.println(\"認證失敗\");\n    } else if (error == OTA_BEGIN_ERROR) {\n      Serial.println(\"開始更新失敗\");\n    } else if (error == OTA_CONNECT_ERROR) {\n      Serial.println(\"連接失敗\");\n    } else if (error == OTA_RECEIVE_ERROR) {\n      Serial.println(\"接收失敗\");\n    } else if (error == OTA_END_ERROR) {\n      Serial.println(\"結束更新失敗\");\n    }\n    \n    // LED 快速閃爍表示錯誤\n    for (int i = 0; i < 10; i++) {\n      digitalWrite(2, HIGH);\n      delay(100);\n      digitalWrite(2, LOW);\n      delay(100);\n    }\n  });\n  \n  // 啟動 OTA 服務\n  ArduinoOTA.begin();\n  \n  Serial.println(\"OTA 設定完成\");\n  Serial.print(\"OTA 主機名稱: \");\n  Serial.println(ota_hostname);\n  Serial.print(\"連接埠: 3232\");\n  Serial.println();\n}\n\nvoid loop() {\n  // 處理 OTA 更新請求\n  ArduinoOTA.handle();\n  \n  // 你的主要程式邏輯\n  // 注意：避免使用 delay() 或長時間阻塞的操作\n  \n  static unsigned long lastHeartbeat = 0;\n  if (millis() - lastHeartbeat > 5000) {\n    lastHeartbeat = millis();\n    \n    // 心跳訊號\n    Serial.println(\"系統運行中... (運行時間: \" + String(millis() / 1000) + \"s)\");\n    \n    // 檢查記憶體使用\n    Serial.print(\"可用記憶體: \");\n    Serial.print(ESP.getFreeHeap());\n    Serial.println(\" bytes\");\n    \n    // LED 心跳閃爍\n    digitalWrite(2, HIGH);\n    delay(100);\n    digitalWrite(2, LOW);\n  }\n  \n  // 檢查 WiFi 連接\n  if (WiFi.status() != WL_CONNECTED) {\n    Serial.println(\"WiFi 連接中斷，嘗試重連...\");\n    WiFi.begin(ssid, password);\n    \n    int attempts = 0;\n    while (WiFi.status() != WL_CONNECTED && attempts < 20) {\n      delay(500);\n      Serial.print(\".\");\n      attempts++;\n    }\n    \n    if (WiFi.status() == WL_CONNECTED) {\n      Serial.println(\"\\nWiFi 重連成功\");\n    } else {\n      Serial.println(\"\\nWiFi 重連失敗，重新啟動系統\");\n      delay(1000);\n      ESP.restart();\n    }\n  }\n  \n  delay(100); // 短暫延遲避免 watchdog 觸發\n}\n\n// 顯示系統資訊\nvoid printSystemInfo() {\n  Serial.println(\"=== 系統資訊 ===\");\n  Serial.print(\"晶片型號: \");\n  Serial.println(ESP.getChipModel());\n  Serial.print(\"晶片修訂版本: \");\n  Serial.println(ESP.getChipRevision());\n  Serial.print(\"CPU 頻率: \");\n  Serial.print(ESP.getCpuFreqMHz());\n  Serial.println(\" MHz\");\n  Serial.print(\"Flash 大小: \");\n  Serial.print(ESP.getFlashChipSize());\n  Serial.println(\" bytes\");\n  Serial.print(\"可用記憶體: \");\n  Serial.print(ESP.getFreeHeap());\n  Serial.println(\" bytes\");\n  Serial.print(\"WiFi MAC: \");\n  Serial.println(WiFi.macAddress());\n  Serial.println(\"=================\");\n}\n\n// 安全重啟系統\nvoid safeRestart() {\n  Serial.println(\"準備重新啟動系統...\");\n  \n  // 關閉所有服務\n  ArduinoOTA.end();\n  WiFi.disconnect();\n  \n  delay(1000);\n  ESP.restart();\n}",
      "language": "esp32",
      "topic": "ESP32 物聯網基礎",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "advanced",
        "tags": ["OTA", "無線更新", "韌體更新", "遠程維護", "原子式"]
      },
      "documentation": "# ESP32 OTA 無線更新\n\n## 功能說明\nOTA (Over-The-Air) 無線更新允許透過 WiFi 網路遠程更新 ESP32 的韌體，無需實體接觸設備，對於部署在遠程位置的物聯網設備非常重要。\n\n## 工作原理\n- **WiFi 傳輸**: 透過 WiFi 接收新韌體\n- **Flash 寫入**: 將新韌體寫入 Flash 記憶體\n- **安全驗證**: 驗證韌體完整性\n- **自動重啟**: 更新完成後自動重啟\n\n## OTA 更新方式\n1. **Arduino IDE**: 直接從 IDE 上傳\n2. **Web 介面**: 透過網頁上傳\n3. **HTTP**: 從遠程伺服器下載\n4. **MQTT**: 透過 MQTT 觸發更新\n\n## 安全考量\n- **密碼保護**: 設定 OTA 更新密碼\n- **韌體驗證**: 檢查韌體數位簽章\n- **網路加密**: 使用 HTTPS 傳輸\n- **存取控制**: 限制更新權限\n- **回滾機制**: 更新失敗時恢復舊版本\n\n## 記憶體分配\n```\nESP32 Flash 分區:\n┌─────────────────┐\n│   引導程式      │\n├─────────────────┤\n│   分區表        │\n├─────────────────┤\n│   NVS 儲存      │\n├─────────────────┤\n│   App0 (目前)   │  ← 運行中的韌體\n├─────────────────┤\n│   App1 (OTA)    │  ← 新韌體暫存\n├─────────────────┤\n│   SPIFFS/其他   │\n└─────────────────┘\n```\n\n## 更新流程\n1. ESP32 啟動 OTA 服務\n2. 電腦/手機連接同一網路\n3. Arduino IDE 偵測到 ESP32\n4. 選擇網路埠進行上傳\n5. 韌體透過 WiFi 傳輸\n6. ESP32 驗證並寫入新韌體\n7. 自動重啟載入新韌體\n\n## 使用步驟\n1. 上傳包含 OTA 的初始韌體\n2. 在 Arduino IDE 的「工具」→「連接埠」中選擇網路埠\n3. 正常上傳程式碼\n4. 輸入 OTA 密碼進行更新\n\n## 最佳實踐\n- 保持 OTA 程式碼在所有版本中\n- 使用強密碼保護 OTA\n- 在重要節點顯示更新進度\n- 實施更新前後的檢查機制\n- 保留緊急恢復機制\n\n## 常見問題\n- **更新失敗**: 檢查網路連接和記憶體\n- **找不到設備**: 確認在同一網路和防火牆設定\n- **密碼錯誤**: 檢查 OTA 密碼設定\n- **記憶體不足**: 清理不必要的程式碼\n\n## 注意事項\n- OTA 更新期間避免斷電\n- 確保有足夠的 Flash 空間\n- 更新過程中不要重置設備\n- 測試新韌體的穩定性\n- 備份重要的設定資料"
    },
    {
      "id": "esp32-deep-sleep",
      "title": "深度睡眠模式",
      "description": "ESP32 低功耗深度睡眠和喚醒控制",
      "code": "#include <WiFi.h>\n#include <driver/rtc_io.h>\n\n// WiFi 憑證\nconst char* ssid = \"你的WiFi名稱\";\nconst char* password = \"你的WiFi密碼\";\n\n// 睡眠設定\n#define uS_TO_S_FACTOR 1000000ULL  // 微秒轉秒的轉換因子\n#define TIME_TO_SLEEP  30          // 睡眠時間（秒）\n\n// GPIO 喚醒設定\n#define BUTTON_PIN_BITMASK 0x200000000 // GPIO33 (2^33)\n#define WAKE_UP_PIN GPIO_NUM_33\n\n// RTC 記憶體變數（在深度睡眠期間保持）\nRTC_DATA_ATTR int bootCount = 0;\nRTC_DATA_ATTR float lastTemperature = 0.0;\nRTC_DATA_ATTR unsigned long totalSleepTime = 0;\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(1000);\n  \n  // 增加啟動計數器\n  ++bootCount;\n  \n  Serial.println(\"===== ESP32 深度睡眠示範 =====\");\n  Serial.println(\"啟動次數: \" + String(bootCount));\n  \n  // 顯示喚醒原因\n  printWakeupReason();\n  \n  // 設定按鈕引腳為輸入（內建上拉）\n  pinMode(WAKE_UP_PIN, INPUT_PULLUP);\n  \n  // 設定狀態 LED\n  pinMode(2, OUTPUT);\n  digitalWrite(2, HIGH); // 點亮 LED 表示喚醒\n  \n  // 如果是第一次啟動或外部喚醒，連接 WiFi\n  esp_sleep_wakeup_cause_t wakeup_reason = esp_sleep_get_wakeup_cause();\n  \n  if (wakeup_reason == ESP_SLEEP_WAKEUP_UNDEFINED || \n      wakeup_reason == ESP_SLEEP_WAKEUP_EXT0) {\n    \n    Serial.println(\"連接 WiFi 並執行主要任務...\");\n    connectWiFi();\n    performMainTasks();\n  } else {\n    Serial.println(\"定時喚醒，執行快速任務...\");\n    performQuickTasks();\n  }\n  \n  // 準備進入深度睡眠\n  prepareForSleep();\n  \n  Serial.println(\"即將進入深度睡眠...\");\n  Serial.flush(); // 確保所有串列輸出完成\n  \n  delay(1000);\n  \n  // 進入深度睡眠\n  esp_deep_sleep_start();\n}\n\nvoid loop() {\n  // 深度睡眠模式下此函數不會執行\n}\n\nvoid printWakeupReason() {\n  esp_sleep_wakeup_cause_t wakeup_reason = esp_sleep_get_wakeup_cause();\n  \n  Serial.print(\"喚醒原因: \");\n  switch (wakeup_reason) {\n    case ESP_SLEEP_WAKEUP_UNDEFINED:\n      Serial.println(\"系統重置或首次啟動\");\n      break;\n    case ESP_SLEEP_WAKEUP_ALL:\n      Serial.println(\"所有喚醒源\");\n      break;\n    case ESP_SLEEP_WAKEUP_EXT0:\n      Serial.println(\"外部中斷 (RTC_IO)\");\n      Serial.println(\"按鈕被按下!\");\n      break;\n    case ESP_SLEEP_WAKEUP_EXT1:\n      Serial.println(\"外部中斷 (RTC_CNTL)\");\n      break;\n    case ESP_SLEEP_WAKEUP_TIMER:\n      Serial.println(\"定時器喚醒\");\n      totalSleepTime += TIME_TO_SLEEP;\n      Serial.println(\"總睡眠時間: \" + String(totalSleepTime) + \"秒\");\n      break;\n    case ESP_SLEEP_WAKEUP_TOUCHPAD:\n      Serial.println(\"觸控感應器喚醒\");\n      break;\n    case ESP_SLEEP_WAKEUP_ULP:\n      Serial.println(\"ULP 協處理器喚醒\");\n      break;\n    default:\n      Serial.println(\"未知原因: \" + String(wakeup_reason));\n      break;\n  }\n}\n\nvoid connectWiFi() {\n  WiFi.begin(ssid, password);\n  \n  int attempts = 0;\n  while (WiFi.status() != WL_CONNECTED && attempts < 20) {\n    delay(500);\n    Serial.print(\".\");\n    attempts++;\n  }\n  \n  if (WiFi.status() == WL_CONNECTED) {\n    Serial.println();\n    Serial.println(\"WiFi 連接成功\");\n    Serial.print(\"IP 地址: \");\n    Serial.println(WiFi.localIP());\n  } else {\n    Serial.println();\n    Serial.println(\"WiFi 連接失敗，將進行離線操作\");\n  }\n}\n\nvoid performMainTasks() {\n  Serial.println(\"執行主要任務...\");\n  \n  // 讀取感測器（模擬）\n  float temperature = 20.0 + random(-50, 50) / 10.0;\n  lastTemperature = temperature;\n  \n  Serial.println(\"感測器讀取:\");\n  Serial.println(\"溫度: \" + String(temperature, 2) + \"°C\");\n  \n  // 如果 WiFi 連接成功，發送數據\n  if (WiFi.status() == WL_CONNECTED) {\n    sendDataToServer(temperature);\n  }\n  \n  // LED 閃爍表示任務完成\n  for (int i = 0; i < 3; i++) {\n    digitalWrite(2, LOW);\n    delay(200);\n    digitalWrite(2, HIGH);\n    delay(200);\n  }\n}\n\nvoid performQuickTasks() {\n  Serial.println(\"執行快速任務...\");\n  \n  // 快速感測器讀取（不連接 WiFi）\n  float temperature = 20.0 + random(-30, 30) / 10.0;\n  lastTemperature = temperature;\n  \n  Serial.println(\"快速感測器讀取:\");\n  Serial.println(\"溫度: \" + String(temperature, 2) + \"°C\");\n  Serial.println(\"上次溫度: \" + String(lastTemperature, 2) + \"°C\");\n  \n  // 簡單的 LED 指示\n  digitalWrite(2, LOW);\n  delay(500);\n  digitalWrite(2, HIGH);\n}\n\nvoid sendDataToServer(float temperature) {\n  Serial.println(\"發送數據到伺服器...\");\n  \n  // 這裡可以加入 HTTP POST 或 MQTT 發布\n  // 為了示範，只顯示模擬的發送過程\n  \n  Serial.println(\"數據發送完成\");\n}\n\nvoid prepareForSleep() {\n  Serial.println(\"準備睡眠模式...\");\n  \n  // 設定定時器喚醒\n  esp_sleep_enable_timer_wakeup(TIME_TO_SLEEP * uS_TO_S_FACTOR);\n  Serial.println(\"設定定時器喚醒: \" + String(TIME_TO_SLEEP) + \"秒\");\n  \n  // 設定外部喚醒（按鈕）\n  esp_sleep_enable_ext0_wakeup(WAKE_UP_PIN, 0); // 低電平喚醒\n  Serial.println(\"設定按鈕喚醒: GPIO\" + String(WAKE_UP_PIN));\n  \n  // 關閉 WiFi 和藍牙以節省電力\n  WiFi.disconnect(true);\n  WiFi.mode(WIFI_OFF);\n  btStop();\n  \n  // 關閉不必要的週邊設備\n  esp_wifi_stop();\n  esp_bt_controller_disable();\n  \n  // 設定 GPIO 在深度睡眠期間的狀態\n  rtc_gpio_pullup_en(WAKE_UP_PIN);\n  rtc_gpio_pulldown_dis(WAKE_UP_PIN);\n  \n  // 關閉 LED\n  digitalWrite(2, LOW);\n  \n  Serial.println(\"系統準備就緒，即將進入深度睡眠\");\n}\n\n// 電源管理統計\nvoid printPowerStats() {\n  Serial.println(\"=== 電源統計 ===\");\n  Serial.println(\"啟動次數: \" + String(bootCount));\n  Serial.println(\"總睡眠時間: \" + String(totalSleepTime) + \"秒\");\n  Serial.println(\"預估節電比例: \" + String((totalSleepTime * 100) / (totalSleepTime + (bootCount * 10))) + \"%\");\n  Serial.println(\"================\");\n}\n\n// 緊急模式（低電量時的極簡操作）\nvoid emergencyMode() {\n  Serial.println(\"進入緊急省電模式\");\n  \n  // 關閉所有不必要功能\n  WiFi.mode(WIFI_OFF);\n  btStop();\n  \n  // 延長睡眠時間\n  esp_sleep_enable_timer_wakeup(300 * uS_TO_S_FACTOR); // 5分鐘\n  \n  // 只保留按鈕喚醒\n  esp_sleep_enable_ext0_wakeup(WAKE_UP_PIN, 0);\n  \n  Serial.println(\"緊急模式設定完成，進入長時間睡眠\");\n  Serial.flush();\n  \n  esp_deep_sleep_start();\n}",
      "language": "esp32",
      "topic": "ESP32 物聯網基礎",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "advanced",
        "tags": ["深度睡眠", "低功耗", "電源管理", "喚醒", "原子式"]
      },
      "documentation": "# ESP32 深度睡眠模式\n\n## 功能說明\n深度睡眠模式是 ESP32 的超低功耗狀態，可將電流消耗降至微安等級，對於電池供電的物聯網設備非常重要。\n\n## 工作原理\n- **CPU 關閉**: 主 CPU 和大部分週邊停止運作\n- **RTC 保持**: RTC 記憶體和時鐘繼續運作\n- **喚醒機制**: 透過多種方式喚醒系統\n- **狀態保存**: RTC 記憶體中的變數保持不變\n\n## 功耗比較\n```\n運作模式     電流消耗\n正常運作     80-120 mA\n輕度睡眠     0.8-1.2 mA\n深度睡眠     10-150 μA\n```\n\n## 喚醒方式\n1. **定時器喚醒**: 設定睡眠時間自動喚醒\n2. **外部中斷**: GPIO 電平變化喚醒\n3. **觸控感應**: 觸控引腳喚醒\n4. **ULP 協處理器**: 超低功耗協處理器喚醒\n\n## RTC 記憶體\n- **容量**: 8KB RTC 快速記憶體\n- **保持性**: 深度睡眠期間保持數據\n- **使用**: 用 `RTC_DATA_ATTR` 標記變數\n- **限制**: 只能儲存基本數據類型\n\n## 睡眠前準備\n```cpp\n// 關閉 WiFi 和藍牙\nWiFi.disconnect(true);\nWiFi.mode(WIFI_OFF);\nbtStop();\n\n// 設定 GPIO 狀態\nrtc_gpio_pullup_en(pin);\nrtc_gpio_pulldown_dis(pin);\n```\n\n## 應用場景\n- **感測器節點**: 定期讀取感測器數據\n- **環境監測**: 長期無人監控系統\n- **農業物聯網**: 土壤濕度、氣象監測\n- **野外設備**: 太陽能或電池供電設備\n- **智慧儀表**: 水錶、電錶等計量設備\n\n## 最佳實踐\n- 在睡眠前完成所有重要任務\n- 適當設定 GPIO 避免漏電\n- 使用 RTC 記憶體儲存狀態\n- 實施分級睡眠策略\n- 監控電池電量調整睡眠時間\n\n## 注意事項\n- 深度睡眠會重啟程式（類似重新開機）\n- 普通變數會丟失，只有 RTC 變數保留\n- 不是所有 GPIO 都能用於喚醒\n- WiFi 連接需要重新建立\n- 序列埠輸出在睡眠前要完成"
    },
    {
      "id": "esp32-spiffs-storage",
      "title": "SPIFFS 檔案系統",
      "description": "ESP32 內建 Flash 檔案系統操作",
      "code": "#include \"FS.h\"\n#include \"SPIFFS.h\"\n#include <WiFi.h>\n#include <ArduinoJson.h>\n\n// WiFi 憑證檔案路徑\nconst char* CONFIG_FILE = \"/config.json\";\nconst char* SENSOR_LOG = \"/sensor_data.csv\";\nconst char* ERROR_LOG = \"/error.log\";\n\nvoid setup() {\n  Serial.begin(115200);\n  Serial.println(\"ESP32 SPIFFS 檔案系統示範\");\n  \n  // 初始化 SPIFFS\n  if (!SPIFFS.begin(true)) {\n    Serial.println(\"SPIFFS 初始化失敗\");\n    return;\n  }\n  \n  Serial.println(\"SPIFFS 初始化成功\");\n  \n  // 顯示檔案系統資訊\n  printSPIFFSInfo();\n  \n  // 列出所有檔案\n  listAllFiles();\n  \n  // 測試配置檔案操作\n  testConfigFile();\n  \n  // 測試感測器數據記錄\n  testSensorLogging();\n  \n  // 測試錯誤日誌\n  testErrorLogging();\n  \n  // 檔案操作範例\n  fileOperationExamples();\n}\n\nvoid loop() {\n  // 每 30 秒記錄一次感測器數據\n  static unsigned long lastLog = 0;\n  if (millis() - lastLog > 30000) {\n    lastLog = millis();\n    \n    // 模擬感測器讀取\n    float temperature = 20.0 + random(-50, 50) / 10.0;\n    float humidity = 50.0 + random(-200, 200) / 10.0;\n    \n    logSensorData(temperature, humidity);\n  }\n  \n  delay(1000);\n}\n\nvoid printSPIFFSInfo() {\n  Serial.println(\"=== SPIFFS 檔案系統資訊 ===\");\n  \n  size_t totalBytes = SPIFFS.totalBytes();\n  size_t usedBytes = SPIFFS.usedBytes();\n  size_t freeBytes = totalBytes - usedBytes;\n  \n  Serial.printf(\"總容量: %u bytes (%.2f KB)\\n\", totalBytes, totalBytes / 1024.0);\n  Serial.printf(\"已使用: %u bytes (%.2f KB)\\n\", usedBytes, usedBytes / 1024.0);\n  Serial.printf(\"可用空間: %u bytes (%.2f KB)\\n\", freeBytes, freeBytes / 1024.0);\n  Serial.printf(\"使用率: %.1f%%\\n\", (usedBytes * 100.0) / totalBytes);\n  \n  Serial.println(\"===============================\");\n}\n\nvoid listAllFiles() {\n  Serial.println(\"\\n=== 檔案列表 ===\");\n  \n  File root = SPIFFS.open(\"/\");\n  File file = root.openNextFile();\n  \n  int fileCount = 0;\n  size_t totalSize = 0;\n  \n  while (file) {\n    Serial.printf(\"檔案: %-20s 大小: %6u bytes\\n\", file.name(), file.size());\n    totalSize += file.size();\n    fileCount++;\n    \n    file = root.openNextFile();\n  }\n  \n  Serial.printf(\"\\n總共 %d 個檔案，佔用 %u bytes\\n\", fileCount, totalSize);\n  Serial.println(\"===================\");\n}\n\nvoid testConfigFile() {\n  Serial.println(\"\\n=== 測試配置檔案 ===\");\n  \n  // 建立範例配置\n  DynamicJsonDocument config(1024);\n  config[\"device_name\"] = \"ESP32-Sensor\";\n  config[\"wifi_ssid\"] = \"MyWiFi\";\n  config[\"wifi_password\"] = \"MyPassword\";\n  config[\"sensor_interval\"] = 30;\n  config[\"mqtt_server\"] = \"broker.emqx.io\";\n  config[\"mqtt_port\"] = 1883;\n  \n  // 儲存配置檔案\n  if (saveConfig(config)) {\n    Serial.println(\"配置檔案儲存成功\");\n  }\n  \n  // 讀取配置檔案\n  DynamicJsonDocument loadedConfig(1024);\n  if (loadConfig(loadedConfig)) {\n    Serial.println(\"配置檔案讀取成功:\");\n    serializeJsonPretty(loadedConfig, Serial);\n    Serial.println();\n  }\n}\n\nbool saveConfig(DynamicJsonDocument& config) {\n  File file = SPIFFS.open(CONFIG_FILE, FILE_WRITE);\n  if (!file) {\n    Serial.println(\"無法開啟配置檔案進行寫入\");\n    return false;\n  }\n  \n  serializeJson(config, file);\n  file.close();\n  return true;\n}\n\nbool loadConfig(DynamicJsonDocument& config) {\n  if (!SPIFFS.exists(CONFIG_FILE)) {\n    Serial.println(\"配置檔案不存在\");\n    return false;\n  }\n  \n  File file = SPIFFS.open(CONFIG_FILE, FILE_READ);\n  if (!file) {\n    Serial.println(\"無法開啟配置檔案進行讀取\");\n    return false;\n  }\n  \n  DeserializationError error = deserializeJson(config, file);\n  file.close();\n  \n  if (error) {\n    Serial.println(\"配置檔案 JSON 解析失敗\");\n    return false;\n  }\n  \n  return true;\n}\n\nvoid testSensorLogging() {\n  Serial.println(\"\\n=== 測試感測器數據記錄 ===\");\n  \n  // 如果檔案不存在，建立標題行\n  if (!SPIFFS.exists(SENSOR_LOG)) {\n    File file = SPIFFS.open(SENSOR_LOG, FILE_WRITE);\n    if (file) {\n      file.println(\"Timestamp,Temperature,Humidity\");\n      file.close();\n      Serial.println(\"感測器日誌檔案已建立\");\n    }\n  }\n  \n  // 記錄一些範例數據\n  for (int i = 0; i < 3; i++) {\n    float temp = 22.0 + i;\n    float hum = 55.0 + i * 2;\n    logSensorData(temp, hum);\n    delay(100);\n  }\n  \n  // 讀取並顯示日誌內容\n  Serial.println(\"\\n感測器日誌內容:\");\n  readFile(SENSOR_LOG);\n}\n\nvoid logSensorData(float temperature, float humidity) {\n  File file = SPIFFS.open(SENSOR_LOG, FILE_APPEND);\n  if (!file) {\n    Serial.println(\"無法開啟感測器日誌檔案\");\n    return;\n  }\n  \n  unsigned long timestamp = millis();\n  file.printf(\"%lu,%.2f,%.2f\\n\", timestamp, temperature, humidity);\n  file.close();\n  \n  Serial.printf(\"記錄數據: T=%.2f°C, H=%.2f%%, 時間=%lu\\n\", \n                temperature, humidity, timestamp);\n}\n\nvoid testErrorLogging() {\n  Serial.println(\"\\n=== 測試錯誤日誌 ===\");\n  \n  logError(\"系統啟動\", \"正常啟動\");\n  logError(\"WiFi 連接\", \"連接失敗\");\n  logError(\"感測器讀取\", \"感測器異常\");\n  \n  Serial.println(\"\\n錯誤日誌內容:\");\n  readFile(ERROR_LOG);\n}\n\nvoid logError(const char* module, const char* message) {\n  File file = SPIFFS.open(ERROR_LOG, FILE_APPEND);\n  if (!file) {\n    Serial.println(\"無法開啟錯誤日誌檔案\");\n    return;\n  }\n  \n  unsigned long timestamp = millis();\n  file.printf(\"[%lu] %s: %s\\n\", timestamp, module, message);\n  file.close();\n  \n  Serial.printf(\"錯誤記錄: [%s] %s\\n\", module, message);\n}\n\nvoid readFile(const char* path) {\n  File file = SPIFFS.open(path, FILE_READ);\n  if (!file) {\n    Serial.println(\"無法開啟檔案進行讀取\");\n    return;\n  }\n  \n  Serial.printf(\"檔案內容 (%s):\\n\", path);\n  Serial.println(\"─────────────────────────\");\n  \n  while (file.available()) {\n    Serial.write(file.read());\n  }\n  \n  Serial.println(\"─────────────────────────\");\n  file.close();\n}\n\nvoid fileOperationExamples() {\n  Serial.println(\"\\n=== 檔案操作範例 ===\");\n  \n  const char* testFile = \"/test.txt\";\n  \n  // 寫入文字檔案\n  writeFile(testFile, \"這是測試內容\\n第二行文字\\n第三行數字: 123\");\n  \n  // 讀取檔案\n  Serial.println(\"\\n讀取檔案內容:\");\n  readFile(testFile);\n  \n  // 附加內容\n  appendFile(testFile, \"\\n附加的內容\");\n  \n  // 再次讀取\n  Serial.println(\"\\n附加內容後:\");\n  readFile(testFile);\n  \n  // 刪除檔案\n  if (SPIFFS.remove(testFile)) {\n    Serial.println(\"\\n測試檔案已刪除\");\n  }\n}\n\nvoid writeFile(const char* path, const char* message) {\n  File file = SPIFFS.open(path, FILE_WRITE);\n  if (!file) {\n    Serial.println(\"寫入檔案失敗\");\n    return;\n  }\n  \n  file.print(message);\n  file.close();\n  Serial.printf(\"檔案 %s 寫入完成\\n\", path);\n}\n\nvoid appendFile(const char* path, const char* message) {\n  File file = SPIFFS.open(path, FILE_APPEND);\n  if (!file) {\n    Serial.println(\"附加檔案失敗\");\n    return;\n  }\n  \n  file.print(message);\n  file.close();\n  Serial.printf(\"內容已附加到 %s\\n\", path);\n}\n\n// 清理舊檔案\nvoid cleanupOldFiles() {\n  Serial.println(\"清理舊檔案...\");\n  \n  // 範例：刪除超過一定大小的日誌檔案\n  if (SPIFFS.exists(SENSOR_LOG)) {\n    File file = SPIFFS.open(SENSOR_LOG, FILE_READ);\n    if (file.size() > 10240) { // 超過 10KB\n      file.close();\n      SPIFFS.remove(SENSOR_LOG);\n      Serial.println(\"大型感測器日誌檔案已刪除\");\n    } else {\n      file.close();\n    }\n  }\n}",
      "language": "esp32",
      "topic": "ESP32 物聯網基礎",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "intermediate",
        "tags": ["SPIFFS", "檔案系統", "數據儲存", "配置管理", "原子式"]
      },
      "documentation": "# ESP32 SPIFFS 檔案系統\n\n## 功能說明\nSPIFFS (SPI Flash File System) 是 ESP32 內建的檔案系統，使用 Flash 記憶體儲存檔案，適合儲存配置、日誌和小型資料檔案。\n\n## 工作原理\n- **Flash 儲存**: 使用內建 Flash 記憶體\n- **平坦結構**: 不支援目錄階層\n- **檔案操作**: 支援讀寫、建立、刪除檔案\n- **持久性**: 斷電後資料不會丟失\n\n## SPIFFS 特性\n- **容量**: 通常 1.5MB 可用空間\n- **檔案數量**: 受 Flash 大小限制\n- **檔案名**: 最長 31 個字元\n- **目錄**: 不支援真正的目錄結構\n- **磨損平衡**: 自動平衡 Flash 磨損\n\n## 分區配置\n```\nESP32 Flash 分區 (4MB):\n┌─────────────────┐\n│   引導程式      │  64KB\n├─────────────────┤\n│   分區表        │  4KB\n├─────────────────┤\n│   NVS          │  20KB\n├─────────────────┤\n│   OTA Data     │  8KB\n├─────────────────┤\n│   App0         │  1.3MB\n├─────────────────┤\n│   App1         │  1.3MB\n├─────────────────┤\n│   SPIFFS       │  1.5MB  ← 檔案系統\n└─────────────────┘\n```\n\n## 常用檔案類型\n- **配置檔案**: JSON 格式的系統設定\n- **感測器日誌**: CSV 格式的資料記錄\n- **錯誤日誌**: 系統錯誤和事件記錄\n- **網頁檔案**: HTML, CSS, JS 檔案\n- **憑證檔案**: WiFi 密碼、API 金鑰\n\n## 檔案操作 API\n```cpp\n// 基本操作\nSPIFFS.begin()          // 初始化\nSPIFFS.open()           // 開啟檔案\nSPIFFS.exists()         // 檢查檔案存在\nSPIFFS.remove()         // 刪除檔案\nSPIFFS.rename()         // 重新命名\n\n// 資訊查詢\nSPIFFS.totalBytes()     // 總容量\nSPIFFS.usedBytes()      // 已使用\nSPIFFS.format()         // 格式化\n```\n\n## 最佳實踐\n- 在 setup() 中初始化 SPIFFS\n- 適當關閉檔案釋放資源\n- 定期檢查可用空間\n- 實施日誌輪替機制\n- 備份重要配置檔案\n\n## 應用場景\n- **配置管理**: WiFi 設定、API 金鑰\n- **資料記錄**: 感測器數據長期儲存\n- **網頁服務**: 靜態網頁檔案\n- **快取**: 暫存資料和狀態\n- **離線資料**: 網路斷線時的本地儲存\n\n## 效能考量\n- 寫入速度比讀取慢\n- 避免頻繁的小檔案寫入\n- 批量操作提高效率\n- 檔案大小影響操作速度\n- Flash 壽命有限制\n\n## 注意事項\n- 不支援目錄結構\n- 檔案名稱有長度限制\n- 需要適當的錯誤處理\n- 考慮 Flash 記憶體磨損\n- 避免同時開啟太多檔案"
    },
    {
      "id": "esp32-smart-home-hub",
      "title": "智慧家居中心",
      "description": "ESP32 智慧家居控制中心，整合多種設備",
      "code": "#include <WiFi.h>\n#include <WebServer.h>\n#include <PubSubClient.h>\n#include <ArduinoJson.h>\n#include <SPIFFS.h>\n#include <time.h>\n\n// WiFi 和 MQTT 設定\nconst char* ssid = \"你的WiFi名稱\";\nconst char* password = \"你的WiFi密碼\";\nconst char* mqtt_server = \"broker.emqx.io\";\nconst char* device_id = \"SmartHome_Hub_001\";\n\n// 硬體控制腳位\nconst int RELAY_LIGHTS = 2;     // 燈光控制繼電器\nconst int RELAY_FAN = 4;        // 風扇控制繼電器\nconst int RELAY_AC = 5;         // 空調控制繼電器\nconst int TEMP_SENSOR = A0;     // 溫度感測器\nconst int LIGHT_SENSOR = A3;    // 光線感測器\nconst int PIR_SENSOR = 18;      // 人體紅外感測器\nconst int BUZZER = 19;          // 蜂鳴器\n\n// 服務物件\nWebServer server(80);\nWiFiClient espClient;\nPubSubClient mqtt(espClient);\n\n// 裝置狀態\nstruct DeviceState {\n  bool lights;\n  bool fan;\n  bool ac;\n  float temperature;\n  int lightLevel;\n  bool motionDetected;\n  bool autoMode;\n  String lastUpdate;\n} homeState;\n\n// 自動化規則\nstruct AutoRule {\n  bool enabled;\n  int startHour;\n  int endHour;\n  float tempThreshold;\n  int lightThreshold;\n} autoRules;\n\nvoid setup() {\n  Serial.begin(115200);\n  \n  // 初始化硬體\n  initializeHardware();\n  \n  // 初始化檔案系統\n  if (!SPIFFS.begin(true)) {\n    Serial.println(\"SPIFFS 初始化失敗\");\n  }\n  \n  // 載入設定檔\n  loadConfiguration();\n  \n  // 連接 WiFi\n  connectWiFi();\n  \n  // 設定時間\n  configTime(8 * 3600, 0, \"pool.ntp.org\");\n  \n  // 設定 MQTT\n  mqtt.setServer(mqtt_server, 1883);\n  mqtt.setCallback(mqttCallback);\n  \n  // 設定網頁伺服器\n  setupWebServer();\n  \n  Serial.println(\"智慧家居中心啟動完成\");\n  \n  // 初始化預設規則\n  autoRules.enabled = true;\n  autoRules.startHour = 18;  // 下午6點\n  autoRules.endHour = 23;    // 晚上11點\n  autoRules.tempThreshold = 26.0;\n  autoRules.lightThreshold = 300;\n}\n\nvoid loop() {\n  // 處理網路服務\n  server.handleClient();\n  if (!mqtt.connected()) {\n    reconnectMQTT();\n  }\n  mqtt.loop();\n  \n  // 讀取感測器\n  updateSensors();\n  \n  // 執行自動化邏輯\n  if (homeState.autoMode) {\n    executeAutomation();\n  }\n  \n  // 定期發布狀態\n  static unsigned long lastPublish = 0;\n  if (millis() - lastPublish > 30000) {  // 每30秒\n    publishHomeStatus();\n    lastPublish = millis();\n  }\n  \n  // 安全檢查\n  securityCheck();\n  \n  delay(1000);\n}\n\nvoid initializeHardware() {\n  // 設定繼電器腳位\n  pinMode(RELAY_LIGHTS, OUTPUT);\n  pinMode(RELAY_FAN, OUTPUT);\n  pinMode(RELAY_AC, OUTPUT);\n  \n  // 設定感測器腳位\n  pinMode(PIR_SENSOR, INPUT);\n  pinMode(BUZZER, OUTPUT);\n  \n  // 初始狀態\n  digitalWrite(RELAY_LIGHTS, LOW);\n  digitalWrite(RELAY_FAN, LOW);\n  digitalWrite(RELAY_AC, LOW);\n  digitalWrite(BUZZER, LOW);\n  \n  // 初始化狀態結構\n  homeState.lights = false;\n  homeState.fan = false;\n  homeState.ac = false;\n  homeState.autoMode = true;\n  \n  Serial.println(\"硬體初始化完成\");\n}\n\nvoid connectWiFi() {\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println();\n  Serial.print(\"WiFi 連接成功，IP: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid setupWebServer() {\n  // 主頁面\n  server.on(\"/\", HTTP_GET, handleRoot);\n  \n  // 設備控制 API\n  server.on(\"/api/lights\", HTTP_POST, handleLightsControl);\n  server.on(\"/api/fan\", HTTP_POST, handleFanControl);\n  server.on(\"/api/ac\", HTTP_POST, handleACControl);\n  server.on(\"/api/auto\", HTTP_POST, handleAutoMode);\n  \n  // 狀態查詢 API\n  server.on(\"/api/status\", HTTP_GET, handleStatus);\n  server.on(\"/api/sensors\", HTTP_GET, handleSensors);\n  \n  // 設定 API\n  server.on(\"/api/rules\", HTTP_GET, handleGetRules);\n  server.on(\"/api/rules\", HTTP_POST, handleSetRules);\n  \n  server.begin();\n  Serial.println(\"網頁伺服器啟動\");\n}\n\nvoid handleRoot() {\n  String html = R\"(\n<!DOCTYPE html>\n<html>\n<head>\n  <title>智慧家居控制中心</title>\n  <meta charset='UTF-8'>\n  <style>\n    body { font-family: Arial; margin: 20px; background: #f0f0f0; }\n    .container { max-width: 800px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; }\n    .device { margin: 10px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }\n    .button { padding: 10px 20px; margin: 5px; border: none; border-radius: 5px; cursor: pointer; }\n    .on { background: #4CAF50; color: white; }\n    .off { background: #f44336; color: white; }\n    .sensor { background: #e7f3ff; }\n    .status { font-weight: bold; }\n  </style>\n</head>\n<body>\n  <div class='container'>\n    <h1>🏠 智慧家居控制中心</h1>\n    \n    <div class='device sensor'>\n      <h3>📊 感測器狀態</h3>\n      <p>溫度: <span id='temp'>--</span>°C</p>\n      <p>光線: <span id='light'>--</span></p>\n      <p>人體感應: <span id='motion'>--</span></p>\n    </div>\n    \n    <div class='device'>\n      <h3>💡 燈光控制</h3>\n      <button class='button' onclick='toggleDevice(\"lights\")' id='lightBtn'>燈光</button>\n      <span class='status' id='lightStatus'>關閉</span>\n    </div>\n    \n    <div class='device'>\n      <h3>🌀 風扇控制</h3>\n      <button class='button' onclick='toggleDevice(\"fan\")' id='fanBtn'>風扇</button>\n      <span class='status' id='fanStatus'>關閉</span>\n    </div>\n    \n    <div class='device'>\n      <h3>❄️ 空調控制</h3>\n      <button class='button' onclick='toggleDevice(\"ac\")' id='acBtn'>空調</button>\n      <span class='status' id='acStatus'>關閉</span>\n    </div>\n    \n    <div class='device'>\n      <h3>🤖 自動模式</h3>\n      <button class='button' onclick='toggleAuto()' id='autoBtn'>自動模式</button>\n      <span class='status' id='autoStatus'>開啟</span>\n    </div>\n  </div>\n  \n  <script>\n    function updateStatus() {\n      fetch('/api/status')\n        .then(response => response.json())\n        .then(data => {\n          updateButton('lightBtn', 'lightStatus', data.lights);\n          updateButton('fanBtn', 'fanStatus', data.fan);\n          updateButton('acBtn', 'acStatus', data.ac);\n          updateButton('autoBtn', 'autoStatus', data.autoMode);\n        });\n      \n      fetch('/api/sensors')\n        .then(response => response.json())\n        .then(data => {\n          document.getElementById('temp').textContent = data.temperature;\n          document.getElementById('light').textContent = data.lightLevel;\n          document.getElementById('motion').textContent = data.motionDetected ? '偵測到' : '無';\n        });\n    }\n    \n    function updateButton(btnId, statusId, state) {\n      const btn = document.getElementById(btnId);\n      const status = document.getElementById(statusId);\n      if (state) {\n        btn.className = 'button on';\n        status.textContent = '開啟';\n      } else {\n        btn.className = 'button off';\n        status.textContent = '關閉';\n      }\n    }\n    \n    function toggleDevice(device) {\n      fetch(`/api/${device}`, { method: 'POST' })\n        .then(() => updateStatus());\n    }\n    \n    function toggleAuto() {\n      fetch('/api/auto', { method: 'POST' })\n        .then(() => updateStatus());\n    }\n    \n    // 初始載入和定期更新\n    updateStatus();\n    setInterval(updateStatus, 5000);\n  </script>\n</body>\n</html>\n)\";\n  \n  server.send(200, \"text/html\", html);\n}\n\nvoid updateSensors() {\n  // 讀取溫度（模擬）\n  int tempRaw = analogRead(TEMP_SENSOR);\n  homeState.temperature = (tempRaw * 3.3 / 4095.0 - 0.5) * 100;\n  \n  // 讀取光線強度\n  homeState.lightLevel = analogRead(LIGHT_SENSOR);\n  \n  // 讀取人體感應\n  homeState.motionDetected = digitalRead(PIR_SENSOR);\n  \n  // 更新時間戳\n  time_t now;\n  time(&now);\n  homeState.lastUpdate = String(now);\n}\n\nvoid executeAutomation() {\n  if (!autoRules.enabled) return;\n  \n  struct tm timeinfo;\n  if (!getLocalTime(&timeinfo)) return;\n  \n  int currentHour = timeinfo.tm_hour;\n  \n  // 時間範圍內的自動控制\n  if (currentHour >= autoRules.startHour || currentHour <= autoRules.endHour) {\n    \n    // 根據光線自動控制燈光\n    if (homeState.lightLevel < autoRules.lightThreshold && !homeState.lights) {\n      setLights(true);\n      Serial.println(\"自動開啟燈光 - 光線不足\");\n    } else if (homeState.lightLevel > autoRules.lightThreshold + 100 && homeState.lights) {\n      setLights(false);\n      Serial.println(\"自動關閉燈光 - 光線充足\");\n    }\n    \n    // 根據溫度自動控制風扇/空調\n    if (homeState.temperature > autoRules.tempThreshold) {\n      if (!homeState.fan) {\n        setFan(true);\n        Serial.println(\"自動開啟風扇 - 溫度過高\");\n      }\n      if (homeState.temperature > autoRules.tempThreshold + 2 && !homeState.ac) {\n        setAC(true);\n        Serial.println(\"自動開啟空調 - 溫度很高\");\n      }\n    } else if (homeState.temperature < autoRules.tempThreshold - 2) {\n      if (homeState.fan) {\n        setFan(false);\n        Serial.println(\"自動關閉風扇 - 溫度正常\");\n      }\n      if (homeState.ac) {\n        setAC(false);\n        Serial.println(\"自動關閉空調 - 溫度正常\");\n      }\n    }\n  }\n}\n\nvoid setLights(bool state) {\n  homeState.lights = state;\n  digitalWrite(RELAY_LIGHTS, state ? HIGH : LOW);\n  publishDeviceUpdate(\"lights\", state);\n}\n\nvoid setFan(bool state) {\n  homeState.fan = state;\n  digitalWrite(RELAY_FAN, state ? HIGH : LOW);\n  publishDeviceUpdate(\"fan\", state);\n}\n\nvoid setAC(bool state) {\n  homeState.ac = state;\n  digitalWrite(RELAY_AC, state ? HIGH : LOW);\n  publishDeviceUpdate(\"ac\", state);\n}",
      "language": "esp32",
      "topic": "ESP32 進階應用",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "advanced",
        "tags": ["智慧家居", "IoT中心", "自動化", "網頁控制", "MQTT", "原子式"]
      },
      "documentation": "# ESP32 智慧家居中心\n\n## 功能說明\n這是一個完整的智慧家居控制中心，整合多種設備控制、感測器監測、自動化規則和遠程控制功能。\n\n## 系統架構\n- **中央控制器**: ESP32 作為智慧家居中心\n- **設備控制**: 繼電器控制燈光、風扇、空調\n- **感測器網路**: 溫度、光線、人體感應\n- **用戶介面**: Web 控制面板和 MQTT 介面\n- **自動化引擎**: 基於規則的自動控制\n\n## 硬體連接\n```\n設備控制:\n繼電器1 (燈光) → GPIO 2\n繼電器2 (風扇) → GPIO 4\n繼電器3 (空調) → GPIO 5\n\n感測器:\n溫度感測器 → A0\n光線感測器 → A3\nPIR 感測器 → GPIO 18\n蜂鳴器 → GPIO 19\n```\n\n## 主要功能\n\n### 1. 設備控制\n- **燈光系統**: 智慧照明控制\n- **氣候控制**: 風扇和空調自動調節\n- **安全系統**: 人體感應和警報\n\n### 2. 感測器監測\n- **環境監測**: 溫度、濕度、光線\n- **安全監測**: 人體移動偵測\n- **即時數據**: 持續監控和記錄\n\n### 3. 自動化規則\n- **時間控制**: 基於時間的自動化\n- **環境響應**: 根據感測器數據自動調整\n- **場景模式**: 預設的控制組合\n\n### 4. 遠程控制\n- **Web 介面**: 瀏覽器控制面板\n- **MQTT 控制**: 物聯網協議整合\n- **手機 App**: 移動設備控制\n\n## 控制介面\n\n### Web 控制面板\n- 即時狀態顯示\n- 設備開關控制\n- 感測器數據查看\n- 自動模式切換\n\n### MQTT 主題\n```\nsmarthome/devices/lights/command\nsmarthome/devices/fan/command\nsmarthome/devices/ac/command\nsmarthome/sensors/temperature\nsmarthome/sensors/motion\nsmarthome/status\n```\n\n## 自動化邏輯\n\n### 光線控制\n- 光線不足時自動開燈\n- 光線充足時自動關燈\n- 可設定敏感度閾值\n\n### 溫度控制\n- 溫度過高時啟動風扇\n- 極高溫時啟動空調\n- 溫度正常時關閉設備\n\n### 時間控制\n- 設定自動化時間範圍\n- 夜間模式自動調整\n- 節能時段管理\n\n## 應用場景\n- **住宅自動化**: 家庭智慧控制系統\n- **辦公室管理**: 辦公環境自動調節\n- **商店監控**: 商業空間環境控制\n- **溫室控制**: 農業環境管理\n\n## 擴展功能\n- 語音控制整合\n- 手機 App 開發\n- 雲端數據分析\n- 機器學習優化\n- 安全攝像頭整合\n\n## 安全特性\n- 設備狀態驗證\n- 異常行為偵測\n- 遠程監控告警\n- 備用控制機制\n\n## 注意事項\n- 確保繼電器額定功率足夠\n- 注意電氣安全和絕緣\n- 定期檢查感測器準確性\n- 備份重要設定檔案"
    },
    {
      "id": "esp32-weather-station",
      "title": "氣象監測站",
      "description": "ESP32 完整氣象資料收集與雲端上傳系統",
      "code": "#include <WiFi.h>\n#include <HTTPClient.h>\n#include <PubSubClient.h>\n#include <ArduinoJson.h>\n#include <SPIFFS.h>\n#include <time.h>\n#include <DHT.h>\n#include <BMP280.h>\n#include <Wire.h>\n\n// WiFi 和雲端設定\nconst char* ssid = \"你的WiFi名稱\";\nconst char* password = \"你的WiFi密碼\";\nconst char* mqtt_server = \"broker.emqx.io\";\nconst char* weather_api = \"http://api.openweathermap.org/data/2.5/weather\";\nconst char* api_key = \"你的API金鑰\";\nconst char* station_id = \"WeatherStation_001\";\n\n// 感測器腳位和設定\n#define DHT_PIN 4\n#define DHT_TYPE DHT22\n#define WIND_SPEED_PIN 2\n#define WIND_DIR_PIN A0\n#define RAIN_PIN 5\n#define UV_PIN A3\n#define SOIL_MOISTURE_PIN A6\n\n// 感測器物件\nDHT dht(DHT_PIN, DHT_TYPE);\nBMP280 bmp;\nWiFiClient espClient;\nPubSubClient mqtt(espClient);\n\n// 氣象資料結構\nstruct WeatherData {\n  float temperature;     // 溫度 (°C)\n  float humidity;        // 濕度 (%)\n  float pressure;        // 氣壓 (hPa)\n  float windSpeed;       // 風速 (m/s)\n  int windDirection;     // 風向 (度)\n  float rainfall;        // 降雨量 (mm)\n  float uvIndex;         // UV 指數\n  int soilMoisture;      // 土壤濕度 (%)\n  String timestamp;      // 時間戳\n  float dewPoint;        // 露點溫度\n  float heatIndex;       // 體感溫度\n} currentWeather;\n\n// 統計資料\nstruct WeatherStats {\n  float tempMin, tempMax;\n  float humidityMin, humidityMax;\n  float pressureMin, pressureMax;\n  float totalRainfall;\n  float maxWindSpeed;\n  int dataPoints;\n} dailyStats;\n\n// 風速測量變數\nvolatile int windPulses = 0;\nunsigned long lastWindMeasurement = 0;\n\nvoid setup() {\n  Serial.begin(115200);\n  Serial.println(\"ESP32 氣象監測站啟動\");\n  \n  // 初始化硬體\n  initializeHardware();\n  \n  // 初始化感測器\n  initializeSensors();\n  \n  // 初始化檔案系統\n  if (!SPIFFS.begin(true)) {\n    Serial.println(\"SPIFFS 初始化失敗\");\n  }\n  \n  // 連接 WiFi\n  connectWiFi();\n  \n  // 設定時間同步\n  configTime(8 * 3600, 0, \"pool.ntp.org\");\n  \n  // 設定 MQTT\n  mqtt.setServer(mqtt_server, 1883);\n  \n  // 初始化統計資料\n  resetDailyStats();\n  \n  Serial.println(\"氣象監測站初始化完成\");\n}\n\nvoid loop() {\n  // 讀取所有感測器\n  readAllSensors();\n  \n  // 計算衍生數據\n  calculateDerivedData();\n  \n  // 更新統計資料\n  updateDailyStats();\n  \n  // 顯示目前數據\n  displayCurrentWeather();\n  \n  // 儲存數據到本地\n  saveWeatherData();\n  \n  // 上傳到雲端\n  static unsigned long lastUpload = 0;\n  if (millis() - lastUpload > 300000) {  // 每5分鐘上傳\n    uploadToCloud();\n    publishMQTTData();\n    lastUpload = millis();\n  }\n  \n  // 檢查是否需要重置每日統計\n  checkDailyReset();\n  \n  delay(60000);  // 每分鐘讀取一次\n}\n\nvoid initializeHardware() {\n  // 設定感測器腳位\n  pinMode(WIND_SPEED_PIN, INPUT_PULLUP);\n  pinMode(RAIN_PIN, INPUT_PULLUP);\n  \n  // 設定中斷 (風速測量)\n  attachInterrupt(digitalPinToInterrupt(WIND_SPEED_PIN), windSpeedISR, FALLING);\n  \n  Serial.println(\"硬體初始化完成\");\n}\n\nvoid initializeSensors() {\n  // 初始化 DHT22\n  dht.begin();\n  \n  // 初始化 BMP280\n  Wire.begin();\n  if (!bmp.begin()) {\n    Serial.println(\"BMP280 初始化失敗\");\n  }\n  \n  Serial.println(\"感測器初始化完成\");\n}\n\nvoid readAllSensors() {\n  Serial.println(\"讀取感測器數據...\");\n  \n  // 讀取溫濕度 (DHT22)\n  currentWeather.temperature = dht.readTemperature();\n  currentWeather.humidity = dht.readHumidity();\n  \n  // 檢查 DHT22 讀取是否成功\n  if (isnan(currentWeather.temperature) || isnan(currentWeather.humidity)) {\n    Serial.println(\"DHT22 讀取失敗\");\n    return;\n  }\n  \n  // 讀取氣壓 (BMP280)\n  currentWeather.pressure = bmp.readPressure() / 100.0;  // 轉換為 hPa\n  \n  // 讀取風速 (基於脈衝計數)\n  measureWindSpeed();\n  \n  // 讀取風向 (類比輸入)\n  int windDirRaw = analogRead(WIND_DIR_PIN);\n  currentWeather.windDirection = map(windDirRaw, 0, 4095, 0, 360);\n  \n  // 讀取降雨 (脈衝計數)\n  // 這裡需要根據具體雨量計實現\n  currentWeather.rainfall = 0.0;  // 暫時設為 0\n  \n  // 讀取 UV 指數\n  int uvRaw = analogRead(UV_PIN);\n  currentWeather.uvIndex = map(uvRaw, 0, 4095, 0, 15);  // 簡化映射\n  \n  // 讀取土壤濕度\n  int soilRaw = analogRead(SOIL_MOISTURE_PIN);\n  currentWeather.soilMoisture = map(soilRaw, 0, 4095, 0, 100);\n  \n  // 設定時間戳\n  time_t now;\n  time(&now);\n  currentWeather.timestamp = String(now);\n}\n\nvoid measureWindSpeed() {\n  unsigned long currentTime = millis();\n  if (currentTime - lastWindMeasurement >= 1000) {  // 每秒計算\n    // 風速計算：假設每個脈衝代表 0.1 m/s\n    currentWeather.windSpeed = windPulses * 0.1;\n    windPulses = 0;\n    lastWindMeasurement = currentTime;\n  }\n}\n\nvoid windSpeedISR() {\n  windPulses++;\n}\n\nvoid calculateDerivedData() {\n  // 計算露點溫度\n  float a = 17.27;\n  float b = 237.7;\n  float alpha = ((a * currentWeather.temperature) / (b + currentWeather.temperature)) + log(currentWeather.humidity / 100.0);\n  currentWeather.dewPoint = (b * alpha) / (a - alpha);\n  \n  // 計算體感溫度 (Heat Index)\n  if (currentWeather.temperature >= 27 && currentWeather.humidity >= 40) {\n    float T = currentWeather.temperature;\n    float H = currentWeather.humidity;\n    currentWeather.heatIndex = -42.379 + 2.04901523*T + 10.14333127*H - 0.22475541*T*H;\n  } else {\n    currentWeather.heatIndex = currentWeather.temperature;\n  }\n}\n\nvoid updateDailyStats() {\n  // 更新溫度範圍\n  if (dailyStats.dataPoints == 0) {\n    dailyStats.tempMin = dailyStats.tempMax = currentWeather.temperature;\n    dailyStats.humidityMin = dailyStats.humidityMax = currentWeather.humidity;\n    dailyStats.pressureMin = dailyStats.pressureMax = currentWeather.pressure;\n  } else {\n    if (currentWeather.temperature < dailyStats.tempMin) dailyStats.tempMin = currentWeather.temperature;\n    if (currentWeather.temperature > dailyStats.tempMax) dailyStats.tempMax = currentWeather.temperature;\n    if (currentWeather.humidity < dailyStats.humidityMin) dailyStats.humidityMin = currentWeather.humidity;\n    if (currentWeather.humidity > dailyStats.humidityMax) dailyStats.humidityMax = currentWeather.humidity;\n    if (currentWeather.pressure < dailyStats.pressureMin) dailyStats.pressureMin = currentWeather.pressure;\n    if (currentWeather.pressure > dailyStats.pressureMax) dailyStats.pressureMax = currentWeather.pressure;\n  }\n  \n  // 更新最大風速\n  if (currentWeather.windSpeed > dailyStats.maxWindSpeed) {\n    dailyStats.maxWindSpeed = currentWeather.windSpeed;\n  }\n  \n  dailyStats.dataPoints++;\n}\n\nvoid displayCurrentWeather() {\n  Serial.println(\"\\n=== 目前氣象資料 ===\");\n  Serial.printf(\"時間: %s\\n\", currentWeather.timestamp.c_str());\n  Serial.printf(\"溫度: %.2f°C\\n\", currentWeather.temperature);\n  Serial.printf(\"濕度: %.2f%%\\n\", currentWeather.humidity);\n  Serial.printf(\"氣壓: %.2f hPa\\n\", currentWeather.pressure);\n  Serial.printf(\"風速: %.2f m/s\\n\", currentWeather.windSpeed);\n  Serial.printf(\"風向: %d°\\n\", currentWeather.windDirection);\n  Serial.printf(\"UV指數: %.1f\\n\", currentWeather.uvIndex);\n  Serial.printf(\"土壤濕度: %d%%\\n\", currentWeather.soilMoisture);\n  Serial.printf(\"露點: %.2f°C\\n\", currentWeather.dewPoint);\n  Serial.printf(\"體感溫度: %.2f°C\\n\", currentWeather.heatIndex);\n  Serial.println(\"=====================\");\n}\n\nvoid saveWeatherData() {\n  // 儲存到 CSV 檔案\n  File dataFile = SPIFFS.open(\"/weather_data.csv\", FILE_APPEND);\n  if (dataFile) {\n    // 如果檔案是新的，寫入標題\n    if (dataFile.size() == 0) {\n      dataFile.println(\"Timestamp,Temperature,Humidity,Pressure,WindSpeed,WindDirection,UV,SoilMoisture,DewPoint,HeatIndex\");\n    }\n    \n    // 寫入數據\n    dataFile.printf(\"%s,%.2f,%.2f,%.2f,%.2f,%d,%.1f,%d,%.2f,%.2f\\n\",\n                    currentWeather.timestamp.c_str(),\n                    currentWeather.temperature,\n                    currentWeather.humidity,\n                    currentWeather.pressure,\n                    currentWeather.windSpeed,\n                    currentWeather.windDirection,\n                    currentWeather.uvIndex,\n                    currentWeather.soilMoisture,\n                    currentWeather.dewPoint,\n                    currentWeather.heatIndex);\n    dataFile.close();\n    Serial.println(\"數據已儲存到本地\");\n  }\n}\n\nvoid uploadToCloud() {\n  if (WiFi.status() != WL_CONNECTED) return;\n  \n  HTTPClient http;\n  http.begin(\"http://your-weather-api.com/upload\");  // 替換為實際 API\n  http.addHeader(\"Content-Type\", \"application/json\");\n  \n  // 建立 JSON 數據\n  DynamicJsonDocument doc(1024);\n  doc[\"station_id\"] = station_id;\n  doc[\"timestamp\"] = currentWeather.timestamp;\n  doc[\"temperature\"] = currentWeather.temperature;\n  doc[\"humidity\"] = currentWeather.humidity;\n  doc[\"pressure\"] = currentWeather.pressure;\n  doc[\"wind_speed\"] = currentWeather.windSpeed;\n  doc[\"wind_direction\"] = currentWeather.windDirection;\n  doc[\"uv_index\"] = currentWeather.uvIndex;\n  doc[\"soil_moisture\"] = currentWeather.soilMoisture;\n  doc[\"dew_point\"] = currentWeather.dewPoint;\n  doc[\"heat_index\"] = currentWeather.heatIndex;\n  \n  String jsonString;\n  serializeJson(doc, jsonString);\n  \n  int httpResponseCode = http.POST(jsonString);\n  \n  if (httpResponseCode > 0) {\n    String response = http.getString();\n    Serial.println(\"雲端上傳成功: \" + response);\n  } else {\n    Serial.println(\"雲端上傳失敗: \" + String(httpResponseCode));\n  }\n  \n  http.end();\n}\n\nvoid publishMQTTData() {\n  if (!mqtt.connected()) {\n    reconnectMQTT();\n  }\n  \n  if (mqtt.connected()) {\n    // 發布個別感測器數據\n    mqtt.publish(\"weather/temperature\", String(currentWeather.temperature).c_str());\n    mqtt.publish(\"weather/humidity\", String(currentWeather.humidity).c_str());\n    mqtt.publish(\"weather/pressure\", String(currentWeather.pressure).c_str());\n    mqtt.publish(\"weather/wind_speed\", String(currentWeather.windSpeed).c_str());\n    mqtt.publish(\"weather/uv_index\", String(currentWeather.uvIndex).c_str());\n    \n    // 發布完整 JSON 數據\n    DynamicJsonDocument doc(512);\n    doc[\"temp\"] = currentWeather.temperature;\n    doc[\"humidity\"] = currentWeather.humidity;\n    doc[\"pressure\"] = currentWeather.pressure;\n    doc[\"wind\"] = currentWeather.windSpeed;\n    doc[\"uv\"] = currentWeather.uvIndex;\n    \n    String jsonString;\n    serializeJson(doc, jsonString);\n    mqtt.publish(\"weather/all\", jsonString.c_str());\n    \n    Serial.println(\"MQTT 數據發布完成\");\n  }\n}",
      "language": "esp32",
      "topic": "ESP32 進階應用",
      "templateType": "atomic",
      "metadata": {
        "difficulty": "advanced",
        "tags": ["氣象站", "感測器網路", "數據收集", "雲端上傳", "統計分析", "原子式"]
      },
      "documentation": "# ESP32 氣象監測站\n\n## 功能說明\n完整的氣象監測系統，能夠收集多種氣象數據，進行本地儲存、統計分析和雲端上傳，適合農業、研究和環境監測應用。\n\n## 系統特色\n- **多感測器整合**: 溫度、濕度、氣壓、風速、風向、UV、土壤濕度\n- **數據處理**: 露點、體感溫度等衍生數據計算\n- **本地儲存**: SPIFFS 檔案系統數據記錄\n- **雲端同步**: HTTP API 和 MQTT 數據上傳\n- **統計分析**: 每日最值統計和趨勢分析\n\n## 感測器配置\n\n### 主要感測器\n```\nDHT22 (溫濕度)    → GPIO 4\nBMP280 (氣壓)     → I2C (SDA: 21, SCL: 22)\n風速計            → GPIO 2 (中斷)\n風向計            → A0 (類比)\n雨量計            → GPIO 5 (中斷)\nUV 感測器         → A3 (類比)\n土壤濕度感測器    → A6 (類比)\n```\n\n### 感測器規格\n- **DHT22**: ±0.5°C 溫度精度, ±2% 濕度精度\n- **BMP280**: ±1 hPa 氣壓精度\n- **風速計**: 脈衝式測量，0.1 m/s 解析度\n- **風向計**: 電位器式，0-360° 範圍\n- **UV 感測器**: 0-15 UV 指數範圍\n\n## 數據處理\n\n### 基本測量\n- **溫度**: 攝氏度 (°C)\n- **濕度**: 相對濕度 (%)\n- **氣壓**: 海平面氣壓 (hPa)\n- **風速**: 米/秒 (m/s)\n- **風向**: 角度 (0-360°)\n- **UV 指數**: 0-15 等級\n- **土壤濕度**: 百分比 (%)\n\n### 衍生數據\n- **露點溫度**: 基於溫濕度計算\n- **體感溫度**: Heat Index 計算\n- **風寒指數**: 低溫風速修正\n- **蒸發量**: 基於多參數估算\n\n## 數據儲存\n\n### 本地儲存 (SPIFFS)\n```csv\nTimestamp,Temperature,Humidity,Pressure,WindSpeed,WindDirection,UV,SoilMoisture,DewPoint,HeatIndex\n1634567890,25.6,65.3,1013.2,2.5,180,3.2,45,18.9,27.1\n```\n\n### 雲端儲存\n- **HTTP API**: RESTful 介面上傳\n- **MQTT**: 即時數據發布\n- **資料庫**: 長期數據儲存\n- **備份機制**: 多重備份策略\n\n## 統計分析\n\n### 每日統計\n- 最高/最低溫度\n- 最高/最低濕度\n- 最高/最低氣壓\n- 最大風速\n- 總降雨量\n- 平均 UV 指數\n\n### 趨勢分析\n- 溫度變化趨勢\n- 氣壓變化預測\n- 降雨機率計算\n- 季節性變化\n\n## 應用場景\n\n### 農業應用\n- **作物監測**: 環境條件監控\n- **灌溉控制**: 土壤濕度管理\n- **病蟲害預警**: 氣象條件分析\n- **收穫時機**: 天氣預測輔助\n\n### 研究應用\n- **氣候研究**: 長期數據收集\n- **環境監測**: 污染指標追蹤\n- **生態調查**: 棲地環境評估\n- **防災預警**: 極端天氣偵測\n\n### 商業應用\n- **觀光業**: 天氣資訊服務\n- **建築業**: 施工條件監測\n- **運輸業**: 路況安全評估\n- **能源業**: 太陽能風能評估\n\n## 網路整合\n\n### 資料上傳\n- **即時上傳**: 每5分鐘同步\n- **批量上傳**: 離線數據補傳\n- **壓縮傳輸**: 節省頻寬\n- **錯誤重試**: 網路中斷恢復\n\n### API 整合\n- **天氣 API**: 對比官方數據\n- **預報 API**: 預測準確性驗證\n- **警報 API**: 極端天氣通知\n- **分析 API**: 雲端運算服務\n\n## 維護管理\n\n### 校準程序\n- 定期與標準儀器比對\n- 感測器零點校正\n- 線性度驗證\n- 環境係數修正\n\n### 故障診斷\n- 感測器狀態檢查\n- 數據異常偵測\n- 通訊狀態監控\n- 自動恢復機制\n\n## 擴展功能\n- **太陽能供電**: 自給自足電力系統\n- **衛星通訊**: 偏遠地區連接\n- **機器學習**: 預測模型訓練\n- **視覺化系統**: 即時圖表顯示\n- **多站點網路**: 區域氣象網\n\n## 注意事項\n- 感測器需要定期校準\n- 防水防塵設計很重要\n- 考慮極端天氣影響\n- 備用電源和通訊方案\n- 數據備份和恢復機制"
    }
  ]
}